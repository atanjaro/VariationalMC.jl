<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · VariationalMC.jl</title><meta name="title" content="Usage · VariationalMC.jl"/><meta property="og:title" content="Usage · VariationalMC.jl"/><meta property="twitter:title" content="Usage · VariationalMC.jl"/><meta name="description" content="Documentation for VariationalMC.jl."/><meta property="og:description" content="Documentation for VariationalMC.jl."/><meta property="twitter:description" content="Documentation for VariationalMC.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">VariationalMC.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li><a class="tocitem" href="#Hubbard-chain"><span>Hubbard chain</span></a></li><li><a class="tocitem" href="#Hubbard-chain-with-MPI-(experimental)"><span>Hubbard chain with MPI (experimental)</span></a></li><li><a class="tocitem" href="#Hubbard-chain-with-Jastrow-factor"><span>Hubbard chain with Jastrow factor</span></a></li><li><a class="tocitem" href="#Square-Hubbard-model-with-Jastrow-factor"><span>Square Hubbard model with Jastrow factor</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/atanjaro/VariationalMC.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/atanjaro/VariationalMC.jl/blob/main/docs/src/usage.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><p>Here are a few example usage cases. </p><h2 id="Hubbard-chain"><a class="docs-heading-anchor" href="#Hubbard-chain">Hubbard chain</a><a id="Hubbard-chain-1"></a><a class="docs-heading-anchor-permalink" href="#Hubbard-chain" title="Permalink"></a></h2><p>In the first example, we will work though simulating the repulsive Hubbard model  on a 1D chain at half-filling. </p><p>The Hubbard Hamiltonian for a 1D chain is given by </p><p class="math-container">\[\hat{H} = -t \sum_{i, \sigma} (\hat{c}^{\dagger}_{i+1,\sigma}\hat{c}^{\phantom \dagger}_{i, \sigma} + {\rm h.c.})
+ U \sum_i \hat{n}_{i, \uparrow}\hat{n}_{i, \downarrow} - \mu \sum_{i, \sigma} \hat{n}_{i, \sigma},\]</p><p>where <span>$\hat{c}^\dagger_{i, \sigma} \ (\hat{c}^{\phantom \dagger}_{i, \sigma})$</span> creates (annihilates) a spin <span>$\sigma$</span> electron on site <span>$i$</span> in the lattice, and <span>$\hat{n}_{i, \sigma} = \hat{c}^\dagger_{i, \sigma} \hat{c}^{\phantom \dagger}_{i, \sigma}$</span> is the spin-<span>$\sigma$</span> electron number operator for site <span>$i$</span>. In the above Hamiltonian <span>$t$</span> is the nearest neighbor hopping integral and <span>$U &gt; 0$</span> controls the strength of the on-site Hubbard repulsion. Lastly, we consider the case that the system is half-filled and particle-hole symmetric, which occurs when when the chemical potential is zero, <span>$\mu = 0.0$</span>.</p><p>Suppose we want to simulate a half-filled Hubbard chain <span>$(\mu = 0.0)$</span> of length <span>$L=4$</span> with <span>$U=1.0$</span> with a Neél   antiferromagnet trial wavefunction and a density-density Jastrow factor.. This is accomplished by running the script associated with this example using the command</p><pre><code class="nohighlight hljs">&gt; julia hubbard_chain.jl 1 4 1.0 2 2 300 1000 2000 100</code></pre><p>Below you will find a heavily commented script that includes details on what each part of the code is doing.</p><pre><code class="language-julia hljs"># Import the required packages
using LinearAlgebra
using Random
using Printf

using LatticeUtilities
using VariationalMC

# We define a top-level function for running the VMC simulation.
# Note that the arguments of this function correspond to the command line
# arguments used to run this script.
function run_hubbard_chain_simulation(
    sID, 
    L,
    U,
    nup,
    ndn,
    N_equil,
    N_opts,
    N_updates,
    N_bins; 
    filepath=&quot;.&quot;
)
    # DEBUG flag which writes information to terminal during the simulation.
    # For efficeincy, this should always be turned off. 
    debug = false

    # Select which parameters in the variational wavefunction will be optimized.
    optimize = (
        # local s-wave pairing
        Δ_0 = false,
        # spin-x (in-plane magnetization)
        Δ_sx = false,
        # spin-z (out-of-plane magnetization)
        Δ_sz = true,
        # (BCS) chemical potential
        μ = false,
        # uniform charge density 
        Δ_cdw = false
    )

    # Specify whether the model will be particle-hole transformed.
    # Note that this is required if adding pair fields to the wavefunction.
    pht = false

    # Construct the foldername the data will be written.
    df_prefix = @sprintf &quot;hubbard_chain_U%.2f_nup%.2f_ndn%.2f_L%d_opt&quot; U, nup, ndn, L

    # Append optimized parameter names to the foldername.
    datafolder_prefix = create_datafolder_prefix(optimize, df_prefix)

    # Initialize an instance of the SimulationInfo type.
    # This type tracks of where the data is written, as well as 
    # which version of Julia and VariationalMC are used in the script. 
    simulation_info = SimulationInfo(
        filepath = filepath, 
        datafolder_prefix = datafolder_prefix,
        sID = sID
    )

    # Initialize the directory the data will be written.
    initialize_datafolder(simulation_info)

    # Initialize a random number generator that will be used throughout the simulation.
    # We seed this function with a randomly sampled number for the
    # global random number generator.
    seed = abs(rand(Int))
    rng = Xoshiro(seed)

    # Set the optimization rate for the VMC simulation.
    dt = 0.03     

    # Set the stabilization factor used in parameter optimization. 
    η = 1e-4    

    # Set the frequency in Monte Carlo steps with which the equal-time Green&#39;s function
    # matrix will be recomputed using the numerical stabilization procedure.
    n_stab_W = 50

    # Specify the maximum allowed error in the equal-time Green&#39;s function matrix that
    # is corrected by numerical stabilization.
    δW = 1e-3

    # Specify the optimization bin size.
    # The optimization bin size if the number of measurments that are averaged over each time data
    # is written to file during optimization. 
    opt_bin_size = 3000

    # Calculate the simulation bin size.
    # The bin size is the number of measurements that are averaged over each time data is written
    # to file during the simulation.
    bin_size = div(N_updates, N_bins)

    # Initialize a dictionary to store additional information about the simulation.
    # This is a sort of &quot;notebook&quot; for tracking extraneous parameters during the VMC simulation.
    metadata = Dict()
    metadata[&quot;N_equil&quot;] = N_equil
    metadata[&quot;N_opts&quot;] = N_opts
    metadata[&quot;N_updates&quot;] = N_updates
    metadata[&quot;N_bins&quot;] = N_bins
    metadata[&quot;seed&quot;] = seed
    metadata[&quot;pht&quot;] = true
    metadata[&quot;δW&quot;] = δW
    metadata[&quot;dt&quot;] = dt 
    metadata[&quot;opt_flags&quot;] = optimize 
    metadata[&quot;avg_acceptance_rate&quot;] = 0.0
    metadata[&quot;opt_time&quot;] = 0.0
    metadata[&quot;sim_time&quot;] = 0.0
    metadata[&quot;total_time&quot;] = 0.0

    #######################
    ### DEFINE THE MODEL ##
    #######################

    # Initialize an instance of the UnitCell type.
    # This struct defines the UnitCell.
    unit_cell = UnitCell(
        lattice_vecs = [[1.0]],
        basis_vecs   = [[0.0]]
    )

    # Initialize an instance of the Lattice type.
    # The struct describes the size of the finite periodic lattice to be simulated.
    # Note that the current version of LatticeUtilities requires 
    # periodic boundary conditions be used.
    lattice = Lattice(
        [L], 
        [true]
    )

    # Define the nearest neighbor bond for a 1D chain.
    bond_x = Bond(
        orbitals = (1,1), 
        displacement = [1]
    )

    # Define the next-nearest neighbor bonds for a 1D chain.
    bond_xp = Bond(
        orbitals = (1,1), 
        displacement = [2]
    )

    # Collect all bond definitions into a single vector.
    # Note that this has the structure [[nearest],[next-nearest]].
    bonds = [[bond_x], [bond_xp]]
    
    # Initialize an instance of the ModelGeometry type.
    # This type helps keep track of all the relevant features of the lattice
    # geometry being simulated, including the defintion of the unit cell,
    # the size of the finite periodic lattice, and all the relevant
    # bond defintions that may arise in the model.
    model_geometry = ModelGeometry(
        unit_cell, 
        lattice, 
        bonds
    )

    ##############################
    ### INITIALIZE MEASUREMENTS ##
    ##############################

    # Initialize the container that measurements will be accumulated into.
    measurement_container = initialize_measurement_container(
        N_opts, 
        opt_bin_size, 
        N_bins, 
        bin_size,
        determinantal_parameters,
        model_geometry
    )

    # Initialize the sub-directories to which the various measurements will be written.
    initialize_measurement_directories(
        simulation_info, 
        measurement_container
    )

    ############################
    ### SET-UP VMC SIMULATION ##
    ############################

    # Determine the total particle density in the canonical ensemble. 
    (density, Np, Ne) = get_particle_density(nup, ndn)

    # Define the nearest neighbor hopping amplitude, setting the energy scale of the system. 
    t = 1.0;

    # Define the next-nearest neighbor hopping amplitude.
    tp = 0.0;

    # Define the non-interacting tight binding model.
    tight_binding_model = TightBindingModel(t, tp)

    # Specify the minimum value of each variational parameter.
    # Note that this is done to avoid open shell issues.
    minabs_vpar = 1e-4;

    # Initialize determinantal variational parameters.
    determinantal_parameters = DeterminantalParameters(
        optimize, 
        tight_binding_model, 
        model_geometry, 
        minabs_vpar, 
        Ne, 
        pht
    )

    # Initialize the (fermionic) particle configuration cache.
    pconfig_cache = nothing

    ###########################
    ### OPTIMIZATION UPDATES ##
    ###########################

    # Record start time for optimization. 
    opt_start_time = time()

    # Iterate over optimization updates.
    for bin in 1:N_opts

        # Initialize the determinantal wavefunction.
        detwf = get_determinantal_wavefunction(
            tight_binding_model, 
            determinantal_parameters, 
            optimize, 
            Ne, 
            nup, 
            ndn, 
            model_geometry, 
            rng,
            pconfig_cache
        )   

        # Iterate over equilibration/thermalization updates.
        for step in 1:N_equil 

            # Attempt to update the fermionic particle configuration.
            (acceptance_rate, detwf) = local_fermion_update!(
                detwf, 
                Ne, 
                model_geometry, 
                n_stab_W,
                δW, 
                rng
            )

            # Record the acceptance rate for attempted local updates of the particle configuration.                                                         
            metadata[&quot;avg_acceptance_rate&quot;] += acceptance_rate;
        end

        # Iterate over the number of optimization bins.
        for n in 1:opt_bin_size

            # Attempt to update the fermionic particle configuration.
            (acceptance_rate, detwf) = local_fermion_update!(
                detwf, 
                Ne, 
                model_geometry, 
                n_stab_W,
                δW, 
                rng
            ) 
                                                                                                        
            # Record the acceptance rate for attempted local updates of the particle configuration                                                       
            metadata[&quot;avg_acceptance_rate&quot;] += acceptance_rate;
            
            # Make measurements, with results being recorded in the measurement container. 
            make_measurements!(
                measurement_container, 
                detwf, 
                tight_binding_model, 
                determinantal_parameters, 
                model_geometry, 
                Ne, 
                pht
            )

            # Write measurement for the current bin to file.
            write_measurements!(
                bin, 
                n, 
                measurement_container, 
                simulation_info
            )
        end

        # Record the last particle configuration used in the current bin. 
        pconfig_cache = detwf.pconfig

        # Process the measurement results, calculating error bars for all measurements. 
        # process_measurements(simulation_info, opt_bin_size)

        # Attempt an update to the variational parameters using the Stochastic Reconfiguration procedure. 
        stochastic_reconfiguration!( 
            measurement_container,  
            determinantal_parameters, 
            η, 
            dt, 
            bin, 
            opt_bin_size
        )  
    end     

    # Record end time for optimization.
    opt_end_time = time()

    # Calculate the total time for optimization. 
    metadata[&quot;opt_time&quot;] += opt_end_time - opt_start_time

    #########################
    ### SIMULATION UPDATES ##
    #########################

    # Record start time for the simulation.
    sim_start_time = time()

    # Iterate over simulation updates.
    for bin in 1:N_updates

        # Initialize the determinantal wavefunction.
        detwf = get_determinantal_wavefunction(
            tight_binding_model, 
            determinantal_parameters, 
            optimize, 
            Ne, 
            nup, 
            ndn, 
            model_geometry, 
            rng,
            pconfig_cache
        )   

        # Iterate over equilibration/thermalization updates.
        for step in 1:N_equil 

            # Attempt to update the fermionic particle configuration.
            (acceptance_rate, detwf) = local_fermion_update!(
                detwf, 
                Ne, 
                model_geometry, 
                n_stab_W,
                δW, 
                rng
            )

            # Record the acceptance rate for attempted local updates of the particle configuration.                                                         
            metadata[&quot;avg_acceptance_rate&quot;] += acceptance_rate;
        end

        # Iterate over the number of simulation bins.
        for n in 1:bin_size

            # Attempt to update the fermionic particle configuration.
            (acceptance_rate, detwf) = local_fermion_update!(
                detwf, 
                Ne, 
                model_geometry, 
                n_stab_W,
                δW, 
                rng
            ) 
                                                                                                        
            # Record the acceptance rate for attempted local updates of the particle configuration                                                       
            metadata[&quot;avg_acceptance_rate&quot;] += acceptance_rate;
            
            # Make measurements, with results being recorded in the measurement container. 
            make_measurements!(
                measurement_container, 
                detwf, 
                tight_binding_model, 
                determinantal_parameters, 
                model_geometry, 
                Ne, 
                pht
            )

            # Write measurement for the current bin to file.
            write_measurements!(
                bin, 
                n, 
                measurement_container, 
                simulation_info
            )
        end

        # Record the last particle configuration used in the current bin. 
        pconfig_cache = detwf.pconfig

        # Process the measurement results, calculating error bars for all measurements. 
        # process_measurements(simulation_info, bin_size)
    end     

    # Record end time for the simulation. 
    sim_end_time = time()

    # Calculate total time for the simulation. 
    metadata[&quot;sim_time&quot;] += sim_end_time - sim_start_time

    # Record the total runtime.
    metadata[&quot;total_time&quot;] += metadata[&quot;opt_time&quot;] + metadata[&quot;sim_time&quot;]

    # # Write simulation summary TOML file.
    # save_simulation_info(simulation_info, metadata)

    return nothing
end 

# Only execute if the script is run directly from the command line.
if abspath(PROGRAM_FILE) == @__FILE__

    # Read in the command line arguments.
    sID = parse(Int, ARGS[1]) # simulation ID
    L = parse(Int, ARGS[2])
    U = parse(Float64, ARGS[3])
    nup = parse(Int, ARGS[4])
    ndn = parse(Int, ARGS[5])
    N_equil = parse(Int, ARGS[6])
    N_opts = parse(Int, ARGS[7])
    N_updates = parse(Int, ARGS[8])
    N_bins = parse(Int, ARGS[9])

    # Run the simulation.
    run_hubbard_chain_simulation(sID, L, U, nup, ndn, N_equil, N_opts, N_updates, N_bins)
end</code></pre><h2 id="Hubbard-chain-with-MPI-(experimental)"><a class="docs-heading-anchor" href="#Hubbard-chain-with-MPI-(experimental)">Hubbard chain with MPI (experimental)</a><a id="Hubbard-chain-with-MPI-(experimental)-1"></a><a class="docs-heading-anchor-permalink" href="#Hubbard-chain-with-MPI-(experimental)" title="Permalink"></a></h2><p>In this example we simulate the same system as in example 1, the half-filled Hubbard chain. However in this case, we use a BCS trial wavefunction with a density-density Jastrow factor. A short tes simulation using  this script associated with this example can be run as</p><pre><code class="nohighlight hljs">&gt; mpiexecjl -n 8 julia hubbard_chain_mpi.jl 1 4 1.0 2 2 300 1000 2000 100</code></pre><p>(The script is forthcoming.)</p><h2 id="Hubbard-chain-with-Jastrow-factor"><a class="docs-heading-anchor" href="#Hubbard-chain-with-Jastrow-factor">Hubbard chain with Jastrow factor</a><a id="Hubbard-chain-with-Jastrow-factor-1"></a><a class="docs-heading-anchor-permalink" href="#Hubbard-chain-with-Jastrow-factor" title="Permalink"></a></h2><p>In this example we simulate the same system as in example 1, the half-filled Hubbard chain. However in this case, we use a BCS trial wavefunction with a density-density Jastrow factor. A short tes simulation using  this script associated with this example can be run as</p><pre><code class="nohighlight hljs">&gt; julia hubbard_chain_jastrow.jl 1 4 1.0 2 2 300 1000 2000 100</code></pre><p>Below you will find a heavily commented script that includes details on what each part of the code is doing.</p><pre><code class="language-julia hljs"># Import the required packages
using LinearAlgebra
using Random
using Printf

using LatticeUtilities
using VariationalMC

# We define a top-level function for running the VMC simulation.
# Note that the arguments of this function correspond to the command line
# arguments used to run this script.
function run_hubbard_chain_simulation(
    sID, 
    L,
    U,
    nup,
    ndn,
    N_equil,
    N_opts,
    N_updates,
    N_bins; 
    filepath=&quot;.&quot;
)
    # DEBUG flag which writes information to terminal during the simulation.
    # For efficeincy, this should always be turned off. 
    debug = false

    # Select which parameters in the variational wavefunction will be optimized.
    optimize = (
        # local s-wave pairing
        Δ_0 = true,
        # spin-x (in-plane magnetization)
        Δ_sx = false,
        # spin-z (out-of-plane magnetization)
        Δ_sz = true,
        # (BCS) chemical potential
        μ = true,
        # uniform charge density 
        Δ_cdw = false,
        # density-density Jastrow 
        djastrow = true
    )

    # Specify whether the model will be particle-hole transformed.
    # Note that this is required if adding pair fields to the wavefunction.
    pht = true

    # Construct the foldername the data will be written.
    df_prefix = @sprintf &quot;hubbard_chain_U%.2f_nup%.2f_ndn%.2f_L%d_opt&quot; U, nup, ndn, L

    # Append optimized parameter names to the foldername.
    datafolder_prefix = create_datafolder_prefix(optimize, df_prefix)

    # Initialize an instance of the SimulationInfo type.
    # This type tracks of where the data is written, as well as 
    # which version of Julia and VariationalMC are used in the script. 
    simulation_info = SimulationInfo(
        filepath = filepath, 
        datafolder_prefix = datafolder_prefix,
        sID = sID
    )

    # Initialize the directory the data will be written.
    initialize_datafolder(simulation_info)

    # Initialize a random number generator that will be used throughout the simulation.
    # We seed this function with a randomly sampled number for the
    # global random number generator.
    seed = abs(rand(Int))
    rng = Xoshiro(seed)

    # Set the optimization rate for the VMC simulation.
    dt = 0.03     

    # Set the stabilization factor used in parameter optimization. 
    η = 1e-4    

    # Set the frequency in Monte Carlo steps with which the equal-time Green&#39;s function
    # matrix will be recomputed using the numerical stabilization procedure.
    n_stab_W = 50

    # Set the frequency in Monte Carlo steps with which the Jastrow T vector will be
    # recomputed using the numerical stabilization procedure.
    n_stab_T = 50

    # Specify the maximum allowed error in the equal-time Green&#39;s function matrix that
    # is corrected by numerical stabilization.
    δW = 1e-3

    # Specify the maximum allowed error in the Jastrow T vector that is corrected 
    # by numerical stabilization.
    δT = 1e-3

    # Specify the optimization bin size.
    # The optimization bin size if the number of measurments that are averaged over each time data
    # is written to file during optimization. 
    opt_bin_size = 3000

    # Calculate the simulation bin size.
    # The bin size is the number of measurements that are averaged over each time data is written
    # to file during the simulation.
    bin_size = div(N_updates, N_bins)

    # Initialize a dictionary to store additional information about the simulation.
    # This is a sort of &quot;notebook&quot; for tracking extraneous parameters during the VMC simulation.
    metadata = Dict()
    metadata[&quot;N_equil&quot;] = N_equil
    metadata[&quot;N_opts&quot;] = N_opts
    metadata[&quot;N_updates&quot;] = N_updates
    metadata[&quot;N_bins&quot;] = N_bins
    metadata[&quot;seed&quot;] = seed
    metadata[&quot;pht&quot;] = true
    metadata[&quot;δW&quot;] = δW
    metadata[&quot;dt&quot;] = dt 
    metadata[&quot;opt_flags&quot;] = optimize 
    metadata[&quot;avg_acceptance_rate&quot;] = 0.0
    metadata[&quot;opt_time&quot;] = 0.0
    metadata[&quot;sim_time&quot;] = 0.0
    metadata[&quot;total_time&quot;] = 0.0

    #######################
    ### DEFINE THE MODEL ##
    #######################

    # Initialize an instance of the UnitCell type.
    # This struct defines the UnitCell.
    unit_cell = UnitCell(
        lattice_vecs = [[1.0]],
        basis_vecs   = [[0.0]]
    )

    # Initialize an instance of the Lattice type.
    # The struct describes the size of the finite periodic lattice to be simulated.
    # Note that the current version of LatticeUtilities requires 
    # periodic boundary conditions be used.
    lattice = Lattice(
        [L], 
        [true]
    )

    # Define the nearest neighbor bond for a 1D chain.
    bond_x = Bond(
        orbitals = (1,1), 
        displacement = [1]
    )

    # Define the next-nearest neighbor bonds for a 1D chain.
    bond_xp = Bond(
        orbitals = (1,1), 
        displacement = [2]
    )

    # Collect all bond definitions into a single vector.
    # Note that this has the structure [[nearest],[next-nearest]].
    bonds = [[bond_x], [bond_xp]]
    
    # Initialize an instance of the ModelGeometry type.
    # This type helps keep track of all the relevant features of the lattice
    # geometry being simulated, including the defintion of the unit cell,
    # the size of the finite periodic lattice, and all the relevant
    # bond defintions that may arise in the model.
    model_geometry = ModelGeometry(
        unit_cell, 
        lattice, 
        bonds
    )

    ##############################
    ### INITIALIZE MEASUREMENTS ##
    ##############################

    # Initialize the container that measurements will be accumulated into.
    measurement_container = initialize_measurement_container(
        N_opts, 
        opt_bin_size, 
        N_bins, 
        bin_size,
        determinantal_parameters,
        model_geometry
    )

    # Initialize the sub-directories to which the various measurements will be written.
    initialize_measurement_directories(
        simulation_info, 
        measurement_container
    )

    ############################
    ### SET-UP VMC SIMULATION ##
    ############################

    # Determine the total particle density in the canonical ensemble. 
    (density, Np, Ne) = get_particle_density(nup, ndn)

    # Define the nearest neighbor hopping amplitude, setting the energy scale of the system. 
    t = 1.0;

    # Define the next-nearest neighbor hopping amplitude.
    tp = 0.0;

    # Define the non-interacting tight binding model.
    tight_binding_model = TightBindingModel(t, tp)

    # Specify the minimum value of each variational parameter.
    # Note that this is done to avoid open shell issues.
    minabs_vpar = 1e-4;

    # Initialize determinantal variational parameters.
    determinantal_parameters = DeterminantalParameters(
        optimize, 
        tight_binding_model, 
        model_geometry, 
        minabs_vpar, 
        Ne, 
        pht
    )

    # Initialize density-density Jastrow variational parameters. 
    djastrow_parameters = JastrowParameters(
        &quot;e-den-den&quot;,
        optimize, 
        model_geometry,
        rng
    )

    # Initialize the (fermionic) particle configuration cache.
    pconfig_cache = nothing

    ###########################
    ### OPTIMIZATION UPDATES ##
    ###########################

    # Record start time for optimization. 
    opt_start_time = time()

    # Iterate over optimization updates.
    for bin in 1:N_opts

        # Initialize the determinantal wavefunction.
        detwf = get_determinantal_wavefunction(
            tight_binding_model, 
            determinantal_parameters, 
            optimize, 
            Ne, 
            nup, 
            ndn, 
            model_geometry, 
            rng,
            pconfig_cache
        )   

        # Initialize the density-density Jastrow factor.
        djas_factor = get_jastrow_factor(
            djastrow_parameters,
            detwf,
            model_geometry,
            pht
        )

        # Iterate over equilibration/thermalization updates.
        for step in 1:N_equil 

            # Attempt to update the fermionic particle configuration.
            (acceptance_rate, detwf, djas_factor) = local_fermion_update!(
                detwf, 
                djas_factor,
                djastrow_parameters,
                Ne, 
                model_geometry, 
                pht,
                n_stab_W,
                n_stab_T,
                δW, 
                δT,
                rng
            )

            # Record the acceptance rate for attempted local updates of the particle configuration.                                                         
            metadata[&quot;avg_acceptance_rate&quot;] += acceptance_rate;
        end

        # Iterate over the number of optimization bins.
        for n in 1:opt_bin_size

            # Attempt to update the fermionic particle configuration.
            (acceptance_rate, detwf, djas_factor) = local_fermion_update!(
                detwf, 
                djas_factor,
                djastrow_parameters,
                Ne, 
                model_geometry, 
                pht,
                n_stab_W,
                n_stab_T,
                δW, 
                δT,
                rng
            ) 
                                                                                                        
            # Record the acceptance rate for attempted local updates of the particle configuration                                                       
            metadata[&quot;avg_acceptance_rate&quot;] += acceptance_rate;
            
            # Make measurements, with results being recorded in the measurement container. 
            make_measurements!(
                measurement_container, 
                detwf, 
                tight_binding_model, 
                djas_factor,
                djastrow_parameters,
                determinantal_parameters, 
                model_geometry, 
                Ne, 
                pht
            )

            # Write measurement for the current bin to file.
            write_measurements!(
                bin, 
                n, 
                measurement_container, 
                simulation_info
            )
        end

        # Record the last particle configuration used in the current bin. 
        pconfig_cache = detwf.pconfig

        # Process the measurement results, calculating error bars for all measurements. 
        # process_measurements(simulation_info, opt_bin_size)

        # Attempt an update to the variational parameters using the Stochastic Reconfiguration procedure. 
        stochastic_reconfiguration!( 
            measurement_container,  
            determinantal_parameters, 
            djastrow_parameters,
            η, 
            dt, 
            bin, 
            opt_bin_size
        )  
    end     

    # Record end time for optimization.
    opt_end_time = time()

    # Calculate the total time for optimization. 
    metadata[&quot;opt_time&quot;] += opt_end_time - opt_start_time

    #########################
    ### SIMULATION UPDATES ##
    #########################

    # Record start time for the simulation.
    sim_start_time = time()

    # Iterate over simulation updates.
    for bin in 1:N_updates

        # Initialize the determinantal wavefunction.
        detwf = get_determinantal_wavefunction(
            tight_binding_model, 
            determinantal_parameters, 
            optimize, 
            Ne, 
            nup, 
            ndn, 
            model_geometry, 
            rng,
            pconfig_cache
        )   

        # Initialize the density-density Jastrow factor.
        djas_factor = get_jastrow_factor(
            djastrow_parameters,
            detwf,
            model_geometry,
            pht
        )

        # Iterate over equilibration/thermalization updates.
        for step in 1:N_equil 

            # Attempt to update the fermionic particle configuration.
            (acceptance_rate, detwf, djas_factor) = local_fermion_update!(
                detwf, 
                Ne, 
                model_geometry, 
                n_stab_W,
                δW, 
                rng
            )

            # Record the acceptance rate for attempted local updates of the particle configuration.                                                         
            metadata[&quot;avg_acceptance_rate&quot;] += acceptance_rate;
        end

        # Iterate over the number of simulation bins.
        for n in 1:bin_size

            # Attempt to update the fermionic particle configuration.
            (acceptance_rate, detwf) = local_fermion_update!(
                detwf, 
                djas_factor,
                djastrow_parameters,
                Ne, 
                model_geometry, 
                pht,
                n_stab_W,
                n_stab_T,
                δW, 
                δT,
                rng
            ) 
                                                                                                        
            # Record the acceptance rate for attempted local updates of the particle configuration                                                       
            metadata[&quot;avg_acceptance_rate&quot;] += acceptance_rate;
            
            # Make measurements, with results being recorded in the measurement container. 
            make_measurements!(
                measurement_container, 
                detwf, 
                tight_binding_model, 
                djas_factor,
                djastrow_parameters,
                determinantal_parameters, 
                model_geometry, 
                Ne, 
                pht
            )

            # Write measurement for the current bin to file.
            write_measurements!(
                bin, 
                n, 
                measurement_container, 
                simulation_info
            )
        end

        # Record the last particle configuration used in the current bin. 
        pconfig_cache = detwf.pconfig

        # Process the measurement results, calculating error bars for all measurements. 
        # process_measurements(simulation_info, bin_size)
    end     

    # Record end time for the simulation. 
    sim_end_time = time()

    # Calculate total time for the simulation. 
    metadata[&quot;sim_time&quot;] += sim_end_time - sim_start_time

    # Record the total runtime.
    metadata[&quot;total_time&quot;] += metadata[&quot;opt_time&quot;] + metadata[&quot;sim_time&quot;]

    # # Write simulation summary TOML file.
    # save_simulation_info(simulation_info, metadata)

    return nothing
end 

# Only execute if the script is run directly from the command line.
if abspath(PROGRAM_FILE) == @__FILE__

    # Read in the command line arguments.
    sID = parse(Int, ARGS[1]) # simulation ID
    L = parse(Int, ARGS[2])
    U = parse(Float64, ARGS[3])
    nup = parse(Int, ARGS[4])
    ndn = parse(Int, ARGS[5])
    N_equil = parse(Int, ARGS[6])
    N_opts = parse(Int, ARGS[7])
    N_updates = parse(Int, ARGS[8])
    N_bins = parse(Int, ARGS[9])

    # Run the simulation.
    run_hubbard_chain_simulation(sID, L, U, nup, ndn, N_equil, N_opts, N_updates, N_bins)
end</code></pre><h2 id="Square-Hubbard-model-with-Jastrow-factor"><a class="docs-heading-anchor" href="#Square-Hubbard-model-with-Jastrow-factor">Square Hubbard model with Jastrow factor</a><a id="Square-Hubbard-model-with-Jastrow-factor-1"></a><a class="docs-heading-anchor-permalink" href="#Square-Hubbard-model-with-Jastrow-factor" title="Permalink"></a></h2><p>In this next example, we will work though simulating the repulsive Hubbard model  on a 2D square lattice at half-filling. </p><p>The Hubbard Hamiltonian for a 2D square lattice is given by </p><p class="math-container">\[\hat{H} = -t \sum_{\langle i,j\rangle, \sigma} (\hat{c}^{\dagger}_{j,\sigma}\hat{c}^{\phantom \dagger}_{i, \sigma} + {\rm h.c.})
+ U \sum_i \hat{n}_{i, \uparrow}\hat{n}_{i, \downarrow} - \mu \sum_{i, \sigma} \hat{n}_{i, \sigma},\]</p><p>where <span>$\hat{c}^\dagger_{i, \sigma} \ (\hat{c}^{\phantom \dagger}_{i, \sigma})$</span> creates (annihilates) a spin <span>$\sigma$</span> electron on site <span>$i$</span> in the lattice, and <span>$\hat{n}_{i, \sigma} = \hat{c}^\dagger_{i, \sigma} \hat{c}^{\phantom \dagger}_{i, \sigma}$</span> is the spin-<span>$\sigma$</span> electron number operator for site <span>$i$</span>. In the above Hamiltonian <span>$t$</span> is the nearest neighbor hopping integral and <span>$U &gt; 0$</span> controls the strength of the on-site Hubbard repulsion. Lastly, we consider the case that the system is half-filled and particle-hole symmetric, which occurs when when the chemical potential is zero, <span>$\mu = 0.0$</span>.</p><p>Suppose we want to simulate a half-filled square Hubbard <span>$(\mu = 0.0)$</span> of size <span>$N=4\times 4$</span> with <span>$U=1.0$</span> with a uniform  <span>$d$</span>-wave trial wavefunction and a density-density Jastrow factor. This is accomplished by running the script associated with this example using the command</p><pre><code class="nohighlight hljs">&gt; julia hubbard_square_jastrow.jl 1 4 1.0 2 2 300 1000 2000 100</code></pre><p>Below you will find a heavily commented script that includes details on what each part of the code is doing.</p><pre><code class="language-julia hljs"># Import the required packages
using LinearAlgebra
using Random
using Printf

using LatticeUtilities
using VariationalMC

# We define a top-level function for running the VMC simulation.
# Note that the arguments of this function correspond to the command line
# arguments used to run this script.
function run_hubbard_square_simulation(
    sID, 
    L,
    U,
    nup,
    ndn,
    N_equil,
    N_opts,
    N_updates,
    N_bins; 
    filepath=&quot;.&quot;
)
    # DEBUG flag which writes information to terminal during the simulation.
    # For efficeincy, this should always be turned off. 
    debug = false

    # Select which parameters in the variational wavefunction will be optimized.
    optimize = (
        # local s-wave pairing
        Δ_0 = false,
        # site-dependent s-wave pairing  
        Δ_spd = false,
        # local d-wave pairing
        Δ_d = true,
        # site-dependent d-wave pairing 
        Δ_dpd = false,          
        # pairing momentum
        q_p = false,
        # spin-x (in-plane magnetization)
        Δ_sx = false,
        # spin-z (out-of-plane magnetization)
        Δ_sz = true,
        # site-dependent spin density
        Δ_ssd = false,
        # (BCS) chemical potential
        μ = false,
        # uniform charge density 
        Δ_cdw = false,
        # site-dependent charge density
        Δ_csd = false,
        # density-density Jastrow 
        djastrow = true,
    )

    # Specify whether the model will be particle-hole transformed.
    # Note that this is required if adding pair fields to the wavefunction.
    pht = true

    # Construct the foldername the data will be written.
    df_prefix = @sprintf &quot;hubbard_chain_U%.2f_nup%.2f_ndn%.2f_L%d_opt&quot; U, nup, ndn, L

    # Append optimized parameter names to the foldername.
    datafolder_prefix = create_datafolder_prefix(optimize, df_prefix)

    # Initialize an instance of the SimulationInfo type.
    # This type tracks of where the data is written, as well as 
    # which version of Julia and VariationalMC are used in the script. 
    simulation_info = SimulationInfo(
        filepath = filepath, 
        datafolder_prefix = datafolder_prefix,
        sID = sID
    )

    # Initialize the directory the data will be written.
    initialize_datafolder(simulation_info)

    # Initialize a random number generator that will be used throughout the simulation.
    # We seed this function with a randomly sampled number for the
    # global random number generator.
    seed = abs(rand(Int))
    rng = Xoshiro(seed)

    # Set the optimization rate for the VMC simulation.
    dt = 0.03     

    # Set the stabilization factor used in parameter optimization. 
    η = 1e-4    

    # Set the frequency in Monte Carlo steps with which the equal-time Green&#39;s function
    # matrix will be recomputed using the numerical stabilization procedure.
    n_stab_W = 50

    # Set the frequency in Monte Carlo steps with which the Jastrow T vector will be
    # recomputed using the numerical stabilization procedure.
    n_stab_T = 50

    # Specify the maximum allowed error in the equal-time Green&#39;s function matrix that
    # is corrected by numerical stabilization.
    δW = 1e-3

    # Specify the maximum allowed error in the Jastrow T vector that is corrected 
    # by numerical stabilization.
    δT = 1e-3

    # Specify the optimization bin size.
    # The optimization bin size if the number of measurments that are averaged over each time data
    # is written to file during optimization. 
    opt_bin_size = 3000

    # Calculate the simulation bin size.
    # The bin size is the number of measurements that are averaged over each time data is written
    # to file during the simulation.
    bin_size = div(N_updates, N_bins)

    # Initialize a dictionary to store additional information about the simulation.
    # This is a sort of &quot;notebook&quot; for tracking extraneous parameters during the VMC simulation.
    metadata = Dict()
    metadata[&quot;N_equil&quot;] = N_equil
    metadata[&quot;N_opts&quot;] = N_opts
    metadata[&quot;N_updates&quot;] = N_updates
    metadata[&quot;N_bins&quot;] = N_bins
    metadata[&quot;seed&quot;] = seed
    metadata[&quot;pht&quot;] = true
    metadata[&quot;δW&quot;] = δW
    metadata[&quot;dt&quot;] = dt 
    metadata[&quot;opt_flags&quot;] = optimize 
    metadata[&quot;avg_acceptance_rate&quot;] = 0.0
    metadata[&quot;opt_time&quot;] = 0.0
    metadata[&quot;sim_time&quot;] = 0.0
    metadata[&quot;total_time&quot;] = 0.0

    #######################
    ### DEFINE THE MODEL ##
    #######################

    # Initialize an instance of the UnitCell type.
    # This struct defines the UnitCell.
    unit_cell = UnitCell(
        lattice_vecs = [[1.0, 0.0], [0.0, 1.0]],
        basis_vecs   = [[0.0, 0.0]]
    )

    # Initialize an instance of the Lattice type.
    # The struct describes the size of the finite periodic lattice to be simulated.
    # Note that the current version of LatticeUtilities requires 
    # periodic boundary conditions be used.
    lattice = Lattice(
        [L, L], 
        [true, true]
    )

    # Define the nearest neighbor x-bond for a square lattice.
    bond_x = Bond(
        orbitals = (1,1), 
        displacement = [1]
    )

    # Define the nearest neighbor y-bond for a square lattice.
    bond_y = Bond(
        orbitals = (1,1), 
        displacement = [0,1]
    )

    # Define the next-nearest neighbor bonds for a square lattice.
    bond_xy = Bond(
        orbitals = (1,1), 
        displacement = [1,1]
    )

    # Define the next-nearest neighbor bonds for a square lattice.
    bond_yx = Bond(
        orbitals = (1,1), 
        displacement = [1,-1]
    )

    # Collect all bond definitions into a single vector.
    # Note that this has the structure [[nearest],[next-nearest]].
    bonds = [[bond_x, bond_y], [bond_xy, bond_yx]]
    
    # Initialize an instance of the ModelGeometry type.
    # This type helps keep track of all the relevant features of the lattice
    # geometry being simulated, including the defintion of the unit cell,
    # the size of the finite periodic lattice, and all the relevant
    # bond defintions that may arise in the model.
    model_geometry = ModelGeometry(
        unit_cell, 
        lattice, 
        bonds
    )

    ##############################
    ### INITIALIZE MEASUREMENTS ##
    ##############################

    # Initialize the container that measurements will be accumulated into.
    measurement_container = initialize_measurement_container(
        N_opts, 
        opt_bin_size, 
        N_bins, 
        bin_size,
        determinantal_parameters,
        model_geometry
    )

    # Initialize the sub-directories to which the various measurements will be written.
    initialize_measurement_directories(
        simulation_info, 
        measurement_container
    )

    ############################
    ### SET-UP VMC SIMULATION ##
    ############################

    # Determine the total particle density in the canonical ensemble. 
    (density, Np, Ne) = get_particle_density(nup, ndn)

    # Define the nearest neighbor hopping amplitude, setting the energy scale of the system. 
    t = 1.0;

    # Define the next-nearest neighbor hopping amplitude.
    tp = 0.0;

    # Define the non-interacting tight binding model.
    tight_binding_model = TightBindingModel(t, tp)

    # Specify the minimum value of each variational parameter.
    # Note that this is done to avoid open shell issues.
    minabs_vpar = 1e-4;

    # Initialize determinantal variational parameters.
    determinantal_parameters = DeterminantalParameters(
        optimize, 
        tight_binding_model, 
        model_geometry, 
        minabs_vpar, 
        Ne, 
        pht
    )

    # Initialize density-density Jastrow variational parameters. 
    djastrow_parameters = JastrowParameters(
        &quot;e-den-den&quot;,
        optimize, 
        model_geometry,
        rng
    )

    # Initialize the (fermionic) particle configuration cache.
    pconfig_cache = nothing

    ###########################
    ### OPTIMIZATION UPDATES ##
    ###########################

    # Record start time for optimization. 
    opt_start_time = time()

    # Iterate over optimization updates.
    for bin in 1:N_opts

        # Initialize the determinantal wavefunction.
        detwf = get_determinantal_wavefunction(
            tight_binding_model, 
            determinantal_parameters, 
            optimize, 
            Ne, 
            nup, 
            ndn, 
            model_geometry, 
            rng,
            pconfig_cache
        )   

        # Initialize the density-density Jastrow factor.
        djas_factor = get_jastrow_factor(
            djastrow_parameters,
            detwf,
            model_geometry,
            pht
        )

        # Iterate over equilibration/thermalization updates.
        for step in 1:N_equil 

            # Attempt to update the fermionic particle configuration.
            (acceptance_rate, detwf, djas_factor) = local_fermion_update!(
                detwf, 
                djas_factor,
                djastrow_parameters,
                Ne, 
                model_geometry, 
                pht,
                n_stab_W,
                n_stab_T,
                δW, 
                δT,
                rng
            )

            # Record the acceptance rate for attempted local updates of the particle configuration.                                                         
            metadata[&quot;avg_acceptance_rate&quot;] += acceptance_rate;
        end

        # Iterate over the number of optimization bins.
        for n in 1:opt_bin_size

            # Attempt to update the fermionic particle configuration.
            (acceptance_rate, detwf, djas_factor) = local_fermion_update!(
                detwf, 
                djas_factor,
                djastrow_parameters,
                Ne, 
                model_geometry, 
                pht,
                n_stab_W,
                n_stab_T,
                δW, 
                δT,
                rng
            ) 
                                                                                                        
            # Record the acceptance rate for attempted local updates of the particle configuration                                                       
            metadata[&quot;avg_acceptance_rate&quot;] += acceptance_rate;
            
            # Make measurements, with results being recorded in the measurement container. 
            make_measurements!(
                measurement_container, 
                detwf, 
                tight_binding_model, 
                djas_factor,
                djastrow_parameters,
                determinantal_parameters, 
                model_geometry, 
                Ne, 
                pht
            )

            # Write measurement for the current bin to file.
            write_measurements!(
                bin, 
                n, 
                measurement_container, 
                simulation_info
            )
        end

        # Record the last particle configuration used in the current bin. 
        pconfig_cache = detwf.pconfig

        # Process the measurement results, calculating error bars for all measurements. 
        # process_measurements(simulation_info, opt_bin_size)

        # Attempt an update to the variational parameters using the Stochastic Reconfiguration procedure. 
        stochastic_reconfiguration!( 
            measurement_container,  
            determinantal_parameters, 
            djastrow_parameters,
            η, 
            dt, 
            bin, 
            opt_bin_size
        )  
    end     

    # Record end time for optimization.
    opt_end_time = time()

    # Calculate the total time for optimization. 
    metadata[&quot;opt_time&quot;] += opt_end_time - opt_start_time

    #########################
    ### SIMULATION UPDATES ##
    #########################

    # Record start time for the simulation.
    sim_start_time = time()

    # Iterate over simulation updates.
    for bin in 1:N_updates

        # Initialize the determinantal wavefunction.
        detwf = get_determinantal_wavefunction(
            tight_binding_model, 
            determinantal_parameters, 
            optimize, 
            Ne, 
            nup, 
            ndn, 
            model_geometry, 
            rng,
            pconfig_cache
        )   

        # Initialize the density-density Jastrow factor.
        djas_factor = get_jastrow_factor(
            djastrow_parameters,
            detwf,
            model_geometry,
            pht
        )

        # Iterate over equilibration/thermalization updates.
        for step in 1:N_equil 

            # Attempt to update the fermionic particle configuration.
            (acceptance_rate, detwf, djas_factor) = local_fermion_update!(
                detwf, 
                Ne, 
                model_geometry, 
                n_stab_W,
                δW, 
                rng
            )

            # Record the acceptance rate for attempted local updates of the particle configuration.                                                         
            metadata[&quot;avg_acceptance_rate&quot;] += acceptance_rate;
        end

        # Iterate over the number of simulation bins.
        for n in 1:bin_size

            # Attempt to update the fermionic particle configuration.
            (acceptance_rate, detwf) = local_fermion_update!(
                detwf, 
                djas_factor,
                djastrow_parameters,
                Ne, 
                model_geometry, 
                pht,
                n_stab_W,
                n_stab_T,
                δW, 
                δT,
                rng
            ) 
                                                                                                        
            # Record the acceptance rate for attempted local updates of the particle configuration                                                       
            metadata[&quot;avg_acceptance_rate&quot;] += acceptance_rate;
            
            # Make measurements, with results being recorded in the measurement container. 
            make_measurements!(
                measurement_container, 
                detwf, 
                tight_binding_model, 
                djas_factor,
                djastrow_parameters,
                determinantal_parameters, 
                model_geometry, 
                Ne, 
                pht
            )

            # Write measurement for the current bin to file.
            write_measurements!(
                bin, 
                n, 
                measurement_container, 
                simulation_info
            )
        end

        # Record the last particle configuration used in the current bin. 
        pconfig_cache = detwf.pconfig

        # Process the measurement results, calculating error bars for all measurements. 
        # process_measurements(simulation_info, bin_size)
    end     

    # Record end time for the simulation. 
    sim_end_time = time()

    # Calculate total time for the simulation. 
    metadata[&quot;sim_time&quot;] += sim_end_time - sim_start_time

    # Record the total runtime.
    metadata[&quot;total_time&quot;] += metadata[&quot;opt_time&quot;] + metadata[&quot;sim_time&quot;]

    # # Write simulation summary TOML file.
    # save_simulation_info(simulation_info, metadata)

    return nothing
end 

# Only execute if the script is run directly from the command line.
if abspath(PROGRAM_FILE) == @__FILE__

    # Read in the command line arguments.
    sID = parse(Int, ARGS[1]) # simulation ID
    L = parse(Int, ARGS[2])
    U = parse(Float64, ARGS[3])
    nup = parse(Int, ARGS[4])
    ndn = parse(Int, ARGS[5])
    N_equil = parse(Int, ARGS[6])
    N_opts = parse(Int, ARGS[7])
    N_updates = parse(Int, ARGS[8])
    N_bins = parse(Int, ARGS[9])

    # Run the simulation.
    run_hubbard_square_simulation(sID, L, U, nup, ndn, N_equil, N_opts, N_updates, N_bins)
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Tuesday 17 June 2025 18:40">Tuesday 17 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
