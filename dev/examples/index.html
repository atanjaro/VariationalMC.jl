<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Examples · VariationalMC.jl</title><meta name="title" content="Examples · VariationalMC.jl"/><meta property="og:title" content="Examples · VariationalMC.jl"/><meta property="twitter:title" content="Examples · VariationalMC.jl"/><meta name="description" content="Documentation for VariationalMC.jl."/><meta property="og:description" content="Documentation for VariationalMC.jl."/><meta property="twitter:description" content="Documentation for VariationalMC.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">VariationalMC.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Examples</a><ul class="internal"><li><a class="tocitem" href="#Import-packages"><span>Import packages</span></a></li><li><a class="tocitem" href="#Specify-simulation-parameters"><span>Specify simulation parameters</span></a></li><li><a class="tocitem" href="#Initialize-simulation"><span>Initialize simulation</span></a></li><li><a class="tocitem" href="#Initialize-simulation-metadata"><span>Initialize simulation metadata</span></a></li><li><a class="tocitem" href="#Initialize-model"><span>Initialize model</span></a></li><li><a class="tocitem" href="#Initialize-model-parameters"><span>Initialize model parameters</span></a></li><li><a class="tocitem" href="#Initialize-measurements"><span>Initialize measurements</span></a></li><li><a class="tocitem" href="#Optimize-the-variational-parameters"><span>Optimize the variational parameters</span></a></li><li><a class="tocitem" href="#Simulate-the-system-with-optimized-parameters"><span>Simulate the system with optimized parameters</span></a></li><li><a class="tocitem" href="#Record-simulation-metadata"><span>Record simulation metadata</span></a></li><li><a class="tocitem" href="#Post-processing"><span>Post-processing</span></a></li><li><a class="tocitem" href="#Execute-script"><span>Execute script</span></a></li><li class="toplevel"><a class="tocitem" href="#2)-Hubbard-model-on-a-square-lattice-(with-Jastrow-factor)"><span>2) Hubbard model on a square lattice (with Jastrow factor)</span></a></li><li><a class="tocitem" href="#Import-packages-2"><span>Import packages</span></a></li><li><a class="tocitem" href="#Specify-simulation-parameters-2"><span>Specify simulation parameters</span></a></li><li><a class="tocitem" href="#Initialize-simulation-2"><span>Initialize simulation</span></a></li><li><a class="tocitem" href="#Initialize-simulation-metadata-2"><span>Initialize simulation metadata</span></a></li><li><a class="tocitem" href="#Initialize-model-2"><span>Initialize model</span></a></li><li><a class="tocitem" href="#Initialize-model-parameters-2"><span>Initialize model parameters</span></a></li><li><a class="tocitem" href="#Initialize-measurements-2"><span>Initialize measurements</span></a></li><li><a class="tocitem" href="#Optimize-the-variational-parameters-2"><span>Optimize the variational parameters</span></a></li><li><a class="tocitem" href="#Simulate-the-system-with-optimized-parameters-2"><span>Simulate the system with optimized parameters</span></a></li><li><a class="tocitem" href="#Record-simulation-metadata-2"><span>Record simulation metadata</span></a></li><li><a class="tocitem" href="#Post-processing-2"><span>Post-processing</span></a></li><li><a class="tocitem" href="#Execute-script-2"><span>Execute script</span></a></li></ul></li><li><a class="tocitem" href="../simulation_output/">Simulation Output Overview</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Examples</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/atanjaro/VariationalMC.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/atanjaro/VariationalMC.jl/blob/main/docs/src/examples.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="1)-Hubbard-model-on-a-1D-chain-(without-Jastrow-factor)"><a class="docs-heading-anchor" href="#1)-Hubbard-model-on-a-1D-chain-(without-Jastrow-factor)">1) Hubbard model on a 1D chain (without Jastrow factor)</a><a id="1)-Hubbard-model-on-a-1D-chain-(without-Jastrow-factor)-1"></a><a class="docs-heading-anchor-permalink" href="#1)-Hubbard-model-on-a-1D-chain-(without-Jastrow-factor)" title="Permalink"></a></h1><p>Download this example as a <a href="https://github.com/atanjaro/VariationalMC.jl/tree/e07eb401cbe7123b875da159f0372c9001c6cf41/examples">Julia script</a>.</p><p>In this example, we will work through simulating a repulsive Hubbard model on a one dimensional (1D) chain. The Hubbard hamiltonian in 1D is given by</p><p class="math-container">\[\hat{H} = -t \sum_{i, \sigma} (\hat{c}^{\dagger}_{i, \sigma}, \hat{c}^{\phantom \dagger}_{i+1, \sigma} + {\rm H.c.})
-t^{\prime} \sum_{i, \sigma} (\hat{c}^{\dagger}_{i, \sigma}, \hat{c}^{\phantom \dagger}_{i+2, \sigma} + {\rm h.c.})
+ U \sum_i \hat{n}_{i, \uparrow}\hat{n}_{i, \downarrow} 
- \mu \sum_{i, \sigma} \hat{n}_{i, \sigma},\]</p><p>where <span>$\hat{c}^\dagger_{i, \sigma} \ (\hat{c}^{\phantom \dagger}_{i, \sigma})$</span> creates (annihilates) a spin <span>$\sigma$</span> electron on site <span>$i$</span> in the lattice, and <span>$\hat{n}_{i, \sigma} = \hat{c}^\dagger_{i, \sigma} \hat{c}^{\phantom \dagger}_{i, \sigma}$</span> is the spin-<span>$\sigma$</span> electron number operator for site <span>$i$</span>. In the above Hamiltonian <span>$(t^{\prime}) \ t$</span> is the (next-) nearest-neighbor hopping amplitude and <span>$U &gt; 0$</span> controls the strength of the on-site Hubbard repulsion. Lastly, we note the system is half-filled and particle-hole symmetric when the next-nearest-neighbor hopping amplitude and the chemical potential is zero <span>$(t^{\prime} = \mu = 0.0)$</span>.</p><h2 id="Import-packages"><a class="docs-heading-anchor" href="#Import-packages">Import packages</a><a id="Import-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Import-packages" title="Permalink"></a></h2><p>We begin by importing the necessary packages, including the Standard Library packages <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">LinearAlgebra</a>, <a href="https://docs.julialang.org/en/v1/stdlib/Random/">Random</a>, and <a href="https://docs.julialang.org/en/v1/stdlib/Printf/">Printf</a> for perfroming linear algebra operations, random number generation, and C-style string formatting, respectively.</p><pre><code class="language-julia hljs">using Linear Algebra
using Random
using Printf</code></pre><p>Next, we use <a href="https://github.com/SmoQySuite/LatticeUtilities.jl">LatticeUtilities</a> which exports a suite of types and methods useful for defining arbitrary lattice geometries, and the construction of neighbor tables. Finally, we import the <a href="https://github.com/atanjaro/VariationalMC.jl">VariationalMC</a> package.</p><pre><code class="language-julia hljs">using LatticeUtilities
using VariationalMC</code></pre><h2 id="Specify-simulation-parameters"><a class="docs-heading-anchor" href="#Specify-simulation-parameters">Specify simulation parameters</a><a id="Specify-simulation-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Specify-simulation-parameters" title="Permalink"></a></h2><p>The main body of the simulation is wrapped in a top-level function named <code>run_hubbard_chain_simulation</code>that will take as keyword arguments various model and simulation parameters that we may want to change. The specific meaning of each argument will be discussed in more detail in later sections of the tutorial.</p><pre><code class="language-julia hljs"># We define a top-level function for running the VMC simulation.
function run_hubbard_chain_simulation(
    sID,            # Simulation ID.
    L,              # System size.
    U,              # Hubbard interaction.
    nup,            # Number of spin-up electrons.
    ndn,            # Number of spin-down electrons.
    N_equil,        # Number of equilibration/thermalization steps.
    N_opt,          # Number of optimization steps.
    N_opt_bins,     # Number of optimization bins.
    N_sim,          # Number of simulation steps.
    N_sim_bins;     # Number of simulation bins.
    filepath=&quot;.&quot;    # Filepath to where the datafolder will be created.
)</code></pre><h2 id="Initialize-simulation"><a class="docs-heading-anchor" href="#Initialize-simulation">Initialize simulation</a><a id="Initialize-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-simulation" title="Permalink"></a></h2><p>In this initial part of the script, we will specify what parameters in the trial wavefunction will be optimized and name our simulation. The <code>NamedTuple</code> called <code>optimized</code> will contain all possible parameters that are automatically initialized in the wavefunction. Setting a flag to <code>true</code> will cause that parameter value (or values) to change during the optimization. We also specify whether the model is particle-hole transformed and is required to be <code>true</code> if pairing symmetery is being added to the wavefunction. </p><pre><code class="language-julia hljs">    # Select which parameters in the variational wavefunction will be optimized.
    optimize = (
        # Spin-x or in-plane magnetization
        Δ_sx = false,
        # Spin-z or out-of-plane magnetization
        Δ_sz = true,
        # (BCS) Chemical potential
        μ = false,
        # Uniform charge density or Charge Density Wave
        Δ_cdw = false,
        # Density-density Jastrow factor
        density_J = false
    )

    # Specify whether the model will be particle-hole transformed.
    pht = false</code></pre><p>The datafolder is created by initializing an instances of the <code>SimulationInfo</code> type, and then calling the <code>initialize_datafolder</code> function.</p><pre><code class="language-julia hljs">    # Construct the foldername the data will be written.
    df_prefix = @sprintf(&quot;hubbard_chain_U%.2f_nup%.2f_ndn%.2f_L%d_opt&quot;, U, nup, ndn, L)

    # Append optimized parameter names to the foldername.
    datafolder_prefix = create_datafolder_prefix(optimize, df_prefix)

    # Initialize an instance of the SimulationInfo type.
    simulation_info = SimulationInfo(
        filepath = filepath, 
        datafolder_prefix = datafolder_prefix,
        sID = sID
    )

    # Initialize the directory the data will be written.
    initialize_datafolder(simulation_info)</code></pre><p>Next, we specify the parameters which control the VMC simulation. Specifically, we seed the random number generator, set the rate of optimization, and set thresholds for numerical stability. In practice, may <code>dt</code> need to be changed depending upon the quality of the convergence.</p><pre><code class="language-julia hljs">    # Initialize a random number generator that will be used throughout the simulation.
    seed = abs(rand(Int))
    rng = Xoshiro(seed)

    # Set the optimization rate for the VMC simulation.
    dt = 0.1

    # Set the stabilization factor used in parameter optimization. 
    η = 1e-4    

    # Set the frequency in Monte Carlo steps with which the equal-time Green&#39;s function matrix will be recomputed using the numerical stabilization procedure.
    n_stab_W = 50

    # Specify the maximum allowed error in the equal-time Green&#39;s function matrix that is corrected by numerical stabilization.
    δW = 1e-3</code></pre><p>In addition, we can calculate the length of each bin by dividing the number of iterations/steps by the number of bins. The bin size is the number of measurements that are averaged over each time data is written during either the optimization or simulation steps.</p><pre><code class="language-julia hljs">    # Calculate optimization bins size.
    opt_bin_size = div(N_opt, N_opt_bins) 

    # Calculate simulation bins size.
    sim_bin_size = div(N_sim, N_sim_bins)</code></pre><h2 id="Initialize-simulation-metadata"><a class="docs-heading-anchor" href="#Initialize-simulation-metadata">Initialize simulation metadata</a><a id="Initialize-simulation-metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-simulation-metadata" title="Permalink"></a></h2><p>In this section of the code we record important metadata about the simulation, including initializing the random number generator that will be used throughout the simulation. The important metadata within the simulation will be recorded in the <code>metadata</code> dictionary.</p><pre><code class="language-julia hljs">    # Record simulation metadata.
    metadata = Dict()
    metadata[&quot;seed&quot;] = seed
    metadata[&quot;pht&quot;] = pht
    metadata[&quot;N_equil&quot;] = N_equil
    metadata[&quot;N_opt&quot;] = N_opt
    metadata[&quot;N_sim&quot;] = N_sim
    metadata[&quot;N_opt_bins&quot;] = N_opt_bins
    metadata[&quot;N_sim_bins&quot;] = N_sim_bins
    metadata[&quot;δW&quot;] = δW
    metadata[&quot;n_stab_W&quot;] = n_stab_W
    metadata[&quot;dt&quot;] = dt 
    metadata[&quot;opt_flags&quot;] = optimize 
    metadata[&quot;acceptance_rate&quot;] = 0.0
    metadata[&quot;opt_time&quot;] = 0.0
    metadata[&quot;sim_time&quot;] = 0.0
    metadata[&quot;vmc_time&quot;] = 0.0</code></pre><p>In the above, <code>sID</code> stands for simulation ID, which is used to distinguish simulations that would otherwise be identical i.e. to distinguish simulations that use the same parameters and are only different in the random seed used to initialize the simulation. A valid <code>sID</code> is any positive integer greater than zero, and is used when naming the data folder the simulation results will be written to. Specifically, the actual data folder created above will be <code>&quot;$(filepath)/$(datafolder_prefix)-$(sID)&quot;</code>. Note that if you set <code>sID = 0</code>, then it will instead be assigned smallest previously unused integer value. For instance, suppose the directory <code>&quot;$(filepath)/$(datafolder_prefix)-1&quot;</code> already exits. Then if you pass <code>sID = 0</code> to <code>SimulationInfo</code>, then the simulation ID <code>sID = 2</code> will be used instead, and a directory <code>&quot;$(filepath)/$(datafolder_prefix)-2&quot;</code> will be created.</p><h2 id="Initialize-model"><a class="docs-heading-anchor" href="#Initialize-model">Initialize model</a><a id="Initialize-model-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-model" title="Permalink"></a></h2><p>The next part of the script defines the model that we will simulate. First we define the lattice geometry for our model, relying on the <a href="https://github.com/SmoQySuite/LatticeUtilities.jl.git">LatticeUtilities</a> package to do so. We define a the unit cell and size of our finite lattice using the <a href="https://smoqysuite.github.io/LatticeUtilities.jl/stable/api/#LatticeUtilities.UnitCell"><code>UnitCell</code></a> and <a href="https://smoqysuite.github.io/LatticeUtilities.jl/stable/api/#LatticeUtilities.Lattice"><code>Lattice</code></a> types, respectively. Lastly, we define various instances of the <a href="https://smoqysuite.github.io/LatticeUtilities.jl/stable/api/#LatticeUtilities.Bond"><code>Bond</code></a> type to represent the the nearest-neighbor and next-nearest-neighbor bonds. All of this information regarding the lattice geometry is then stored in an instance of the <code>ModelGeometry</code> type.</p><pre><code class="language-julia hljs">    # Initialize an instance of the UnitCell type.
    unit_cell = UnitCell(
        lattice_vecs = [[1.0]],
        basis_vecs   = [[0.0]]
    )

    # Initialize an instance of the Lattice type.
    lattice = Lattice(
        [L], 
        [true]
    )

    # Define the nearest neighbor bonds.
    bond_x = Bond(
        orbitals = (1,1), 
        displacement = [1]
    )

    # Define next-nearest neighbor bonds.
    bond_xp = Bond(
        orbitals = (1,1), 
        displacement = [2]
    )

    # Collect all bond definitions into a single vector.
    # Note that this has the structure [[nearest],[next-nearest]].
    bonds = [[bond_x], [bond_xp]]

    # Initialize an instance of the ModelGeometry type.
    model_geometry = ModelGeometry(
        unit_cell, 
        lattice, 
        bonds
    )</code></pre><h2 id="Initialize-model-parameters"><a class="docs-heading-anchor" href="#Initialize-model-parameters">Initialize model parameters</a><a id="Initialize-model-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-model-parameters" title="Permalink"></a></h2><p>The next step is to initialize our model parameters, which includes calculating the particle density in the canonical ensemble. The <code>get_particle_density</code> method includes mutliple ways of specifying the particle information. Here, we have chosen to pass the number of spin-up and spin-down particles. The function then computes the corresponding total density, particle number, and electron number.</p><pre><code class="language-julia hljs">    # Determine the total particle density in the canonical ensemble. 
    (density, Np, Ne, nup, ndn) = get_particle_density(nup, ndn, model_geometry, pht) </code></pre><p>We then specify parameters for our tight binding model and initializes all of the parameters that are in the determinantal part of the trial wavefunction. We can also set an initial particle configuration, if we have one. If an empty array is provided instead, a random configuration will be given at the start of the simulation. </p><pre><code class="language-julia hljs">    # Define the nearest neighbor hopping amplitude, setting the energy scale of the system. 
    t = 1.0

    # Define the next-nearest neighbor hopping amplitude.
    tp = 0.0

    # Define the third-nearest neighbor hopping amplitude.
    tpd = 0.0

    # Define the non-interacting tight binding model.
    tight_binding_model = TightBindingModel(t, tp, tpd)

    # Initialize determinantal variational parameters.
    determinantal_parameters = DeterminantalParameters(
        optimize, 
        tight_binding_model, 
        model_geometry, 
        Ne, 
        pht
    )

    # Initialize the (fermionic) particle configuration.
    pconfig = Int[]</code></pre><h2 id="Initialize-measurements"><a class="docs-heading-anchor" href="#Initialize-measurements">Initialize measurements</a><a id="Initialize-measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Initialize-measurements" title="Permalink"></a></h2><p>Finally, we initialize the mesaurement container, which accumulates the sums of measurements made in a bin. The standard measurements are of the local energy <code>local_energy</code>, double occupancy <code>double_occ</code>, particle confiugurations <code>pconfig</code>, and variational parameters <code>parameters</code>. There is also the option to add additional observables to measure through the <code>initialize_simulation_measurement!</code>and <code>initialize_correlation_measurement!</code> methods. </p><pre><code class="language-julia hljs">    # Initialize the container that measurements will be accumulated into.
    measurement_container = initialize_measurement_container(
        N_opt, 
        opt_bin_size, 
        N_sim, 
        sim_bin_size,
        determinantal_parameters,
        model_geometry
    )</code></pre><p>The <code>initialize_measurement_directories</code> can now be used used to initialize the various subdirectories in the data folder that the measurements will be written to. For more information, please refer to the Simulation Output Overview page.</p><pre><code class="language-julia hljs">    # Initialize the sub-directories to which the various measurements will be written.
    initialize_measurement_directories(
        simulation_info, 
        measurement_container
    )</code></pre><h2 id="Optimize-the-variational-parameters"><a class="docs-heading-anchor" href="#Optimize-the-variational-parameters">Optimize the variational parameters</a><a id="Optimize-the-variational-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Optimize-the-variational-parameters" title="Permalink"></a></h2><p>Now that we have set-up the VMC simulation, we can begin optimizing the variational parameters. At the start of each bin, we initialize the variational wavefunction. On the first iteration, if no initial configuration is specified, a random one will be generated. In this example, we are neglecting the inclusion of the Jastrow correlation factor here for demonstration purposes but it can be included (see Example 2).</p><pre><code class="language-julia hljs">        # Initialize the determinantal wavefunction.
        detwf = get_determinantal_wavefunction(
            tight_binding_model, 
            determinantal_parameters, 
            optimize, 
            Np, 
            nup, 
            ndn, 
            model_geometry, 
            rng,
            pht,
            pconfig
        )  </code></pre><p>This next section of the code equilibrates/thermalizes the system before making measurements. Within the equilibration loop, the structure is fairly simple: the <code>local_fermion_update!</code> function is called to sweep over the particle configuration, attempting to update particle positions. Here, the number of updates performed before measurement is <code>N_equil</code> and <code>opt_bin_size</code> refers to the length of each bin from <code>N_opt_bins</code>.</p><p>The quantities <code>n_stab_W</code> and <code>δW</code> are passed to the <code>local_fermion_update!</code> function and controls the stability of the equal-time Green&#39;s function matrix <code>W</code>. After <code>n_stab_W</code> fermionic updates, there is a deviation check performed and if it exceeds the threshold <code>δW</code>, then the Green&#39;s function is recomputed from scratch.</p><p>Finally, the number of measurements that are averaged over per bin is given by <code>opt_bin_size = N_opt ÷ N_opt_bins</code>. The bin-averaged measurements are written to file once <code>bin_size</code> measurements are accumulated using the <code>write_measurements!</code> function.</p><pre><code class="language-julia hljs">        # Iterate over optimization bin length
        for n in 1:opt_bin_size

            # Iterate over equilibration/thermalization updates
            for equil in 1:N_equil
                (acceptance_rate, detwf) = local_fermion_update!(
                    detwf, 
                    Np, 
                    model_geometry, 
                    n_stab_W,
                    δW, 
                    rng
                )

                # Record acceptance rate.
                metadata[&quot;acceptance_rate&quot;] += acceptance_rate
            end

            # Make measurements, with results being recorded in the measurement container.
            make_measurements!(
                measurement_container, 
                detwf, 
                tight_binding_model, 
                determinantal_parameters, 
                optimize,
                model_geometry, 
                U,
                Np, 
                pht
            )
        end</code></pre><p>After the last measurement is made, the last particle configuration is recorded globally for use in the initialization of the determinantal wavefunction for the next bin. </p><pre><code class="language-julia hljs">        # Record the last particle configuration used for the start of the next bin.
        pconfig = detwf.pconfig</code></pre><p>The primary part of this step of the simulation is the optimization of the variational parameters. Since all measurements for this bin have already been accumulated in the <code>measurement_container</code>, the <code>optimize_parameters!</code> function need only apply the Stochastic Reconfiguration (SR) procedure. Once an SR iteration is complete, all measurements are written to file. The <code>write_measurements!</code> method has an optional argument to write the parameter values to file, which we want for the optimization step.</p><pre><code class="language-julia hljs">        # Attempt to update the variational parameters using the Stochastic Reconfiguration procedure. 
        optimize_parameters!( 
            measurement_container,  
            determinantal_parameters, 
            η, 
            dt, 
            opt_bin_size
        )  

        # Write measurement for the current bin to file.
        write_measurements!(
            &quot;opt&quot;,
            bin, 
            opt_bin_size,
            measurement_container, 
            simulation_info,
            write_parameters=true
        )</code></pre><h2 id="Simulate-the-system-with-optimized-parameters"><a class="docs-heading-anchor" href="#Simulate-the-system-with-optimized-parameters">Simulate the system with optimized parameters</a><a id="Simulate-the-system-with-optimized-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Simulate-the-system-with-optimized-parameters" title="Permalink"></a></h2><p>In this next section, we continue to sample particle configurations using <code>local_fermion_update!</code> function but without the SR optimization. This is mainly done to ensure proper statistics in calculating observables like the local energy. </p><pre><code class="language-julia hljs">    # Iterate over simulation bins.
    for bin in 1:N_sim_bins

        # Initialize the determinantal wavefunction.
        detwf = get_determinantal_wavefunction(
            tight_binding_model, 
            determinantal_parameters, 
            optimize, 
            Np, 
            nup, 
            ndn, 
            model_geometry, 
            rng,
            pht,
            pconfig
        )  

        # Iterate over optimization bin length
        for n in 1:sim_bin_size

            # Iterate over equilibration/thermalization updates
            for equil in 1:N_equil
                (acceptance_rate, detwf) = local_fermion_update!(
                    detwf, 
                    Np, 
                    model_geometry, 
                    n_stab_W,
                    δW, 
                    rng
                )

                # Record acceptance rate.
                metadata[&quot;acceptance_rate&quot;] += acceptance_rate
            end

            # Make measurements, with results being recorded in the measurement container.
            make_measurements!(
                measurement_container, 
                detwf, 
                tight_binding_model, 
                model_geometry, 
                U,
                Np, 
                pht
            )
        end

        # Record the last particle configuration used for the start of the next bin.
        pconfig = detwf.pconfig

        # Write measurement for the current bin to file.
        write_measurements!(
            &quot;sim&quot;,
            bin, 
            sim_bin_size,
            measurement_container, 
            simulation_info
        )
    end</code></pre><h2 id="Record-simulation-metadata"><a class="docs-heading-anchor" href="#Record-simulation-metadata">Record simulation metadata</a><a id="Record-simulation-metadata-1"></a><a class="docs-heading-anchor-permalink" href="#Record-simulation-metadata" title="Permalink"></a></h2><p>Now that the optimization and simulation of the system are complete, we calculate the total time of the VMC simulation and the average final acceptance rate. Such information is saved to file using the <code>model_summary</code> function. </p><pre><code class="language-julia hljs">    # Record the total VMC time.
    metadata[&quot;vmc_time&quot;] += metadata[&quot;opt_time&quot;] + metadata[&quot;sim_time&quot;]

    # Normalize acceptance rate.
    metadata[&quot;acceptance_rate&quot;] /=  (N_opt + N_sim)

    # Write model summary to file.
    model_summary(simulation_info, metadata)</code></pre><h2 id="Post-processing"><a class="docs-heading-anchor" href="#Post-processing">Post-processing</a><a id="Post-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Post-processing" title="Permalink"></a></h2><p>During the simulation, all measurments are written to file in HDF5 format for speed and portability; however, for analyzing data, having CSV files are mush more convenient. Calling the <code>process_measurements</code> function accomoplishes this. It will then up to the user to determine final processing and statistics. It should be noted that the next version of the code will have a convergence detection module and plotting function. </p><pre><code class="language-julia hljs">    # Process all optimization and simulation measurements.
    process_measurements(
        measurement_container, 
        simulation_info, 
        determinantal_parameters,
        model_geometry
    )</code></pre><h2 id="Execute-script"><a class="docs-heading-anchor" href="#Execute-script">Execute script</a><a id="Execute-script-1"></a><a class="docs-heading-anchor-permalink" href="#Execute-script" title="Permalink"></a></h2><p>VMC simulations are typically run from the command line as jobs on a computing cluster. With this in mind, the following block of code only executes if the Julia script is run from the command line, also reading in additional command line arguments.</p><pre><code class="language-julia hljs"># Only execute if the script is run directly from the command line.
if abspath(PROGRAM_FILE) == @__FILE__

    # Read in the command line arguments.
    sID = parse(Int, ARGS[1])           # simulation ID
    L = parse(Int, ARGS[2])
    U = parse(Float64, ARGS[3])
    nup = parse(Int, ARGS[4])
    ndn = parse(Int, ARGS[5])
    N_equil = parse(Int, ARGS[6])
    N_opt = parse(Int, ARGS[7])
    N_opt_bins = parse(Int, ARGS[8])
    N_sim = parse(Int, ARGS[9])
    N_sim_bins = parse(Int, ARGS[10])

    # Run the simulation.
    run_hubbard_chain_simulation(sID, L, U, nup, ndn, N_equil, N_opt, N_opt_bins, N_sim, N_sim_bins)
end</code></pre><p>For instance, the command</p><pre><code class="nohighlight hljs">&gt; julia hubbard_chain.jl 1 4 2.0 2 2 200 3000 100 6000 100</code></pre><p>runs a VMC simulation of a <span>$N = 4$</span> half-filled 1D Hubbard model with interaction strength <span>$U = 2.0$</span>. In the VMC simulation, <span>$200$</span> sweeps through the lattice are be performed to thermalize the system, with <span>$3000$</span> optimization steps and <span>$6000$</span> simulation steps. During the simulation, bin-averaged measurements are written to file <span>$100$</span> times, with each bin of data containing the average of <span>$3,000/100 = 30$</span> sequential optimization measurements and <span>$6,000/100 = 60$</span> simulation measurements.</p><h1 id="2)-Hubbard-model-on-a-square-lattice-(with-Jastrow-factor)"><a class="docs-heading-anchor" href="#2)-Hubbard-model-on-a-square-lattice-(with-Jastrow-factor)">2) Hubbard model on a square lattice (with Jastrow factor)</a><a id="2)-Hubbard-model-on-a-square-lattice-(with-Jastrow-factor)-1"></a><a class="docs-heading-anchor-permalink" href="#2)-Hubbard-model-on-a-square-lattice-(with-Jastrow-factor)" title="Permalink"></a></h1><p>Download this example as a <a href="https://github.com/atanjaro/VariationalMC.jl/blob/14b1c221029e963f09efcc8fe7b6be34dce7e126/examples/hubbard_square.jl">Julia script</a>.</p><p>In this example, we will work through simulating a repulsive Hubbard model on a two dimensional (2D) square lattice. The Hubbard hamiltonian in 2D is given by</p><p class="math-container">\[\hat{H} = &amp; -t \sum_{\sigma,\langle i, j \rangle} (\hat{c}^{\dagger}_{i, \sigma}, \hat{c}^{\phantom \dagger}_{j, \sigma} + {\rm H.c.})
+ \sum_i \hat{n}_{i, \uparrow}\hat{n}_{i, \downarrow}
- \mu \sum_{i, \sigma}\hat{n}_{i,\sigma}\]</p><p>where <span>$\hat{c}^\dagger_{i, \sigma} \ (\hat{c}^{\phantom \dagger}_{i, \sigma})$</span> creates (annihilates) a spin <span>$\sigma$</span> electron on site <span>$i$</span> in the lattice, and <span>$\hat{n}_{i, \sigma} = \hat{c}^\dagger_{i, \sigma} \hat{c}^{\phantom \dagger}_{i, \sigma}$</span> is the spin-<span>$\sigma$</span> electron number operator for site <span>$i$</span>. The nearest-neighbor hopping amplitude is <span>$t$</span> and <span>$\mu$</span> is the chemical potential. The strength of the repulsive Hubbard interaction is controlled by <span>$U&gt;0$</span>. </p><h2 id="Import-packages-2"><a class="docs-heading-anchor" href="#Import-packages-2">Import packages</a><a class="docs-heading-anchor-permalink" href="#Import-packages-2" title="Permalink"></a></h2><p>We begin by importing the necessary packages, including the Standard Library packages <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">LinearAlgebra</a>, <a href="https://docs.julialang.org/en/v1/stdlib/Random/">Random</a>, and <a href="https://docs.julialang.org/en/v1/stdlib/Printf/">Printf</a> for perfroming linear algebra operations, random number generation, and C-style string formatting, respectively.</p><pre><code class="language-julia hljs">using Linear Algebra
using Random
using Printf</code></pre><p>Next, we use <a href="https://github.com/SmoQySuite/LatticeUtilities.jl">LatticeUtilities</a> which exports a suite of types and methods useful for defining arbitrary lattice geometries, and the construction of neighbor tables. Finally, we import the <a href="https://github.com/atanjaro/VariationalMC.jl">VariationalMC</a> package.</p><pre><code class="language-julia hljs">using LatticeUtilities
using VariationalMC</code></pre><h2 id="Specify-simulation-parameters-2"><a class="docs-heading-anchor" href="#Specify-simulation-parameters-2">Specify simulation parameters</a><a class="docs-heading-anchor-permalink" href="#Specify-simulation-parameters-2" title="Permalink"></a></h2><p>The main body of the simulation is wrapped in a top-level function named <code>run_hubbard_square_simulation</code>that will take as keyword arguments various model and simulation parameters that we may want to change. The specific meaning of each argument will be discussed in more detail in later sections of the tutorial.</p><pre><code class="language-julia hljs"># We define a top-level function for running the VMC simulation.
function run_hubbard_square_simulation(
    sID,            # Simulation ID.
    L,              # System size.
    U,              # Hubbard interaction.
    nup,            # Number of spin-up electrons.
    ndn,            # Number of spin-down electrons.
    N_equil,        # Number of equilibration/thermalization steps.
    N_opt,          # Number of optimization steps.
    N_opt_bins,     # Number of optimization bins.
    N_sim,          # Number of simulation steps.
    N_sim_bins;     # Number of simulation bins.
    filepath=&quot;.&quot;    # Filepath to where the datafolder will be created.
)</code></pre><h2 id="Initialize-simulation-2"><a class="docs-heading-anchor" href="#Initialize-simulation-2">Initialize simulation</a><a class="docs-heading-anchor-permalink" href="#Initialize-simulation-2" title="Permalink"></a></h2><p>In this initial part of the script, we will specify what parameters in the trial wavefunction will be optimized and name our simulation. The <code>NamedTuple</code> called <code>optimized</code> will contain all possible parameters that are automatically initialized in the wavefunction. Setting a flag to <code>true</code> will cause that parameter value (or values) to change during the optimization. We also specify whether the model is particle-hole transformed and is required to be <code>true</code> if pairing symmetery is being added to the wavefunction. </p><pre><code class="language-julia hljs">    # Select which parameters in the variational wavefunction will be optimized.
    optimize = (
        # local s-wave pairing
        Δ_0 = false,
        # site-dependent s-wave pairing  
        Δ_spd = false,
        # local d-wave pairing
        Δ_d = false,
        # site-dependent d-wave pairing 
        Δ_dpd = false,          
        # pairing momentum
        q_p = false,
        # spin-x (in-plane magnetization)
        Δ_sx = false,
        # spin-z (out-of-plane magnetization)
        Δ_sz = true,
        # site-dependent spin density
        Δ_ssd = false,
        # (BCS) chemical potential
        μ = false,
        # uniform charge density 
        Δ_cdw = false,
        # site-dependent charge density
        Δ_csd = false,
        # density-density Jastrow 
        density_J = true,
    )

    # Specify whether the model will be particle-hole transformed.
    pht = false</code></pre><p>The datafolder is created by initializing an instances of the <code>SimulationInfo</code> type, and then calling the <code>initialize_datafolder</code> function.</p><pre><code class="language-julia hljs">    # Construct the foldername the data will be written.
    df_prefix = @sprintf(&quot;hubbard_square_U%.2f_density%.2f_Lx%d_Ly%d_opt&quot;, U, density, L, L)

    # Append optimized parameter names to the foldername.
    datafolder_prefix = create_datafolder_prefix(optimize, df_prefix)

    # Initialize an instance of the SimulationInfo type.
    simulation_info = SimulationInfo(
        filepath = filepath, 
        datafolder_prefix = datafolder_prefix,
        sID = sID
    )

    # Initialize the directory the data will be written.
    initialize_datafolder(simulation_info)</code></pre><p>Next, we specify the parameters which control the VMC simulation. Specifically, we seed the random number generator, set the rate of optimization, and set thresholds for numerical stability. In practice, may <code>dt</code> and/or <code>dt_J</code> need to be changed depending upon the quality of the convergence.</p><pre><code class="language-julia hljs">    # Initialize a random number generator that will be used throughout the simulation.
    seed = abs(rand(Int))
    rng = Xoshiro(seed)

    # Set the optimization rate for the VMC simulation.
    dt = 0.03
    
    # (optional) Set the boost in the Jastrow optimization rate.
    dt_J = 1.0

    # Set the stabilization factor used in parameter optimization. 
    η = 1e-4    

    # Set the frequency in Monte Carlo steps with which the equal-time Green&#39;s function
    # matrix will be recomputed using the numerical stabilization procedure.
    n_stab_W = 50

    # Set the frequency in Monte Carlo steps with which the Jastrow T vector will be
    # recomputed using the numerical stabilization procedure.
    n_stab_T = 50

    # Specify the maximum allowed error in the equal-time Green&#39;s function matrix that
    # is corrected by numerical stabilization.
    δW = 1e-3

    # Specify the maximum allowed error in the Jastrow T vector that is corrected 
    # by numerical stabilization.
    δT = 1e-3</code></pre><p>In addition, we can calculate the length of each bin by dividing the number of iterations/steps by the number of bins. The bin size is the number of measurements that are averaged over each time data is written during either the optimization or simulation steps.</p><pre><code class="language-julia hljs">    # Calculate optimization bins size.
    opt_bin_size = div(N_opt, N_opt_bins) 

    # Calculate simulation bins size.
    sim_bin_size = div(N_sim, N_sim_bins)</code></pre><h2 id="Initialize-simulation-metadata-2"><a class="docs-heading-anchor" href="#Initialize-simulation-metadata-2">Initialize simulation metadata</a><a class="docs-heading-anchor-permalink" href="#Initialize-simulation-metadata-2" title="Permalink"></a></h2><p>In this section of the code we record important metadata about the simulation, including initializing the random number generator that will be used throughout the simulation. The important metadata within the simulation will be recorded in the <code>metadata</code> dictionary.</p><pre><code class="language-julia hljs">    # Record simulation metadata.
    metadata = Dict()
    metadata[&quot;seed&quot;] = seed
    metadata[&quot;pht&quot;] = pht
    metadata[&quot;N_equil&quot;] = N_equil
    metadata[&quot;N_opt&quot;] = N_opt
    metadata[&quot;N_sim&quot;] = N_sim
    metadata[&quot;N_opt_bins&quot;] = N_opt_bins
    metadata[&quot;N_sim_bins&quot;] = N_sim_bins
    metadata[&quot;δW&quot;] = δW
    metadata[&quot;δT&quot;] = δT
    metadata[&quot;n_stab_W&quot;] = n_stab_W
    metadata[&quot;n_stab_T&quot;] = n_stab_T
    metadata[&quot;dt&quot;] = dt 
    metadata[&quot;opt_flags&quot;] = optimize 
    metadata[&quot;acceptance_rate&quot;] = 0.0
    metadata[&quot;opt_time&quot;] = 0.0
    metadata[&quot;sim_time&quot;] = 0.0
    metadata[&quot;vmc_time&quot;] = 0.0</code></pre><p>In the above, <code>sID</code> stands for simulation ID, which is used to distinguish simulations that would otherwise be identical i.e. to distinguish simulations that use the same parameters and are only different in the random seed used to initialize the simulation. A valid <code>sID</code> is any positive integer greater than zero, and is used when naming the data folder the simulation results will be written to. Specifically, the actual data folder created above will be <code>&quot;$(filepath)/$(datafolder_prefix)-$(sID)&quot;</code>. Note that if you set <code>sID = 0</code>, then it will instead be assigned smallest previously unused integer value. For instance, suppose the directory <code>&quot;$(filepath)/$(datafolder_prefix)-1&quot;</code> already exits. Then if you pass <code>sID = 0</code> to <code>SimulationInfo</code>, then the simulation ID <code>sID = 2</code> will be used instead, and a directory <code>&quot;$(filepath)/$(datafolder_prefix)-2&quot;</code> will be created.</p><h2 id="Initialize-model-2"><a class="docs-heading-anchor" href="#Initialize-model-2">Initialize model</a><a class="docs-heading-anchor-permalink" href="#Initialize-model-2" title="Permalink"></a></h2><p>The next part of the script defines the model that we will simulate. First we define the lattice geometry for our model, relying on the <a href="https://github.com/SmoQySuite/LatticeUtilities.jl.git">LatticeUtilities</a> package to do so. We define a the unit cell and size of our finite lattice using the <a href="https://smoqysuite.github.io/LatticeUtilities.jl/stable/api/#LatticeUtilities.UnitCell"><code>UnitCell</code></a> and <a href="https://smoqysuite.github.io/LatticeUtilities.jl/stable/api/#LatticeUtilities.Lattice"><code>Lattice</code></a> types, respectively. Lastly, we define various instances of the <a href="https://smoqysuite.github.io/LatticeUtilities.jl/stable/api/#LatticeUtilities.Bond"><code>Bond</code></a> type to represent the the nearest-neighbor and next-nearest-neighbor bonds. All of this information regarding the lattice geometry is then stored in an instance of the <code>ModelGeometry</code> type.</p><pre><code class="language-julia hljs">    # Initialize an instance of the UnitCell type.
    unit_cell = UnitCell(
        lattice_vecs = [[1.0, 0.0], [0.0, 1.0]],
        basis_vecs   = [[0.0, 0.0]]
    )

    # Initialize an instance of the Lattice type.
    lattice = Lattice(
        [L, L], 
        [true, true]
    )

    # Define the nearest neighbor x-bond for a square lattice.
    bond_x = Bond(
        orbitals = (1,1), 
        displacement = [1,0]
    )

    # Define the nearest neighbor y-bond for a square lattice.
    bond_y = Bond(
        orbitals = (1,1), 
        displacement = [0,1]
    )

    # Define the next-nearest neighbor bonds for a square lattice.
    bond_xy = Bond(
        orbitals = (1,1), 
        displacement = [1,1]
    )

    # Define the next-nearest neighbor bonds for a square lattice.
    bond_yx = Bond(
        orbitals = (1,1), 
        displacement = [1,-1]
    )

    # Collect all bond definitions into a single vector.
    # Note that this has the structure [[nearest],[next-nearest]].
    bonds = [[bond_x, bond_y], [bond_xy, bond_yx]]

    # Initialize an instance of the ModelGeometry type.
    model_geometry = ModelGeometry(
        unit_cell, 
        lattice, 
        bonds
    )</code></pre><h2 id="Initialize-model-parameters-2"><a class="docs-heading-anchor" href="#Initialize-model-parameters-2">Initialize model parameters</a><a class="docs-heading-anchor-permalink" href="#Initialize-model-parameters-2" title="Permalink"></a></h2><p>The next step is to initialize our model parameters, which includes calculating the particle density in the canonical ensemble. The <code>get_particle_density</code> method includes mutliple ways of specifying the particle information. Here, we have chosen to pass the total particle density. The function then computes the corresponding total density, particle number, and electron number.</p><pre><code class="language-julia hljs">    # Determine the total particle density in the canonical ensemble. 
    (density, Np, Ne, nup, ndn) = get_particle_density(density, model_geometry, pht) </code></pre><p>We then specify parameters for our tight binding model and initializes all of the parameters that are in the determinantal part of the trial wavefunction. Parameters for the density-desnity Jastrow factor are initialized seperately. We can also set an initial particle configuration, if we have one. If an empty array is provided instead, a random configuration will be given at the start of the simulation. </p><pre><code class="language-julia hljs">    # Define the nearest neighbor hopping amplitude, setting the energy scale of the system. 
    t = 1.0

    # Define the next-nearest neighbor hopping amplitude.
    tp = 0.0

    # Define the third-nearest neighbor hopping amplitude.
    tpd = 0.0

    # Define the non-interacting tight binding model.
    tight_binding_model = TightBindingModel(t, tp, tpd)

    # Initialize determinantal variational parameters.
    determinantal_parameters = DeterminantalParameters(
        optimize, 
        tight_binding_model, 
        model_geometry, 
        Ne, 
        pht
    )

    # Initialize density-density Jastrow variational parameters.
    density_J_parameters = JastrowParameters(
        &quot;e-den-den&quot;,
        optimize, 
        model_geometry,
        rng
    )

    # Initialize the (fermionic) particle configuration.
    pconfig = Int[]</code></pre><h2 id="Initialize-measurements-2"><a class="docs-heading-anchor" href="#Initialize-measurements-2">Initialize measurements</a><a class="docs-heading-anchor-permalink" href="#Initialize-measurements-2" title="Permalink"></a></h2><p>Finally, we initialize the mesaurement container, which accumulates the sums of measurements made in a bin. The standard measurements are of the local energy <code>local_energy</code>, double occupancy <code>double_occ</code>, particle confiugurations <code>pconfig</code>, and variational parameters <code>parameters</code>. There is also the option to add additional observables to measure through the <code>initialize_simulation_measurement!</code>and <code>initialize_correlation_measurement!</code> methods. Here, we have added density-density correlation measurements.</p><pre><code class="language-julia hljs">    # Initialize the container that measurements will be accumulated into.
    measurement_container = initialize_measurement_container(
        N_opt, 
        opt_bin_size, 
        N_sim, 
        sim_bin_size,
        determinantal_parameters,
        model_geometry
    )

    # Add density-density correlation measurements.
    initialize_correlation_measurement!(
        &quot;density&quot;, 
        measurement_container, 
        model_geometry
    )</code></pre><p>The <code>initialize_measurement_directories</code> can now be used used to initialize the various subdirectories in the data folder that the measurements will be written to. For more information, please refer to the Simulation Output Overview page.</p><pre><code class="language-julia hljs">    # Initialize the sub-directories to which the various measurements will be written.
    initialize_measurement_directories(
        simulation_info, 
        measurement_container
    )</code></pre><h2 id="Optimize-the-variational-parameters-2"><a class="docs-heading-anchor" href="#Optimize-the-variational-parameters-2">Optimize the variational parameters</a><a class="docs-heading-anchor-permalink" href="#Optimize-the-variational-parameters-2" title="Permalink"></a></h2><p>Now that we have set-up the VMC simulation, we can begin optimizing the variational parameters. At the start of each bin, we initialize the variational wavefunction which includes the determinantal part and the density-density Jastrow factor. On the first iteration, if no initial configuration is specified, a random one will be generated.</p><pre><code class="language-julia hljs">        # Initialize the determinantal wavefunction.
        detwf = get_determinantal_wavefunction(
            tight_binding_model, 
            determinantal_parameters, 
            optimize, 
            Np, 
            nup, 
            ndn, 
            model_geometry, 
            rng,
            pht,
            pconfig
        )  

        # Initialize density-density Jastrow factor.
        density_J_factor = get_jastrow_factor(
            density_J_parameters,
            detwf,
            model_geometry,
            pht
        )</code></pre><p>This next section of the code equilibrates/thermalizes the system before making measurements. Within the equilibration loop, the structure is fairly simple: the <code>local_fermion_update!</code> function is called to sweep over the particle configuration, attempting to update particle positions. Here, the number of updates performed before measurement is <code>N_equil</code> and <code>opt_bin_size</code> refers to the length of each bin from <code>N_opt_bins</code>.</p><p>The quantities <code>n_stab_W</code> and <code>δW</code> are passed to the <code>local_fermion_update!</code> function and controls the stability of the equal-time Green&#39;s function matrix <code>W</code>. After <code>n_stab_W</code> fermionic updates, there is a deviation check performed and if it exceeds the threshold <code>δW</code>, then the Green&#39;s function is recomputed from scratch.</p><p>Finally, the number of measurements that are averaged over per bin is given by <code>opt_bin_size = N_opt ÷ N_opt_bins</code>. The bin-averaged measurements are written to file once <code>bin_size</code> measurements are accumulated using the <code>write_measurements!</code> function.</p><pre><code class="language-julia hljs">        # Iterate over optimization bin length
        for n in 1:opt_bin_size

            # Iterate over equilibration/thermalization updates
            for equil in 1:N_equil
                (acceptance_rate, detwf, density_J_factor) = local_fermion_update!(
                    detwf, 
                    density_J_factor,
                    density_J_parameters,
                    Np, 
                    model_geometry, 
                    pht,
                    n_stab_W,
                    n_stab_T,
                    δW, 
                    δT,
                    rng
                )

                # Record acceptance rate.
                metadata[&quot;acceptance_rate&quot;] += acceptance_rate
            end

            # Make measurements, with results being recorded in the measurement container.
            make_measurements!(
                measurement_container, 
                detwf, 
                tight_binding_model, 
                determinantal_parameters, 
                density_J_parameters,
                density_J_factor,
                optimize,
                model_geometry, 
                U,
                Np, 
                pht
            )
        end</code></pre><p>After the last measurement is made, the last particle configuration is recorded globally for use in the initialization of the determinantal wavefunction for the next bin. </p><pre><code class="language-julia hljs">        # Record the last particle configuration used for the start of the next bin.
        pconfig = detwf.pconfig</code></pre><p>The primary part of this step of the simulation is the optimization of the variational parameters. Since all measurements for this bin have already been accumulated in the <code>measurement_container</code>, the <code>optimize_parameters!</code> function need only apply the Stochastic Reconfiguration (SR) procedure. Once an SR iteration is complete, all measurements are written to file. The <code>write_measurements!</code> method has an optional argument to write the parameter values to file, which we want for the optimization step.</p><pre><code class="language-julia hljs">        # Attempt to update the variational parameters using the Stochastic Reconfiguration procedure. 
        optimize_parameters!( 
            measurement_container,  
            determinantal_parameters, 
            density_J_parameters,
            η, 
            dt, 
            dt_J,
            opt_bin_size
        )  

        # Write measurement for the current bin to file.
        write_measurements!(
            &quot;opt&quot;,
            bin, 
            opt_bin_size,
            measurement_container, 
            simulation_info,
            write_parameters=true
        )</code></pre><h2 id="Simulate-the-system-with-optimized-parameters-2"><a class="docs-heading-anchor" href="#Simulate-the-system-with-optimized-parameters-2">Simulate the system with optimized parameters</a><a class="docs-heading-anchor-permalink" href="#Simulate-the-system-with-optimized-parameters-2" title="Permalink"></a></h2><p>In this next section, we continue to sample particle configurations using <code>local_fermion_update!</code> function but without the SR optimization. This is mainly done to ensure proper statistics in calculating observables like the local energy. </p><pre><code class="language-julia hljs">    # Iterate over simulation bins.
    for bin in 1:N_sim_bins

        # Initialize the determinantal wavefunction.
        detwf = get_determinantal_wavefunction(
            tight_binding_model, 
            determinantal_parameters, 
            optimize, 
            Np, 
            nup, 
            ndn, 
            model_geometry, 
            rng,
            pht,
            pconfig
        )  

        # Initialize density-density Jastrow factor.
        density_J_factor = get_jastrow_factor(
            density_J_parameters,
            detwf,
            model_geometry,
            pht
        )

        # Iterate over optimization bin length
        for n in 1:sim_bin_size

            # Iterate over equilibration/thermalization updates
            for equil in 1:N_equil
                (acceptance_rate, detwf, density_J_factor) = local_fermion_update!(
                    detwf, 
                    density_J_factor,
                    density_J_parameters,
                    Np, 
                    model_geometry, 
                    pht,
                    n_stab_W,
                    n_stab_T,
                    δW, 
                    δT,
                    rng
                )

                # Record acceptance rate.
                metadata[&quot;acceptance_rate&quot;] += acceptance_rate
            end

            # Make measurements, with results being recorded in the measurement container.
            make_measurements!(
                measurement_container, 
                detwf, 
                tight_binding_model, 
                density_J_parameters,
                density_J_factor,
                model_geometry, 
                U,
                Np, 
                pht
            )
        end

        # Record the last particle configuration used for the start of the next bin.
        pconfig = detwf.pconfig

        # Write measurement for the current bin to file.
        write_measurements!(
            &quot;sim&quot;,
            bin, 
            sim_bin_size,
            measurement_container, 
            simulation_info
        )
    end</code></pre><h2 id="Record-simulation-metadata-2"><a class="docs-heading-anchor" href="#Record-simulation-metadata-2">Record simulation metadata</a><a class="docs-heading-anchor-permalink" href="#Record-simulation-metadata-2" title="Permalink"></a></h2><p>Now that the optimization and simulation of the system are complete, we calculate the total time of the VMC simulation and the average final acceptance rate. Such information is saved to file using the <code>model_summary</code> function. </p><pre><code class="language-julia hljs">    # Record the total VMC time.
    metadata[&quot;vmc_time&quot;] += metadata[&quot;opt_time&quot;] + metadata[&quot;sim_time&quot;]

    # Normalize acceptance rate.
    metadata[&quot;acceptance_rate&quot;] /=  (N_opt + N_sim)

    # Write model summary to file.
    model_summary(simulation_info, metadata)</code></pre><h2 id="Post-processing-2"><a class="docs-heading-anchor" href="#Post-processing-2">Post-processing</a><a class="docs-heading-anchor-permalink" href="#Post-processing-2" title="Permalink"></a></h2><p>During the simulation, all measurments are written to file in HDF5 format for speed and portability; however, for analyzing data, having CSV files are mush more convenient. Calling the <code>process_measurements</code> function accomoplishes this. It will then up to the user to determine final processing and statistics. It should be noted that the next version of the code will have a convergence detection module and plotting function. </p><pre><code class="language-julia hljs">    # Process all optimization and simulation measurements.
    process_measurements(
        measurement_container, 
        simulation_info, 
        determinantal_parameters, 
        density_J_parameters,
        model_geometry
    )</code></pre><h2 id="Execute-script-2"><a class="docs-heading-anchor" href="#Execute-script-2">Execute script</a><a class="docs-heading-anchor-permalink" href="#Execute-script-2" title="Permalink"></a></h2><p>VMC simulations are typically run from the command line as jobs on a computing cluster. With this in mind, the following block of code only executes if the Julia script is run from the command line, also reading in additional command line arguments.</p><pre><code class="language-julia hljs"># Only execute if the script is run directly from the command line.
if abspath(PROGRAM_FILE) == @__FILE__

    # Read in the command line arguments.
    sID = parse(Int, ARGS[1])           # simulation ID
    L = parse(Int, ARGS[2])
    U = parse(Float64, ARGS[3])
    density = parse(Int, ARGS[4])
    N_equil = parse(Int, ARGS[5])
    N_opt = parse(Int, ARGS[6])
    N_opt_bins = parse(Int, ARGS[7])
    N_sim = parse(Int, ARGS[8])
    N_sim_bins = parse(Int, ARGS[9])

    # Run the simulation.
    run_hubbard_square_simulation(sID, L, U, density, N_equil, N_opt, N_opt_bins, N_sim, N_sim_bins)
end</code></pre><p>For instance, the command</p><pre><code class="nohighlight hljs">&gt; julia hubbard_square.jl 1 4 2.0 0.5 1000 3000 100 6000 100</code></pre><p>runs a VMC simulation of a <span>$N = 4 \times 4$</span> quarter-filled 2D Hubbard model with interaction strength <span>$U = 2.0$</span>. In the VMC simulation, <span>$1000$</span> sweeps through the lattice are be performed to thermalize the system, with <span>$3000$</span> optimization steps and <span>$6000$</span> simulation steps. During the simulation, bin-averaged measurements are written to file <span>$100$</span> times, with each bin of data containing the average of <span>$3,000/100 = 30$</span> sequential optimization measurements and <span>$6,000/100 = 60$</span> simulation measurements.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../simulation_output/">Simulation Output Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Friday 19 December 2025 14:43">Friday 19 December 2025</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
