var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#ModelGeometry-Type-and-Methods","page":"API","title":"ModelGeometry Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ModelGeometry","category":"page"},{"location":"api/#VariationalMC.ModelGeometry","page":"API","title":"VariationalMC.ModelGeometry","text":"ModelGeometry{T, B<:AbstractVector{<:AbstractVector{T}}}\n\nA type defining the geometry of a lattice model, including the unit cell, lattice, and bond definitions.\n\nunit_cell::UnitCell: contains unit cell definitions.\nlattice::Lattice: contains lattice definitions including boundary conditions.\nbond::B: vector of all bond definitions.\n\n\n\n\n\n","category":"type"},{"location":"api/#Internal-Methods","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.apply_twist_angle!\nVariationalMC.x\nVariationalMC.y\nVariationalMC.d\nVariationalMC.reduce_index_2d\nVariationalMC.reduce_index_1d \nVariationalMC.max_dist","category":"page"},{"location":"api/#VariationalMC.apply_twist_angle!","page":"API","title":"VariationalMC.apply_twist_angle!","text":"apply_twist_angle!( H_t::Matrix{T},\n                    θ_twist::E,\n                    model_geometry::ModelGeometry ) where {T<:Number, E<:AbstractFloat}\n\nApplies a twist angle to the hopping matrix by multiplying by an appropriate phase factor.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.x","page":"API","title":"VariationalMC.x","text":"x( i::I, \n   model_geometry::ModelGeometry ) where {I<:Integer}\n\nConvenience function for obtaining the x-coordinate of a lattice site given a  lattice spindex.\n\ni::I: spindex.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.y","page":"API","title":"VariationalMC.y","text":"y( i::I, \n   model_geometry::ModelGeometry ) where {I<:Integer}\n\nConvenience function for obtaining the y-coordinate of a lattice site given a  lattice spindex.\n\ni::I: spindex.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.d","page":"API","title":"VariationalMC.d","text":"d( p1::I, \n   p2::I, \n   model_geometry::ModelGeometry ) where {I<:Integer}\n\nGiven lattice points p_1 and p_2, returns the distance between those two points,  accounting for the lattice edges under different boundary conditions.\n\np1::I: first lattice point.\np2::I: second lattice point.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.reduce_index_2d","page":"API","title":"VariationalMC.reduce_index_2d","text":"reduce_index_2d( i::I, \n                 j::I, \n                 model_geometry::ModelGeometry ) where {I<:Integer}\n\nFor two lattice sites i and j on a 2D lattice, returns the irreducible index k between them, where k is an integer.\n\ni::I: first lattice site.\nj::I: second lattice site.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.reduce_index_1d","page":"API","title":"VariationalMC.reduce_index_1d","text":"reduce_index_1d( i::I, \n                 j::I, \n                 model_geometry::ModelGeometry ) where {I<:Integer}\n\nFor two lattice sites i and j on a 1D lattice, returns the irreducible index k between them, where k is an integer.\n\ni::I: first lattice site.\nj::I: second lattice site.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.max_dist","page":"API","title":"VariationalMC.max_dist","text":"max_dist( N::I, \n          L::I ) where {I<:Integer}\n\nFor a lattice with N sites and extent L, returns the maximum irreducible index k_mathrmmax.\n\nN::I: total number of lattice sites.\nL::I: extent of the lattice.\n\n\n\n\n\n","category":"function"},{"location":"api/#Parameters-Types-and-Methods","page":"API","title":"Parameters Types and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TightBindingModel\nSpinModel\nDeterminantalParameters\nJastrowParameters","category":"page"},{"location":"api/#VariationalMC.TightBindingModel","page":"API","title":"VariationalMC.TightBindingModel","text":"TightBindingModel{E<:AbstractFloat}\n\nA type defining a non-interacting tight binding model with nearest, next  nearest, and third nearest hopping parameters.\n\nt₀::E: zeroth hopping parameter (nearest neighbor)\nt₁::E: first hopping parameter (next nearest neighbor)\nt₂::E: second hopping parameter (third nearest neighbor)\n\n\n\n\n\n","category":"type"},{"location":"api/#VariationalMC.SpinModel","page":"API","title":"VariationalMC.SpinModel","text":"SpinModel{E<:AbstractFloat}\n\nA type defining a non-interacting spin model with nearest, next nearest, and  third nearest neighbor exchange coupling parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#VariationalMC.DeterminantalParameters","page":"API","title":"VariationalMC.DeterminantalParameters","text":"DeterminantalParameters{I<:Integer}\n\nA type defining a set of variational parameters obtained from the auxiliary Hamiltonian,  otherwise known as the \"determinantal\" part of the variational wavefunction.\n\ndet_pars::NamedTuple: contains parameter names and their values.\nnum_det_pars::I: total number of determinantal parameters.\nnum_det_opts::I: number of determinantal parameters being optimized.\n\n\n\n\n\n","category":"type"},{"location":"api/#VariationalMC.JastrowParameters","page":"API","title":"VariationalMC.JastrowParameters","text":"JastrowParameters{S<:AbstractString, K, V, I<:Integer}\n\nA type defining quantities related to Jastrow variational parameters.\n\njastrow_type::S: type of Jastrow parameters: \"e-den-den\", \"e-spn-spn\"\njpar_map::OrderedDict{K, V}: dictionary of irreducible indices to their correct index pairs and Jastrow parameter.\nnum_jpars::I: total number of Jastrow parameters.\nnum_jpar_opts::I: total number of Jastrow parameters being optimized.\n\n\n\n\n\n","category":"type"},{"location":"api/#Internal-Methods-2","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.collect_parameters\nVariationalMC.update_parameters!\nVariationalMC.readin_parameters","category":"page"},{"location":"api/#VariationalMC.collect_parameters","page":"API","title":"VariationalMC.collect_parameters","text":"collect_parameters( determinantal_parameters::DeterminantalParameters{I}, \n                    jastrow_parameters::JastrowParameters{S, K, V, I} ) where {S<:AbstractString, K, V, I<:Integer}\n\nConcatenates all values of determinantal and Jastrow parameters into a single vector of variational parameters.\n\ndeterminantal_parameters::DeterminantalParameters{I}: current set of determinantal parameters.\njastrow_parameters::JastrowParameters{S, K, V, I}: current set of Jastrow parameters.\n\n\n\n\n\ncollect_parameters( determinantal_parameters::DeterminantalParameters{I}, \n                    jastrow_parameters_1::JastrowParameters{S, K, V, I},\n                    jastrow_parameters_2::JastrowParameters{S, K, V, I} ) where {S<:AbstractString, K, V, I<:Integer}\n\nConcatenates all values of determinantal and Jastrow parameters into a single vector of  variational parameters.\n\ndeterminantal_parameters::DeterminantalParameters{I}: current set of determinantal parameters.\njastrow_parameters_1::JastrowParameters{S, I, V}: first set of Jastrow parameters.\njastrow_parameters_2::JastrowParameters{S, I, V}: second set of Jastrow parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.update_parameters!","page":"API","title":"VariationalMC.update_parameters!","text":"update_parameters!( measurement_container::NamedTuple,\n                    new_vpars::AbstractVector, \n                    determinantal_parameters::DeterminantalParameters{I} ) where {I<:Integer}\n\nUpdates variational parameters after Stochastic Reconfiguration.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\nnew_vpars::AbstractVector: updated variational parameters.\ndeterminantal_parameters::DeterminantalParameters{I}: current set of determinantal variational parameters.\n\n\n\n\n\nupdate_parameters!( measurement_container::NamedTuple,\n                    new_vpars::AbstractVector, \n                    determinantal_parameters::DeterminantalParameters{I}, \n                    jastrow_parameters::JastrowParameters{S, K, V, I} ) where {S<:AbstractString, K, V, I<:Integer}\n\nUpdates variational parameters after Stochastic Reconfiguration.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\nnew_vpars::AbstractVector: updated variational parameters.\ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\njastrow_parameters::JastrowParameters{S, K, V, I}: set of Jastrow variational parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.readin_parameters","page":"API","title":"VariationalMC.readin_parameters","text":"readin_parameters( filename::S ) where {S<:AbstractString}\n\nParses TOML file containing initial variational parameters. \n\nfilename::S: name of parameter summary file in TOML format.\n\n\n\n\n\n","category":"function"},{"location":"api/#Hamiltonian-Methods","page":"API","title":"Hamiltonian Methods","text":"","category":"section"},{"location":"api/#Internal-Methods-3","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.build_auxiliary_hamiltonian\nVariationalMC.build_tight_binding_hamiltonian\nVariationalMC.build_variational_hamiltonian\nVariationalMC.add_pairing_symmetry!\nVariationalMC.add_spin_order!\nVariationalMC.add_charge_order!\nVariationalMC.add_chemical_potential!\nVariationalMC.diagonalize!\nVariationalMC.is_openshell\nVariationalMC.get_variational_matrices\nVariationalMC.get_tb_chem_pot","category":"page"},{"location":"api/#VariationalMC.build_auxiliary_hamiltonian","page":"API","title":"VariationalMC.build_auxiliary_hamiltonian","text":"build_auxiliary_hamiltonian( tight_binding_model::TightBindingModel{E}, \n                             determinantal_parameters::DeterminantalParameters{I}, \n                             optimize::NamedTuple, \n                             model_geometry::ModelGeometry, \n                             pht::Bool ) where {E<:AbstractFloat, I<:Integer}\n\nConstructs an auxiliary Hamiltonian matrix H_mathrmaux by combining the non-interacting hopping matrix H_t with matrices of variational terms H_mathrmvar.\n\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model.\ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hol transformed.\n\n\n\n\n\nbuild_auxiliary_hamiltonian( tight_binding_model::TightBindingModel{E}, \n                             determinantal_parameters::DeterminantalParameters{I}, \n                             optimize::NamedTuple, \n                             model_geometry::ModelGeometry, \n                             twist_angles::AbstractRange{E},\n                             pht::Bool ) where {E<:AbstractFloat, I<:Integer}\n\nConstructs an auxiliary Hamiltonian matrix H_mathrmaux^theta for N_theta twist angles by combining the non-interacting hopping matrix H_t with matrices of variational terms H_mathrmvar.\n\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model.\ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\ntwist_angles::AbstractRange{E}: set of twist angles.\npht::Bool: whether model is particle-hol transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.build_tight_binding_hamiltonian","page":"API","title":"VariationalMC.build_tight_binding_hamiltonian","text":"build_tight_binding_hamiltonian( tight_binding_model::TightBindingModel{E},\n                                 model_geometry::ModelGeometry,\n                                 pht::Bool ) where {E<:AbstractFloat}\n\nConstructs a 2N by 2N tight-binding hopping matrix where N is the number of lattice sites,  given hopping parameters t, t^prime, and t^primeprime.\n\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed. \n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.build_variational_hamiltonian","page":"API","title":"VariationalMC.build_variational_hamiltonian","text":"build_variational_hamiltonian( determinantal_parameters::DeterminantalParameters{I}, \n                               model_geometry::ModelGeometry,\n                               optimize::NamedTuple, \n                               pht::Bool ) where {I<:Integer}\n\nConstructs a set of 2N by 2N matrices for each variational parameter, where N is the number of  lattice sites. Returns a total variational Hamiltonian matrix H_mathrmvar as well has a vector  of operators V.\n\ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\noptimize::NamedTuple: field of optimization flags.\npht::Bool: whether model is particle-hole transformed. \n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.add_pairing_symmetry!","page":"API","title":"VariationalMC.add_pairing_symmetry!","text":"add_pairing_symmetry!( symmetry::S, \n                       determinantal_parameters::DeterminantalParameters{I}, \n                       optimize::NamedTuple, \n                       H_vpars::Vector{Matrix{T}}, \n                       V::Vector{Matrix{T}}, \n                       model_geometry::ModelGeometry,\n                       bonds,\n                       dims::I,\n                       N::I, \n                       pht::Bool ) where {S<:AbstractString, I<:Integer, T<:Number}\n\nAdds a pairing term to the auxiliary Hamiltonian. \n\nsymmetry::S: type of pairing symmetry: \"s\", \"d\", \"sPDW\", or \"dPDW\".\ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\nH_vpars::Vector{Matrix{T}}: vector of variational Hamiltonian matrices.\nV::Vector{Matrix{T}}: vector of variational operators.\nmodel_geometry::ModelGeometry: contains lattice and unit cell quantities.\ndims::I: dimensions of the lattice. \nbonds: lattice bonds.\nN::I: number of sites in the lattice. \npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.add_spin_order!","page":"API","title":"VariationalMC.add_spin_order!","text":"add_spin_order!( order::S, \n                 determinantal_parameters::DeterminantalParameters{I}, \n                 optimize::NamedTuple, \n                 H_vpars::Vector{Matrix{T}}, \n                 V::Vector{Matrix{T}}, \n                 model_geometry::ModelGeometry,\n                 dims::I,\n                 N::I, \n                 pht::Bool )::Nothing\n\nAdds a spin ordering term to the auxiliary Hamiltonian. \n\norder::String: type of spin order: \"spin-x\", \"spin-z\", or \"site-dependent\"\ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\nH_vpars::Vector{Any}: vector of variational Hamiltonian matrices.\nV::Vector{Any}: vector of variational operators.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\ndims::I: dimensions of the lattice. \nN::I: number of sites in the lattice. \npht::Bool: whether model if particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.add_charge_order!","page":"API","title":"VariationalMC.add_charge_order!","text":"add_charge_order!( order::S, \n                   determinantal_parameters::DeterminantalParameters{I}, \n                   optimize::NamedTuple, \n                   H_vpars::Vector{Matrix{T}}, \n                   V::Vector{Matrix{T}}, \n                   model_geometry::ModelGeometry,\n                   dims::I,\n                   N::I, \n                   pht::Bool ) where {S<:AbstractString, I<:Integer, T<:Number}\n\nAdds a charge ordering term to the auxiliary Hamiltonian.\n\norder::S: type of spin order: \"density wave\" or \"site-dependent\"\ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\nH_vpars::Vector{Matrix{T}}: vector of variational Hamiltonian matrices.\nV::Vector{Matrix{T}}: vector of variational operators.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\ndims::I: dimensions of the lattice. \nN::I: number of sites in the lattice. \npht::Bool: whether model if particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.add_chemical_potential!","page":"API","title":"VariationalMC.add_chemical_potential!","text":"add_chemical_potential!( determinantal_parameters::DeterminantalParameters{I}, \n                         optimize::NamedTuple, \n                         H_vpars::Vector{Matrix{T}}, \n                         V::Vector{Matrix{T}}, \n                         N::I, \n                         pht::Bool )::Nothing\n\nAdds a chemical potential term to the auxiliary Hamiltonian.\n\ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\nH_vpars::Vector{Matrix{T}}: vector of variational Hamiltonian matrices.\nV::Vector{Matrix{T}}: vector of variational operators.\nN::I: number of sites in the lattice. \npht::Bool: whether model if particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.diagonalize!","page":"API","title":"VariationalMC.diagonalize!","text":"diagonalize!( H::Matrix{T} ) where {T<:Number}\n\nReturns all eigenenergies varepsilon and all eigenstates phi of the  auxiliary Hamiltonian matrix. All eigenstates are stored in the columns of a  unitary matrix U_aux. \n\nH::Matrix{T}: auxiliary Hamiltonian matrix.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.is_openshell","page":"API","title":"VariationalMC.is_openshell","text":"is_openshell( ε::Vector{E},  \n              Np::I,\n              pht::Bool ) where {E<:AbstractFloat, I<:Integer}\n\nChecks whether a mean-field energy configuration is open shell.\n\nε::Vector{E}: vector of mean-field energies.\nNp::I: total number of particles in the system.\npht::Bool: whether the model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_variational_matrices","page":"API","title":"VariationalMC.get_variational_matrices","text":"get_variational_matrices( V::Vector{Matrix{T1}}, \n                          U_aux::Matrix{T2}, \n                          ε::Vector{E}, \n                          Np::I\n                          model_geometry::ModelGeometry ) where {T1<:Number, T2<:Number, E<:AbstractFloat, I<:Integer}\n\nReturns a set of variational parameter matrices A_k constructed from each variational operator V_k by computing \n\nQ_k = frac(U^daggerV_kU)_etanu(varepsilon_eta - varepsilon_nu)\n\nwhere eta  N_p and nu leq N_p.\n\nV::Vector{Matrix{T1}: vector of variational operators. \nU_aux::Matrix{T2}: matrix which diagonalizes the auxiliary Hamiltonian.\nε::Vector{E}: initial energies.\nNp::I: number of particles in the system. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_tb_chem_pot","page":"API","title":"VariationalMC.get_tb_chem_pot","text":"get_tb_chem_pot( Ne::I, \n                 tight_binding_model::TightBindingModel{E}, \n                 model_geometry::ModelGeometry ) where {I<:Integer, E<:AbstractFloat}\n\nComputes the appropriate chemical potential mu for a non-interacting tight-binding model on a finite lattice.\n\nNe::I: total number of electrons.\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#DeterminantalWavefunction-Type-and-Methods","page":"API","title":"DeterminantalWavefunction Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DeterminantalWavefunction\nDeterminantalWavefunctionTABC\nget_determinantal_wavefunction","category":"page"},{"location":"api/#VariationalMC.DeterminantalWavefunction","page":"API","title":"VariationalMC.DeterminantalWavefunction","text":"DeterminantalWavefunction{T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nA type defining quantities related to a determinantal wavefunction.\n\nW::Matrix{T}: equal-time Green's function matrix.\nD::Matrix{T}: Slater matrix.\nM::AbstractMatrix{T}: reduced U_aux matrix.\nU_aux::Matrix{T}: unitary matrix that diagonalizes the auxiliary Hamiltonian.\nA::Vector{Q}: variational parameter matrices.\nε::Vector{E}: vector of mean-field energies.\npconfig::Vector{I}: particle configuration.\nnq_updates_W::I: tracker for the number for quick updates to the W matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/#VariationalMC.DeterminantalWavefunctionTABC","page":"API","title":"VariationalMC.DeterminantalWavefunctionTABC","text":"DeterminantalWavefunctionTABC{T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nA type defining quantities related to a determinantal wavefunction over a range  of twist angles.\n\nW_θ::Vector{Matrix{T}}: set of equal-time Green's function matrices.\nD_θ::Vector{Matrix{T}}: set of Slater matrices.\nM_θ::Vector{AbstractMatrix{T}}: set of reduced U_aux matrices.\nU_θ::Vector{Matrix{T}}: set of unitary matrices that diagonalizes the auxiliary Hamiltonian.\nA_θ::Vector{Vector{Q}}: set of variational parameter matrices.\nε_θ::Vector{Vector{E}}: vector of mean-field energies.\npconfig::Vector{I}: particle configuration.\nN_θ::I: number of twist angles to average over.\ntwist_angles::AbstractRange{E}: set of twist angles.\nnq_updates_W::I: tracker for the number for quick updates to the W matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/#VariationalMC.get_determinantal_wavefunction","page":"API","title":"VariationalMC.get_determinantal_wavefunction","text":"get_determinantal_wavefunction( tight_binding_model::TightBindingModel{E}, \n                                determinantal_parameters::DeterminantalParameters{I}, \n                                optimize::NamedTuple, \n                                Np::I, \n                                nup::I, \n                                ndn::I, \n                                model_geometry::ModelGeometry, \n                                rng::AbstractRNG, \n                                pht::Bool,\n                                pconfig::Vector{I} = Int[] ) where {E<:AbstractFloat, I<:Integer}\n\nConstructs a variational wavefunction Phi_0rangle based on parameters given by the tight-binding model  and determinantal parameter and returns an instance of the DeterminantalWavefunction type. If no initial  particle configuration is specified, a random configuration will be generated.                            \n\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model. \ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\nNp::I: total number of particles in the system.\nnup::I: number of spin-up electrons.\nndn::I: number of spin-down electrons.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nrng::AbstractRNG: random number generator. \npht::Bool: whether model is particle-hole transformed.\npconfig::Vector{I} = Int[]: optional initial particle configuration.\n\n\n\n\n\nget_determinantal_wavefunction( tight_binding_model::TightBindingModel{E}, \n                                determinantal_parameters::DeterminantalParameters{I}, \n                                optimize::NamedTuple, \n                                Np::I, \n                                nup::I, \n                                ndn::I, \n                                model_geometry::ModelGeometry, \n                                N_θ::I,\n                                twist_angles::AbstractRange{E},\n                                rng::AbstractRNG, \n                                pht::Bool,\n                                pconfig::Vector{I} = Int[] ) where {E<:AbstractFloat, I<:Integer}\n\nConstructs a variational wavefunction Phi_0^thetarangle for N_\\theta twist angles based on parameters  given by the tight-binding model and determinantal parameter and returns an instance of the DeterminantalWavefunctionTABC  type. If no initial particle configuration is specified, a random configuration will be generated.                            \n\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model. \ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\nNp::I: total number of particles in the system.\nnup::I: number of spin-up electrons.\nndn::I: number of spin-down electrons.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nN_θ::I: number of twist angles.\ntwist_angles::AbstractRange{E}: list of twist angles.\nrng::AbstractRNG: random number. \npht::Bool: whether model is particle-hole transformed.\npconfig::Vector{I} = Int[]: optional initial particle configuration.\n\n\n\n\n\n","category":"function"},{"location":"api/#Jastrow-Types-and-Methods","page":"API","title":"Jastrow Types and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JastrowFactor\nget_jastrow_factor","category":"page"},{"location":"api/#VariationalMC.JastrowFactor","page":"API","title":"VariationalMC.JastrowFactor","text":"JastrowFactor{E<:AbstractFloat, I<:Integer}\n\nA type defining quantities related to a Jastrow factor.  \n\nTvec_f::Vector{E}: fermionic T vector.\nTvec_b::Vector{E}: bosonic or phononic T vector. \nnq_updates_T::I: tracker for the number of quick updates to the T vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#VariationalMC.get_jastrow_factor","page":"API","title":"VariationalMC.get_jastrow_factor","text":"get_jastrow_factor( jastrow_parameters::JastrowParameters{S, K, V, I}, \n                    detwf::DeterminantalWavefunction{T, Q, E, I}, \n                    model_geometry::ModelGeometry, \n                    pht::Bool )::JastrowFactor\n\nGiven a set of Jastrow parameters, constructs the relevant Jastrow factor mathcalJ_n and  returns a instance of the JastrowFactor type. \n\njastrow_parameters::JastrowParameters{S, K, V, I}: current set of Jastrow parameters. \ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed. \n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Methods-4","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.get_fermionic_Tvec\nVariationalMC.update_fermionic_Tvec!\nVariationalMC.get_fermionic_jastrow_ratio\nVariationalMC.map_jastrow_parameters","category":"page"},{"location":"api/#VariationalMC.get_fermionic_Tvec","page":"API","title":"VariationalMC.get_fermionic_Tvec","text":"get_fermionic_Tvec( jastrow_type::S,  \n                    jpar_map::OrderedDict{Any, Any},\n                    detwf::DeterminantalWavefunction{T, Q, E, I}, \n                    N::I,\n                    pht::Bool )\n\nReturns a fermionic T vector with elements T_i = sum_j v_ij n_i where v_ij are the    Jastrow peseudopotentials and n_i are the total fermion occupations.\n\njastrow_type::S: either \"e-den-den\" or \"e-spn-spn.\njpar_map::OrderedDict{Any, Any}: current map of Jastrow parameters.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction. \nN::I: number of lattice sites.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.update_fermionic_Tvec!","page":"API","title":"VariationalMC.update_fermionic_Tvec!","text":"update_fermionic_Tvec!( markov_move::MarkovMove{I}, \n                        spin::I, \n                        jastrow_parameters::JastrowParameters{S, K, V, I},\n                        jastrow_factor::JastrowFactor{E}, \n                        detwf::DeterminantalWavefunction,\n                        model_geometry::ModelGeometry, \n                        n_stab_T::I, \n                        δT::E, \n                        pht::Bool ) where {S<:AbstractString, K, V, I<:Integer, E<:AbstractFloat}\n\nUpdates elements T_i of the fermion-type T vector after an accepted Metropolis step.\n\nmarkov_move::MarkovMove{I}: quantities related to a Markov process. \nspin::I: spin of the current particle. \njastrow_parameters::JastrowParameters{S, K, V, I}: current set of Jastrow variational parameters.\njastrow::JastrowFactor{E}: current Jastrow factor.\ndetwf::DeterminantalWavefunction: current determinantal wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nn_stab_T::I: frequency of T vector stabilization setps.\nδT::E: deviation threshold for the T vector.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_fermionic_jastrow_ratio","page":"API","title":"VariationalMC.get_fermionic_jastrow_ratio","text":"get_fermionic_jastrow_ratio( markov_move::MarkovMove{I}, \n                             jastrow_parameters::JastrowParameters{S, K, V, I},\n                             jastrow_factor::JastrowFactor{E}, \n                             pht::Bool, \n                             spin::I, \n                             model_geometry::ModelGeometry ) where {I<:Integer, S<:AbstractString, K, V, E<:AbstractFloat}\n\nCalculates ratio of fermionic Jastrow factors\n\nfracmathcalJ_1mathcalJ_2 = exps(T_l - T_k) + v_ll - v_lk\n\nafter a single particle completes a move from site k to site l using the corresponding T vectors T_k and T_l.\n\nmarkov_move::MarkovMove{I}: quantities related to a Markov process.  \njastrow_parameters::JastrowParameters{S, K, V, I}: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor{E}: current Jastrow factor.\npht::Bool: whether model is particle-hole transformed.\nspin::I: spin of the current particle.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\nget_fermionic_jastrow_ratio( k::I, \n                             l::I, \n                             jastrow_parameters::JastrowParameters{S, K, V, I},\n                             jastrow_factor::JastrowFactor{E}, \n                             pht::Bool, \n                             spin::I, \n                             model_geometry::ModelGeometry ) where {I<:Integer, S<:AbstractString, K, V, E<:AbstractFloat}\n\nCalculates ratio of fermionic Jastrow factors\n\nfracmathcalJ_1mathcalJ_2 = exp-s(T_l - T_k) + v_ll - v_lk\n\nafter a single particle completes a move from site k to site l using the corresponding T vectors T_k and T_l.\n\nk::Int: initial site of the current particle. \nl::Int: final site of the current particle. \njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor: current Jastrow factor.\npht::Bool: whether model is particle-hole transformed.\nspin::Int: spin of the current particle.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.map_jastrow_parameters","page":"API","title":"VariationalMC.map_jastrow_parameters","text":"map_jastrow_parameters( model_geometry::ModelGeometry, \n                        rng::AbstractRNG )\n\nGenerates a dictionary of irreducible index keys k with values being a tuple of all  lattice index pairs (ij), which generate k, and their associated Jastrow parameter  v_ij. The parameter corresponding to the largest irreducible index is initialized to zero.\n\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.  \nrng::AbstractRNG: random number generator.\n\n\n\n\n\nmap_jastrow_parameters( model_geometry::ModelGeometry, \n                        init_jpars::Vector{E} ) where {E<:AbstractFloat}\n\nGiven an initial set of Jastrow parameters from file, generates a dictionary of irreducible  index keys k with values being a tuple of all lattice index pairs (ij), which generate  k, and their associated Jastrow parameter v_ij. The parameter corresponding to the  largest irreducible index is initialized to zero.\n\nmodel_geometry::ModelGeometry: contains unit cell and lattice qunatities. \ninit_jpars::Vector{E}: initial Jastrow parameters from file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Markov-Methods","page":"API","title":"Markov Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"local_fermion_update!","category":"page"},{"location":"api/#VariationalMC.local_fermion_update!","page":"API","title":"VariationalMC.local_fermion_update!","text":"local_fermion_update!( detwf::DeterminantalWavefunction{T, V, E, I},\n                       Np::I, \n                       model_geometry::ModelGeometry, \n                       n_stab_W::I,\n                       δW::E, \n                       rng::AbstractRNG ) where {T<:Number, V, E<:AbstractFloat, I<:Integer}\n\nPerforms a local update to the fermionic sector by attempting to move a particle beta at a randomly  selected lattice site k to another random site l, with the move accepted or rejected by the Meteropolis algorithm.\n\ndetwf::DeterminantalWavefunction{T, V, E, I}: current determinantal variational wavefunction.\nNp::I: total number of particles in the system.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nn_stab_W::I: frequency of Green's function stabilization steps.\nδW::E: error threshold for the Green's function.\nrng::AbstractRNG: random number generator.\n\n\n\n\n\nlocal_fermion_update!( detwf::DeterminantalWavefunction{T, Q, E, I}, \n                       jastrow_factor::JastrowFactor{E}, \n                       jastrow_parameters::JastrowParameters{S, K, V, I},\n                       Np::I, \n                       model_geometry::ModelGeometry, \n                       pht::Bool, \n                       n_stab_W::I,\n                       n_stab_T::Int,\n                       δW::E, \n                       δT::E, \n                       rng::AbstractRNG ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, K, V}\n\nPerforms a local update to the fermionic sector by attempting to move a particle beta at a randomly  selected lattice site k to another random site l, with the move accepted or rejected by the Meteropolis algorithm.\n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current determinantal variational wavefunction.\njastrow_facor::JastrowFactor{E}: current Jastrow factor.\njastrow_parameters::JastrowParameters{S, K, V, I}: current set of Jastrow variational parameters.\nNp::I: total number of particles in the system.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\nn_stab_W::I: frequency of Green's function stabilization steps.\nn_stab_T::I: frequency of T vector stabilization steps.\nδW::E: error threshold for the Green's function.\nδT::E: error treshold for the Jastrow T vector.\nrng::AbstractRNG: random number generator.\n\n\n\n\n\nlocal_fermion_update!( detwf::DeterminantalWavefunction{T, Q, E, I}, \n                       jastrow_factor_1::JastrowFactor{E}, \n                       jastrow_factor_2::JastrowFactor{E}, \n                       jastrow_parameters_1::JastrowParameters{S, K, V, I},\n                       jastrow_parameters_2::JastrowParameters{S, K, V, I},\n                       Np::I, \n                       model_geometry::ModelGeometry, \n                       pht::Bool, \n                       n_stab_W::I,\n                       n_stab_T::I,\n                       δW::E, \n                       δT::E, \n                       rng::Xoshiro ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, K, V}\n\nPerforms a local update to the fermionic sector by attempting to move a particle beta at a randomly  selected lattice site k to another random site l, with the move accepted or rejected by the Meteropolis algorithm.\n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current determinantal variational wavefunction.\njastrow_factor_1::Jastrow{E}: first Jastrow factor.\njastrow_factor_2::Jastrow{E}: second Jastrow factor.\njastrow_parameters_1::JastrowParameters{S, K, V, I}: first set of Jastrow variational parameters.\njastrow_parameters_2::JastrowParameters{S, K, V, I}: second set of Jastrow variational parameters.\nNp::I: total number of particles in the system.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nn_stab_W::I: frequency of Green's function stabilization steps.\nn_stab_T::I: frequency of T vector stabilization steps.\nδW::E: error threshold for the Green's function.\nδT::E: error treshold for the Jastrow T vector.\nrng::AbstractRNG: random number generator.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Methods-5","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.metropolis_step","category":"page"},{"location":"api/#VariationalMC.metropolis_step","page":"API","title":"VariationalMC.metropolis_step","text":"metropolis_step( detwf::DeterminantalWavefunction{T, Q, E, I}, \n                 Np::I, \n                 n_stab_W::I, \n                 δW::E,\n                 model_geometry::ModelGeometry, \n                 rng::AbstractRNG ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nAttempts to move particle beta at lattice site k to a randomly selected site l.\n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current determinantal variational wavefunction.\nNp::I: total number of particles in the system.\nn_stab_W::I: frequency of Green's function stabilization steps.\nδW::E: error threshold for the Green's function.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nrng::AbstractRNG: random number generator.\n\n\n\n\n\nmetropolis_step( detwf::DeterminantalWavefunction{T, Q, E, I}, \n                 jastrow_factor::JastrowFactor{E}, \n                 jastrow_parameters::JastrowParameters{S, K, V, I},\n                 Np::I, \n                 n_stab_W::I, \n                 n_stab_T::I, \n                 δW::E, \n                 δT::E, \n                 model_geometry::ModelGeometry, \n                 pht::Bool, \n                 rng::AbstractRNG ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nAttempts to move particle beta at lattice site k to a randomly selected site l.\n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\njastrow_factor::JastrowFactor{E}: current Jastrow factor.\njastrow_parameters::JastrowParameters{S, K, V, I}: current set of Jastrow parameters.\nNp::I: total number of particles in the system.\nn_stab_W::I: frequency of Green's function stabilization steps.\nn_stab_T::I: frequency of T vector stabilization steps.\nδW::E: error threshold for the Green's function.\nδT::E: error threshold for the T vector.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\nrng::AbstractRNG: random number generator.\n\n\n\n\n\nmetropolis_step( detwf::DeterminantalWavefunction{T, Q, E, I}, \n                 jastrow_factor_1::JastrowFactor{E}, \n                 jastrow_factor_2::JastrowFactor{E},\n                 jastrow_parameters_1::JastrowParameters{S, K, V, I}, \n                 jastrow_parameters_2::JastrowParameters{S, K, V, I},\n                 Np::I, \n                 n_stab_W::I, \n                 n_stab_T::I, \n                 δW::E, \n                 δT::E, \n                 model_geometry::ModelGeometry, \n                 pht::Bool, \n                 rng::Xoshiro ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nAttempts to move particle beta at lattice site k to a randomly selected site l.\n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\njastrow_factor_1::JastrowFactor{E}: first Jastrow factor.\njastrow_factor_2::JastrowFactor{E}: second Jastrow factor.\njastrow_parameters_1::JastrowParameters{S, K, V, I}: first set of Jastrow parameters.\njastrow_parameters_2::JastrowParameters{S, K, V, I}: second set of Jastrow parameters.\nNp::I: total number of particles in the system.\nn_stab_W::I: frequency of Green's function stabilization steps.\nn_stab_T::I: frequency of T vector stabilization steps.\nδW::E: error threshold for the Green's function.\nδT::E: error threshold for the T vector.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\nrng::AbstractRNG: random number generator.\n\n\n\n\n\n","category":"function"},{"location":"api/#ParticleConfiguration-Types-and-Methods","page":"API","title":"ParticleConfiguration Types and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"get_particle_density","category":"page"},{"location":"api/#VariationalMC.get_particle_density","page":"API","title":"VariationalMC.get_particle_density","text":"get_particle_density( density::E, \n                      model_geometry::ModelGeometry,\n                      pht::Bool ) where {E<:AbstractFloat}\n\nGiven a particle density, returns the total number of particles N_p, the total number of  electrons N_e number of spin-up fermions n_uparrow, number of spin-down fermions n_downarrow. In cases where the given density is not a commensurate filling, a new density will be  calculated to correspond with the new particle number. \n\ndensity::E: desired electronic density.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities. \npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nget_particle_density( Np::I,\n                      model_geometry::ModelGeometry,\n                      pht::Bool ) where {I<:Integer}\n\nGiven the total number of particles in the lattice N_p, returns the particle density,  the total number of electrons N_e, the number of spin-up fermions n_uparrow and  the number of spin-down fermions n_downarrow.\n\nNp::I: total number of particles. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities. \npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nget_particle_density( nup::I, \n                      ndn::I,\n                      model_geometry::ModelGeometry, \n                      pht::Bool ) where {I<:Integer}\n\nGiven the number of spin-up fermions n_uparrow, and number of spin-down fermions n_downarrow,  returns the particle density, total number of particles N_p, and the total number of electrons N_e.\n\nnup::I: number of spin-up fermions.\nndn::I: number of spin-down fermions.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Types-and-Methods","page":"API","title":"Internal Types and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.MarkovMove\nVariationalMC.propose_random_move\nVariationalMC.hop!\nVariationalMC.generate_initial_fermion_configuration!\nVariationalMC.get_onsite_fermion_occupation\nVariationalMC.get_spindex_type\nVariationalMC.get_index_from_spindex\nVariationalMC.get_spindices_from_index\nVariationalMC.get_linked_spindex","category":"page"},{"location":"api/#VariationalMC.MarkovMove","page":"API","title":"VariationalMC.MarkovMove","text":"MarkovMove{I<:Integer}\n\nA type defining a Markov process where a particle is proposed to moved from spindex k to spindex l and a Boolean denoting whether said move is possible.\n\nparticle::I: the particle undergoing a Markov process.\nk::I: initial spindex of the particle.\nl::I: final spindex of the particle. \npossible::B: whether the Markov process is possible.\n\n\n\n\n\n","category":"type"},{"location":"api/#VariationalMC.propose_random_move","page":"API","title":"VariationalMC.propose_random_move","text":"propose_random_move( Np::I, \n                     pconfig::AbstractVector{I}, \n                     model_geometry::ModelGeometry, \n                     rng::AbstractRNG ) where {I<:Integer}\n\nProposes randomly moving (via hopping or exchange) a particle from some intial spindex k  to a neighboring spindex l and returns an instance of MarkovMove.\n\nNp::I: total number of particles in the system.  \npconfig::AbstractVector{I}: current particle configuration. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities. \nrng::AbstractRNG: random number generator.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.hop!","page":"API","title":"VariationalMC.hop!","text":"hop!( markov_move::MarkovMove{I}, \n      pconfig::AbstractVector{I} ) where {I<:Integer}\n\nIf a proposed move (hopping) is accepted, updates the particle positions in  the currenrt configuration.\n\nmarkov_move::MarkovMove{I}: quantities related to a Markov process.  \npconfig::AbstractVector{I}: current particle configuration. \n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.generate_initial_fermion_configuration!","page":"API","title":"VariationalMC.generate_initial_fermion_configuration!","text":"generate_initial_fermion_configuration!( pconfig::AbstractVector{I},\n                                         nup::I, \n                                         ndn::I, \n                                         model_geometry::ModelGeometry, \n                                         rng::AbstractRNG ) where {I<:Integer}\n\nGenerates a random initial configuration of spin-up and spin-down fermions. The first N  elements correspond to spin-up and the last N correspond to spin-down. Occupation is  denoted by a positive integer corresponding to that particle's creation operator label. \n\npconfig::Vector{I}: vector to store configurations.\nnup::I: number of spin-up fermions.\nndn::I: number of spin-down fermions.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nrng::AbstractRNG: random number generator.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_onsite_fermion_occupation","page":"API","title":"VariationalMC.get_onsite_fermion_occupation","text":"get_onsite_fermion_occupation( site::I, \n                               pconfig::AbstractVector{I},\n                               N::I ) where {I<:Integer}\n\nReturns the number of spin-up and spin-down fermions occupying a real lattice site i.  \n\nsite::I: lattice site. \npconfig::AbstractVector{I}: current particle configuration.\nN::I: total number of sites.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_spindex_type","page":"API","title":"VariationalMC.get_spindex_type","text":"get_spindex_type( spindex::I, \n                  model_geometry::ModelGeometry ) where {I<:Integer}\n\nReturns the spin species at a given spindex.\n\nspindex::I: spin index.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_index_from_spindex","page":"API","title":"VariationalMC.get_index_from_spindex","text":"get_index_from_spindex( spindex::I, \n                        model_geometry::ModelGeometry ) where {I<:Integer}\n\nReturns the lattice site i for a given spindex.\n\nspindex::I: spin index.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_spindices_from_index","page":"API","title":"VariationalMC.get_spindices_from_index","text":"get_spindices_from_index( index::I, \n                          model_geometry::ModelGeometry ) where {I<:Integer}\n\nReturns spin-up and spin-down indices from a given site index.\n\nindex::I: lattice site index.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_linked_spindex","page":"API","title":"VariationalMC.get_linked_spindex","text":"get_linked_spindex( i::I, \n                    N::I ) where {I<:Integer}\n\nGiven an index i in the spin-up sector, returns an index in the spin-down sector.\n\ni::I: lattice index in the spin-up sector.\nN::I: total number of lattice sites. \n\n\n\n\n\n","category":"function"},{"location":"api/#Optimizer-Methods","page":"API","title":"Optimizer Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"optimize_parameters!","category":"page"},{"location":"api/#VariationalMC.optimize_parameters!","page":"API","title":"VariationalMC.optimize_parameters!","text":"optimize_parameters!( measurement_container::NamedTuple, \n                      determinantal_parameters::DeterminantalParameters{I}, \n                      η::E, \n                      dt::E, \n                      bin_size::I ) where {I<:Integer, E<:AbstractFloat}\n\nOptimizes and updates variational parameters using the Stochastic Reconfiguration method, in which the variation in parameter alpha_k can be found by solving deltaalpha_k = (S + etamathbbI)f^-1, where S is the covariance matrix, f is the force vector, and eta is a stabilization parameter.\n\nmeasurement_container::NamedTuple: container where measurements are stored. \ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\nη::E: optimization stabilization factor. \ndt::E: optimization rate. \nbin_size::I: length of the bins. \n\n\n\n\n\noptimize_parameters!( measurement_container::NamedTuple, \n                      determinantal_parameters::DeterminantalParameters{I}, \n                      jastrow_parameters::JastrowParameters{T, K, V, I}, \n                      η::E, \n                      dt::E, \n                      dt_J::E,\n                      bin_size::I ) where {I<:Integer, T<:AbstractString, K, V, E<:AbstractFloat}\n\nOptimizes and updates variational parameters using the Stochastic Reconfiguration method, in which the variation in parameter alpha_k can be found by solving deltaalpha_k = (S + etamathbbI)f^-1, where S is the covariance matrix, f is the force vector, and eta is a stabilization parameter.\n\nmeasurement_container::NamedTuple: container where measurements are stored. \ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\njastrow_parameters::JastrowParameters{T, K, V, I}: set of Jastrow variational parameters. \nη::E: optimization stabilization factor. \ndt::E: optimization rate. \ndt_J::E: boost in the optimization rate of the Jastrow parameters.\nbin_size::I: length of the bins. \n\n\n\n\n\noptimize_parameters!( measurement_container::NamedTuple, \n                      determinantal_parameters::DeterminantalParameters{I}, \n                      jastrow_parameters_1::JastrowParameters{T, K, V, I},\n                      jastrow_parameters_2::JastrowParameters{T, K, V, I}, \n                      η::E, \n                      dt::E, \n                      bin_size::I ) where {I<:Integer, T<:AbstractString, K, V, E<:AbstractFloat}\n\nOptimizes and updates variational parameters using the Stochastic Reconfiguration method, in which the variation in parameter alpha_k can be found by solving deltaalpha_k = (S + etamathbbI)f^-1, where S is the covariance matrix, f is the force vector, and eta is a stabilization parameter.\n\nmeasurement_container::NamedTuple: container where measurements are stored. \ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\njastrow_parameters_1::JastrowParameters{T, K, V, I}: set of Jastrow variational parameters.\njastrow_parameters_2::JastrowParameters{T, K, V, I}: set of Jastrow variational parameters. \nη::E: optimization stabilization factor. \ndt::E: optimization rate. \nbin_size::I: length of the bins. \n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Methods-6","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.get_Δk\nVariationalMC.get_covariance_matrix\nVariationalMC.get_force_vector","category":"page"},{"location":"api/#VariationalMC.get_Δk","page":"API","title":"VariationalMC.get_Δk","text":"get_Δk( optimize::NamedTuple, \n        determinantal_parameters::DeterminantalParameters{I}, \n        detwf::DeterminantalWavefunction{T, V, E, I}, \n        model_geometry::ModelGeometry, \n        Np::I ) where {I<:Integer, T<:Number, V, E<:AbstractFloat}\n\nCalculates the local logarithmic derivative Delta_k = fracpartiallnPsi_Tpartialalpha_k,  for each determinantal variational parameter alpha_k and returns a vector of derivatives.\n\noptimize::NamedTuple: field of optimization flags.\ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\ndetwf::DeterminantalWavefunction{T, V, E, I}: current variational wavefunction. \n`model_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNp::I: total number of particles in the system.\n\n\n\n\n\nget_Δk( optimize::NamedTuple, \n        jastrow_parameters::JastrowParameters{T, K, V, I},\n        detwf::DeterminantalWavefunction{Q, F, E, I}, \n        pht::Bool ) where {T<:AbstractString, K, V, I<:Integer, Q<:Number, F, E<:AbstractFloat}\n\nCalculates the local logarithmic derivative Delta_k = fracpartiallnPsi_Tpartialalpha_k,  for each determinantal variational parameter alpha_k and returns a vector of derivatives.\n\noptimize::NamedTuple: field of optimization flags.\njastrow_parameters::JastrowParameters{T, K, V, I}: current set of Jastrow variational parameters. \ndetwf::DeterminantalWavefunction{Q, F, E, I}: current variational wavefunction. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_covariance_matrix","page":"API","title":"VariationalMC.get_covariance_matrix","text":"get_covariance_matrix( measurement_container::NamedTuple, \n                       opt_bin_size::I ) where {I<:Integer}\n\nCalculates the covariance matrix S with elements S_kk = langle Delta_kDelta_k^primerangle - langle Delta_k ranglelangle Delta_k^prime rangle.\n\nmeasurement_container::NamedTuple: container where measurements are stored. \nopt_bin_size::I: length of the current bin.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_force_vector","page":"API","title":"VariationalMC.get_force_vector","text":"get_force_vector( measurement_container::NamedTuple, \n                  opt_bin_size::I ) where {I<:Integer}\n\nConstructs force vector f with elements f_k = langle Delta_k ranglelangle Hrangle - langle Delta_kHrangle.\n\nmeasurement_container::NamedTuple: container where measurements are stored. \nopt_bin_size::I: length of the current bin.\n\n\n\n\n\n","category":"function"},{"location":"api/#Measurement-Methods","page":"API","title":"Measurement Methods","text":"","category":"section"},{"location":"api/#Intitialize-Measurements","page":"API","title":"Intitialize Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"initialize_measurement_container\ninitialize_measurement_directories","category":"page"},{"location":"api/#VariationalMC.initialize_measurement_container","page":"API","title":"VariationalMC.initialize_measurement_container","text":"initialize_measurement_container( N_opt::I, \n                                  opt_bin_size::I, \n                                  N_sim::I, \n                                  sim_bin_size::I,\n                                  determinantal_parameters::DeterminantalParameters{I}, \n                                  model_geometry::ModelGeometry ) where {I<:Integer}\n\nInitializes a set of dictionaries containing generic arrays for storing measurements.\n\nN_opt::I: number of optimization updates.\nopt_bin_size::I: length of an optimization bin.\nN_sim::I: number of simulation bins.\nsim_bin_size::I: length of a simulation bin. \ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\ninitialize_measurement_container( N_opt::I, \n                                  opt_bin_size::I, \n                                  N_sim::I, \n                                  sim_bin_size::I,\n                                  determinantal_parameters::DeterminantalParameters{I}, \n                                  jastrow_parameters::JastrowParameters{S, K, V, I},\n                                  model_geometry::ModelGeometry ) where {I<:Integer, S<:AbstractString, K, V}\n\nInitializes a set of dictionaries containing generic arrays for storing measurements.\n\nN_opt::I: number of optimization updates.\nopt_bin_size::I: length of an optimization bin.\nN_sim::I: number of simulation bins.\nsim_bin_size::I: length of a simulation bin. \ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\njastrow_parameters::JastrowParameters{S, K, V, I}: set of Jastrow variational parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\ninitialize_measurement_container( N_opt::I, \n                                  opt_bin_size::I, \n                                  N_sim::I, \n                                  sim_bin_size::I,\n                                  determinantal_parameters::DeterminantalParameters{I}, \n                                  jastrow_parameters_1::JastrowParameters{S, K, V, I},\n                                  jastrow_parameters_2::JastrowParameters{S, K, V, I},\n                                  model_geometry::ModelGeometry ) where {I<:Integer, S<:AbstractString, K, V}\n\nInitializes a set of dictionaries containing generic arrays for storing measurements.\n\nN_opt::I: number of optimization updates.\nopt_bin_size::I: length of an optimization bin.\nN_sim::I: number of simulation bins.\nsim_bin_size::I: length of a simulation bin. \ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\njastrow_parameters_1::JastrowParameters{S, K, V, I}: first set of Jastrow variational parameters.\njastrow_parameters_2::JastrowParameters{S, K, V, I}: second set of Jastrow variational parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.initialize_measurement_directories","page":"API","title":"VariationalMC.initialize_measurement_directories","text":"initialize_measurement_directories(;\n    simulation_info::SimulationInfo,\n    measurement_container::NamedTuple\n)\n\ninitialize_measurement_directories(\n        comm::MPI.Comm;\n        simulation_info::SimulationInfo,\n        measurement_container::NamedTuple\n)\n\ninitialize_measurement_directories(\n    simulation_info::SimulationInfo,\n    measurement_container::NamedTuple\n)\n\ninitialize_measurement_directories(\n        comm::MPI.Comm,\n        simulation_info::SimulationInfo,\n        measurement_container::NamedTuple\n)\n\nInitialize the measurement directories for simulation. If using MPI and a comm::MPI.Comm object is passed as the first argument, then none of the MPI processes will proceed beyond this function call until the measurement directories have been initialized.\n\n\n\n\n\n","category":"function"},{"location":"api/#Scalar-Measurements","page":"API","title":"Scalar Measurements","text":"","category":"section"},{"location":"api/#Internal-Methods-7","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.get_local_energy\nVariationalMC.get_local_kinetic_energy\nVariationalMC.get_local_hubbard_energy\nVariationalMC.get_double_occ\nVariationalMC.get_n\nVariationalMC.get_Sz","category":"page"},{"location":"api/#VariationalMC.get_local_energy","page":"API","title":"VariationalMC.get_local_energy","text":"get_local_energy( detwf::DeterminantalWavefunction{T, Q, E, I}, \n                  tight_binding_model::TightBindingModel{E}, \n                  model_geometry::ModelGeometry, \n                  U::E,\n                  Np::I, \n                  pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nCalculates the local variational energy E_mathrmvar per site for a Hubbard model.\n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard interaction.\nNp::I: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nget_local_energy( detwf::DeterminantalWavefunction{T, Q, E, I}, \n                  tight_binding_model::TightBindingModel{E},\n                  jastrow_parameters::JastrowParameters{S, K, V, I}, \n                  jastrow_factor::JastrowFactor{E},\n                  model_geometry::ModelGeometry,\n                  U::E,\n                  Np::I,\n                  pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nCalculates the local variational energy E_mathrmvar per site for a Hubbard model.\n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model. \njastrow_parameters::JastrowParameters{S, K, V, I}: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor{E}: current Jastrow factor.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard interaction.\nNp::I: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nget_local_energy( detwf::DeterminantalWavefunction{T, Q, E, I}, \n                  tight_binding_model::TightBindingModel,\n                  jastrow_parameters_1::JastrowParameters{S, K, V, I},\n                  jastrow_parameters_2::JastrowParameters{S, K, V, I}, \n                  jastrow_factor_1::JastrowFactor{E},\n                  jastrow_factor_2::JastrowFactor{E},\n                  model_geometry::ModelGeometry,\n                  U::E,\n                  Np::I,\n                  pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nCalculates the local variational energy E_mathrmvar per site for a Hubbard model.\n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model. \njastrow_parameters_1::JastrowParameters{S, K, V, I}: first set of Jastrow variational parameters.\njastrow_parameters_2::JastrowParameters{S, K, V, I}: second set of Jastrow variational parameters.\njastrow_factor_1::JastrowFactor{E}: first Jastrow factor.\njastrow_factor_2::JastrowFactor{E}: second Jastrow factor.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard interaction.\nNp::I: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_local_kinetic_energy","page":"API","title":"VariationalMC.get_local_kinetic_energy","text":"get_local_kinetic_energy( detwf::DeterminantalWavefunction{T, Q, E, I}, \n                          tight_binding_model::TightBindingModel{E}, \n                          model_geometry::ModelGeometry, \n                          Np::I\n                          pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nCalculates the local kinetic energy E_mathrmkin . \n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNp::I: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nget_local_kinetic_energy( detwf::DeterminantalWavefunction{T, Q, E, I}, \n                          tight_binding_model::TightBindingModel{E}, \n                          jastrow_parameters::JastrowParameters{S, K, V, I},\n                          jastrow_factor::JastrowFactor{E}, \n                          model_geometry::ModelGeometry, \n                          Np::I,\n                          pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nCalculates the local kinetic energy E_mathrmkin . \n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model. \njastrow_parameters::JastrowParameters{S, K, V, I}: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor{E}: current Jastrow factor.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNp::I: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nget_local_kinetic_energy( detwf::DeterminantalWavefunctionT, Q, E, I}, \n                          tight_binding_model::TightBindingModel{E}, \n                          jastrow_parameters_1::JastrowParameters{S, K, V, I},\n                          jastrow_parameters_2::JastrowParameters{S, K, V, I},\n                          jastrow_factor_1::JastrowFactor{E},\n                          jastrow_factor_2::JastrowFactor{E}, \n                          model_geometry::ModelGeometry, \n                          Np::I,\n                          pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nCalculates the local kinetic energy E_mathrmkin . \n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model. \njastrow_parameters_1::JastrowParameters{S, K, V, I}: first set of Jastrow variational parameters.\njastrow_parameters_2::JastrowParameters{S, K, V, I}: second set of Jastrow variational parameters.\njastrow_factor_1::JastrowFactor{E}: first Jastrow factor.\njastrow_factor_2::JastrowFactor{E}: second Jastrow factor.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNp::I: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_local_hubbard_energy","page":"API","title":"VariationalMC.get_local_hubbard_energy","text":"get_local_hubbard_energy( U::E, \n                          detwf::DeterminantalWavefunction{T, Q, E, I}, \n                          model_geometry::ModelGeometry, \n                          pht::Bool ) where {E<:AbstractFloat, T<:Number, Q, I<:Integer}\n\nCalculates the energy due to on-site Hubbard interaction U.  \n\nU::E: Hubbard interaction.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_double_occ","page":"API","title":"VariationalMC.get_double_occ","text":"get_double_occ( detwf::DeterminantalParameters{T, Q, E, I}, \n                model_geometry::ModelGeometry, \n                pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nCalculates the average double occupancyD = sum_i n_boldsymboliuparrown_boldsymbolidownarrow. \n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_n","page":"API","title":"VariationalMC.get_n","text":"get_n( detwf::DeterminantalWavefunction{T, Q, E, I}, \n       model_geometry::ModelGeometry,\n       pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nCalculate the average particle density n = sum_i (n_boldsymboliuparrow + n_boldsymbolidownarrow).\n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_Sz","page":"API","title":"VariationalMC.get_Sz","text":"get_Sz( detwf::DeterminantalWavefunction{T, Q, E, I}, \n        model_geometry::ModelGeometry,\n        pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nCalculate the average value of the operator  S_z = frac12 sum_i (n_boldsymboliuparrow - n_boldsymbolidownarrow).\n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optimization-Measurements","page":"API","title":"Optimization Measurements","text":"","category":"section"},{"location":"api/#Internal-Methods-8","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.measure_Δk!\nVariationalMC.measure_ΔkΔkp!\nVariationalMC.measure_ΔkE!","category":"page"},{"location":"api/#VariationalMC.measure_Δk!","page":"API","title":"VariationalMC.measure_Δk!","text":"measure_Δk!( measurement_container::NamedTuple, \n             detwf::DeterminantalWavefunction{T, Q, E, I}, \n             determinantal_parameters::DeterminantalParameters{I}, \n             optimize::NamedTuple,\n             model_geometry::ModelGeometry, \n             Np::I ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nMeasures the logarithmic derivative Delta_k for k variational parameters and then writes them to the measurement container. \n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\ndeterminantal_parameters::DeterminantalParameters{I}: current set of determinantal variational parameters.\noptimize::NamedTuple:: tuple of optimization flags.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNp::I: total number of particles in the system. \n\n\n\n\n\nmeasure_Δk!( measurement_container::NamedTuple, \n             detwf::DeterminantalWavefunction{T, Q, E, I}, \n             determinantal_parameters::DeterminantalParameters{I}, \n             jastrow_parameters::JastrowParameters{S, K, V, I}, \n             optimize::NamedTuple,\n             model_geometry::ModelGeometry, \n             Np::I, \n             pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nMeasures the logarithmic derivative Delta_k for `k variational parameters and then writes them to the measurement container. \n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\ndeterminantal_parameters::DeterminantalParameters: current set of determinantal variational parameters.\njastrow_parameters::JastrowParameters{S, K, V, I}: first set of Jastrow variational parameters.\noptimize::NamedTuple:: tuple of optimization flags.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNp::I: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nmeasure_Δk!( measurement_container::NamedTuple, \n             detwf::DeterminantalWavefunction{T, Q, E, I}, \n             determinantal_parameters::DeterminantalParameters{I}, \n             jastrow_parameters_1::JastrowParameters{S, K, V, I},\n             jastrow_parameters_2::JastrowParameters{S, K, V, I},\n             optimize::NamedTuple,\n             model_geometry::ModelGeometry, \n             Np::I, \n             pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nMeasures the logarithmic derivative Delta_k for `k variational parameters and then writes them to the measurement container. \n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ndeterminantal_parameters::DeterminantalParameters: current set of determinantal variational parameters.\njastrow_parameters_1::JastrowParameters: first set of Jastrow variational parameters.\njastrow_parameters_2::JastrowParameters: second set of Jastrow variational parameters.\noptimize::NamedTuple:: tuple of optimization flags.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNp::Int: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.measure_ΔkΔkp!","page":"API","title":"VariationalMC.measure_ΔkΔkp!","text":"measure_ΔkΔkp!( measurement_container::NamedTuple, \n                detwf::DeterminantalWavefunction{T, Q, E, I}, \n                determinantal_parameters::DeterminantalParameters{I}, \n                optimize::NamedTuple,\n                model_geometry::ModelGeometry, \n                Np::I ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nMeasures the product of logarithmic derivatives Delta_kDelta_k^prime and then writes them to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ndeterminantal_parameters::DeterminantalParameters: current variational determinantal parameters.\noptimize::NamedTuple:: tuple of optimization flags.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNp::Int: total number of particles in the system.\n\n\n\n\n\nmeasure_ΔkΔkp!( measurement_container::NamedTuple, \n                detwf::DeterminantalWavefunction{T, Q, E, I}, \n                determinantal_parameters::DeterminantalParameters{I}, \n                jastrow_parameters::JastrowParameters{S, K, V, I},\n                optimize::NamedTuple,\n                model_geometry::ModelGeometry, \n                Np::I, \n                pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nMeasures the product of logarithmic derivatives Delta_kDelta_k^prime and then writes them to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ndeterminantal_parameters::DeterminantalParameters: current set of determinantal variational parameters.\njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\noptimize::NamedTuple:: tuple of optimization flags.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNp::Int: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nmeasure_ΔkΔkp!( measurement_container::NamedTuple, \n                detwf::DeterminantalWavefunction{T, Q, E, I}, \n                determinantal_parameters::DeterminantalParameters{I}, \n                jastrow_parameters_1::JastrowParameters{S, K, V, I},\n                jastrow_parameters_2::JastrowParameters{S, K, V, I},\n                optimize::NamedTuple,\n                model_geometry::ModelGeometry, \n                Np::I, \n                pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nMeasures the product of logarithmic derivatives Delta_kDelta_k^prime and then writes them to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ndeterminantal_parameters::DeterminantalParameters: current set of determinantal variational parameters.\njastrow_parameters_1::JastrowParameters: first set of Jastrow variational parameters.\njastrow_parameters_2::JastrowParameters: second set of Jastrow variational parameters.\noptimize::NamedTuple:: tuple of optimization flags.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNp::Int: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.measure_ΔkE!","page":"API","title":"VariationalMC.measure_ΔkE!","text":"measure_ΔkE!( measurement_container::NamedTuple, \n              detwf::DeterminantalWavefunction{T, Q, E, I}, \n              tight_binding_model::TightBindingModel{E}, \n              determinantal_parameters::DeterminantalParameters{I}, \n              optimize::NamedTuple,\n              model_geometry::ModelGeometry, \n              U::E,\n              Np::I, \n              pht::Bool )where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nMeasures the product of logarithmic derivatives with the local energy Delta_kE and then writes them to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction. \ntight_binding_model::TightBindingModel: parameter for a non-interacting tight-binding model.\ndeterminantal_parameters::DeterminantalParameters: current set of determinantal variational parameters.\noptimize::NamedTuple:: tuple of optimization flags.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard repulsion.\nNp::Int: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nmeasure_ΔkE!( measurement_container::NamedTuple, \n              detwf::DeterminantalWavefunction{T, Q, E, I}, \n              tight_binding_model::TightBindingModel{E}, \n              determinantal_parameters::DeterminantalParameters{I}, \n              jastrow_parameters::JastrowParameters{S, K, V, I}, \n              jastrow_factor::JastrowFactor{E, I},\n              optimize::NamedTuple,\n              model_geometry::ModelGeometry, \n              U::E,\n              Np::I, \n              pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nMeasures the product of logarithmic derivatives with the local energy Delta_kE and then writes them to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ntight_binding_model::TightBindingModel: parameters for a non-interacting tight-binding model.\ndeterminantal_parameters::DeterminantalParameters: current set of determinantal variational parameters.\njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor: current Jastrow factor.\noptimize::NamedTuple:: tuple of optimization flags.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard repulsion.\nNp::Int: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nmeasure_ΔkE!( measurement_container::NamedTuple, \n              detwf::DeterminantalWavefunction{T, Q, E, I}, \n              tight_binding_model::TightBindingModel{E}, \n              determinantal_parameters::DeterminantalParameters{I}, \n              jastrow_parameters_1::JastrowParameters{S, K, V, I},\n              jastrow_parameters_2::JastrowParameters{S, K, V, I}, \n              jastrow_factor_1::JastrowFactor{E, I},\n              jastrow_factor_2::JastrowFactor{E, I},\n              optimize::NamedTuple,\n              model_geometry::ModelGeometry, \n              U::E,\n              Np::I, \n              pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nMeasures the product of logarithmic derivatives with the local energy Delta_kE and then writes them to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ntight_binding_model::TightBindingModel: parameters for a non-interacting tight-binding model.\ndeterminantal_parameters::DeterminantalParameters: current set of determinantal variational parameters.\njastrow_parameters_1::JastrowParameters: first set of Jastrow variational parameters.\njastrow_parameters_2::JastrowParameters: second set of Jastrow variational parameters.\njastrow_factor_1::JastrowFactor: first Jastrow factor.\njastrow_factor_2::JastrowFactor: second Jastrow factor.\noptimize::NamedTuple:: tuple of optimization flags.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard repulsion.\nNp::Int: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation-Measurements","page":"API","title":"Simulation Measurements","text":"","category":"section"},{"location":"api/#Internal-Methods-9","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.measure_local_energy!\nVariationalMC.measure_double_occ!\nVariationalMC.measure_n!\nVariationalMC.measure_Sz!","category":"page"},{"location":"api/#VariationalMC.measure_local_energy!","page":"API","title":"VariationalMC.measure_local_energy!","text":"measure_local_energy!( measurement_container::NamedTuple, \n                       detwf::DeterminantalWavefunction{T, Q, E, I}, \n                       tight_binding_model::TightBindingModel{E}, \n                       model_geometry::ModelGeometry,\n                       U::E,\n                       Np::I,\n                       pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nMeasures the total local energy E_mathrmloc for a Hubbard model and writes to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard interaction.\nNp::I: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nmeasure_local_energy!( measurement_container::NamedTuple, \n                       detwf::DeterminantalWavefunction{T, Q, E, I}, \n                       tight_binding_model::TightBindingModel{E}, \n                       jastrow_parameters::JastrowParameters{S, K, V, I},\n                       jastrow_factor::JastrowFactor{E}, \n                       model_geometry::ModelGeometry,\n                       U::E,\n                       Np::I, \n                       pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nMeasures the total local energy E_mathrmloc for a Hubbard model and writes to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model. \njastrow_parameters::JastrowParameters{S, K, V, I}: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor{E}: current Jastrow factor. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard interaction.\nNp::I: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nmeasure_local_energy!( measurement_container::NamedTuple, \n                       detwf::DeterminantalWavefunction{T, Q, E, I}, \n                       tight_binding_model::TightBindingModel{E}, \n                       jastrow_parameters_1::JastrowParameters{S, K, V, I},\n                       jastrow_parameters_2::JastrowParameters{S, K, V, I},\n                       jastrow_factor_1::JastrowFactor{E},\n                       jastrow_factor_2::JastrowFactor{E}, \n                       model_geometry::ModelGeometry,\n                       U::E,\n                       Np::I, \n                       pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nMeasures the total local energy E_mathrmloc for a Hubbard model and writes to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\ntight_binding_model::TightBindingModel{E}: parameters for a non-interacting tight-binding model. \njastrow_parameters_1::JastrowParameters{S, K, V, I}: first set of Jastrow variational parameters.\njastrow_parameters_2::JastrowParameters{S, K, V, I}: second set of Jastrow variational parameters.\njastrow_factor_1::JastrowFactor{E}: first Jastrow factor.\njastrow_factor_2::JastrowFactor{E}: second Jastrow factor. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard interaction.\nNp::I: total number of particles in the system.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.measure_double_occ!","page":"API","title":"VariationalMC.measure_double_occ!","text":"measure_double_occ!( measurement_container::NamedTuple, \n                     detwf::DeterminantalWavefunction{T, Q, E, I}, \n                     model_geometry::ModelGeometry, \n                     pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nMeasures the average double occupancy langle Drangle.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.measure_n!","page":"API","title":"VariationalMC.measure_n!","text":"measure_n!( measurement_container::NamedTuple, \n            detwf::DeterminantalWavefunction{T, Q, E, I}, \n            model_geometry::ModelGeometry,\n            pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nMeasures the local particle density averaged over all sites langle nrangle.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.measure_Sz!","page":"API","title":"VariationalMC.measure_Sz!","text":"measure_Sz!( measurement_container::NamedTuple, \n            detwf::DeterminantalWavefunction{T, Q, E, I}, \n            model_geometry::ModelGeometry,\n            pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nMeasures the local spin z-component over averaged all sites langle S_zrangle.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Correlation-Measurements","page":"API","title":"Correlation Measurements","text":"","category":"section"},{"location":"api/#Internal-Methods-10","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.measure_density_correlation!\nVariationalMC.measure_spin_correlation!\nVariationalMC.get_site_dependent_n\nVariationalMC.get_site_dependent_s","category":"page"},{"location":"api/#VariationalMC.measure_density_correlation!","page":"API","title":"VariationalMC.measure_density_correlation!","text":"measure_density_correlation!( measurement_container::NameTuple,\n                              detwf::DeterminantalWavefunction{T, Q, E, I},\n                              model_geometry::ModelGeometry,\n                              pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nMeasures the equal-time density-density correlation function langle hatn_ihatn_jrangle.\n\nmeasurement_container::NamedTuple: container where measurements are stroed.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transform.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.measure_spin_correlation!","page":"API","title":"VariationalMC.measure_spin_correlation!","text":"measure_spin_correlation!( measurement_container::NamedTuple,\n                           detwf::DeterminantalWavefunction{T, Q, E, I},\n                           model_geometry::ModelGeometry,\n                           pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nMeasures the equal-time spin-spin correlation function langle hatS_ihatS_jrangle. \n\nmeasurement_container::NamedTuple: container where measurements are stroed.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transform.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_site_dependent_n","page":"API","title":"VariationalMC.get_site_dependent_n","text":"get_site_dependent_n( detwf::DeterminantalWavefunction{T, Q, E, I}, \n                      model_geometry::ModelGeometry,\n                      pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nCalculates the local density n_boldsymboli on each lattice site.\n\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_site_dependent_s","page":"API","title":"VariationalMC.get_site_dependent_s","text":"get_site_dependent_s( detwf::DeterminantalParameters{T, Q, E, I}\n                      model_geometry::ModelGeometry,\n                      pht::Bool )\n\nCalculates the local spin S_boldsymboli on each lattice site.\n\ndetwf::DeterminantalParameters{T, Q, E, I}: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Make-Measurements","page":"API","title":"Make Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"make_measurements!","category":"page"},{"location":"api/#VariationalMC.make_measurements!","page":"API","title":"VariationalMC.make_measurements!","text":"make_measurements!( measurement_container::NamedTuple, \n                    detwf::DeterminantalWavefunction{T, Q, E, I}, \n                    tight_binding_model::TightBindingModel{E}, \n                    determinantal_parameters::DeterminantalParameters{I}, \n                    optimize::NamedTuple,\n                    model_geometry::ModelGeometry,\n                    U::E,\n                    Np::I, \n                    pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nMeasures optimization and simulation observables including the local energy langle E_mathrmlocrangle, logarithmic derivatives langleDelta_krangle, langleDelta_kDelta_k^primerangle, langleDelta_kErangle, average double occupancy langle Drangle, and average density langle nrangle. Also records the current particle configuration xrangle.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current determinantal wavefunction.\ntight_binding_model::TightBindingModel{E}: non-interacting tight-binding model. \ndeterminantal_parameters{I}::DeterminantalParameters{I}: set of determinantal variational parameters.\noptimize::NamedTuple:: tuple of optimization flags.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard interaction.\nNp::I: total number of particles in the system.\npht::Bool: whether or not model is particle-hole transformed.\n\n\n\n\n\nmake_measurements!( measurement_container::NamedTuple, \n                    detwf::DeterminantalWavefunction{T, Q, E, I}, \n                    tight_binding_model::TightBindingModel{E},\n                    determinantal_parameters::DeterminantalParameters{I},\n                    jastrow_parameters::JastrowParameters{S, K, V, I},\n                    jastrow_factor::JastrowFactor{E, I},\n                    optimize::NamedTuple,\n                    model_geometry::ModelGeometry, \n                    U::E,\n                    Np::I, \n                    pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nMeasures optimization and simulation observables including the local energy langle E_mathrmlocrangle, logarithmic derivatives langleDelta_krangle, langleDelta_kDelta_k^primerangle, langleDelta_kErangle, average double occupancy langle Drangle, and average density langle nrangle. Also records the current particle configuration xrangle.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current determinantal wavefunction.\ntight_binding_model::TightBindingModel{E}: non-interacting tight-binding model. \ndeterminantal_parameters::DeterminantalParameters{I}: set of determinantal variational parameters.\njastrow_parameters::JastrowParameters{S, K, V, I}: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor{E, I}: current Jastrow factor. \noptimize::NamedTuple:: tuple of optimization flags.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard interaction.\nNp::I: total number of particles in the system.\npht::Bool: whether or not model is particle-hole transformed.\n\n\n\n\n\nmake_measurements!( measurement_container::NamedTuple, \n                    detwf::DeterminantalWavefunction{T, Q, E, I}, \n                    tight_binding_model::TightBindingModel{E},\n                    determinantal_parameters::DeterminantalParameters{I},\n                    jastrow_parameters_1::JastrowParameters{S, K, V, I},\n                    jastrow_parameters_2::JastrowParameters{S, K, V, I},\n                    jastrow_factor_1::JastrowFactor{E, I},\n                    jastrow_factor_2::JastrowFactor{E, I}, \n                    optimize::NamedTuple,\n                    model_geometry::ModelGeometry, \n                    U::E,\n                    Np::I, \n                    pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nMeasures optimization and simulation observables including the local energy langle E_mathrmlocrangle, logarithmic derivatives langleDelta_krangle, langleDelta_kDelta_k^primerangle, langleDelta_kErangle, average double occupancy langle Drangle, and average density langle nrangle. Also records the current particle configuration xrangle.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current determinantal wavefunction.\ntight_binding_model::TightBindingModel{E}: non-interacting tight-binding model. \ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\njastrow_parameters_1::JastrowParameters{S, K, V, I}: first set of Jastrow variational parameters.\njastrow_parameters_2::JastrowParameters{S, K, V, I}: second set of Jastrow variational parameters.\njastrow_factor_1::JastrowFactor{E, I}: first Jastrow factor.\njastrow_factor_2::JastrowFactor{E, I}: second Jastrow factor.\noptimize::NamedTuple:: tuple of optimization flags. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard interaction.\nNp::I: total number of particles in the system.\npht::Bool: whether or not model is particle-hole transformed.\n\n\n\n\n\nmake_measurements!( measurement_container::NamedTuple, \n                    detwf::DeterminantalWavefunction{T, Q, E, I}, \n                    tight_binding_model::TightBindingModel{E}, \n                    model_geometry::ModelGeometry, \n                    U::E,\n                    Np::I, \n                    pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer}\n\nMeasures simulation observables including the local energy langle E_mathrmlocrangle, average double occupancy langle Drangle, and average density langle nrangle. Also records the current particle configuration xrangle.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current determinantal wavefunction.\ntight_binding_model::TightBindingModel{E}: non-interacting tight-binding model. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard interaction.\nNp::I: total number of particles in the system.\npht::Bool: whether or not model is particle-hole transformed.\n\n\n\n\n\nmake_measurements!( measurement_container::NamedTuple, \n                    detwf::DeterminantalWavefunction{T, Q, E, I}, \n                    tight_binding_model::TightBindingModel{E}, \n                    jastrow_parameters::JastrowParameters{S, K, V, I},\n                    jastrow_factor::JastrowFactor{E}, \n                    model_geometry::ModelGeometry, \n                    U::E,\n                    Np::I, \n                    pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nMeasures simulation observables including the local energy langle E_mathrmlocrangle, average double occupancy langle Drangle, and average density langle nrangle. Also records the current particle configuration xrangle.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current determinantal wavefunction.\ntight_binding_model::TightBindingModel{E}: non-interacting tight-binding model. \njastrow_parameters::JastrowParameters{S, K, V, I}: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor{E}: current Jastrow factor. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard interaction.\nNp::I: total number of particles in the system.\npht::Bool: whether or not model is particle-hole transformed.\n\n\n\n\n\nmake_measurements!( measurement_container::NamedTuple, \n                    detwf::DeterminantalWavefunction{T, Q, E, I}, \n                    tight_binding_model::TightBindingModel{E}, \n                    jastrow_parameters_1::JastrowParameters{S, K, V, I},\n                    jastrow_parameters_2::JastrowParameters{S, K, V, I},\n                    jastrow_factor_1::JastrowFactor{E},\n                    jastrow_factor_2::JastrowFactor{E}, \n                    model_geometry::ModelGeometry, \n                    U::E,\n                    Np::I, \n                    pht::Bool ) where {T<:Number, Q, E<:AbstractFloat, I<:Integer, S<:AbstractString, K, V}\n\nMeasures simulation observables including the local energy langle E_mathrmlocrangle, average double occupancy langle Drangle, and average density langle nrangle. Also records the current particle configuration xrangle.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction{T, Q, E, I}: current determinantal wavefunction.\ntight_binding_model::TightBindingModel{E}: non-interacting tight-binding model. \njastrow_parameters_1::JastrowParameters{S, K, V, I}: first set of Jastrow variational parameters.\njastrow_parameters_2::JastrowParameters{S, K, V, I}: second set of Jastrow variational parameters.\njastrow_factor_1::JastrowFactor{E}: first Jastrow factor.\njastrow_factor_2::JastrowFactor{E}: second Jastrow factor. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nU::E: Hubbard interaction.\nNp::I: total number of particles in the system.\npht::Bool: whether or not model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Methods-11","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.reset_measurements!","category":"page"},{"location":"api/#VariationalMC.reset_measurements!","page":"API","title":"VariationalMC.reset_measurements!","text":"reset_measurements!( measurements::Dict{S, T}; \n                     in_place::Bool = false ) where {S<:AbstractString, T}\n\nResets values in the measurement container to zero.\n\nmeasurements::Dict{S, T}: measurement container.\nin_place::Bool = false: whether to perform in-place update of measurements. Best to set to false to prevent undesired mutation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Write-Measurements","page":"API","title":"Write Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"write_measurements!","category":"page"},{"location":"api/#VariationalMC.write_measurements!","page":"API","title":"VariationalMC.write_measurements!","text":"write_measurements!( step::AbstractString\n                     bin::I, \n                     bin_size::I,\n                     measurement_container::NamedTuple, \n                     simulation_info::SimulationInfo;\n                     write_parameters=false ) where {I<:Integer}\n\nWrites simulation and correlation (if measured) measurements in the current bin to file.  Files created are in HDF5 format. \n\nstep::AbstractString: VMC step: opt or sim, optimization or simulation.\nbin::I: current bin.\nbin_size::I: size of the current bins.\nmeasurement_container::NamedTuple: container where measurements are stored.\nsimulation_info::SimulationInfo: contains datafolder names.\nwrite_parameters=false: whether parameters are written to file. Set to true during optimization.\n\nData in each file can be accessed by doing:\n\nh5open(simfile, \"r\") do f     # list all top-level measurements     println(keys(f))  # e.g., [\"globaldensity\", \"double_occ\", ...]\n\n# access a specific dataset\ndata = read(f[\"/local_energy/bin-1/\"])  # returns a Julia array\nprintln(data)\n\nend\n\nfor num in 1:Noptbins     h5open(opt_file, \"r\") do f         data = read(f[\"/parameters/bin-num/\"])          println(data)     end end\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Methods-12","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.normalize_measurements","category":"page"},{"location":"api/#VariationalMC.normalize_measurements","page":"API","title":"VariationalMC.normalize_measurements","text":"normalize_measurements( data, \n                        bin_size::I, \n                        key::AbstractString )\n\nNormalizes different types of data by the length of a bin.\n\ndata: data of abstract type.\nbin_size::I: length of the bin.\nkey::AbstractString: name of measurement.\n\n\n\n\n\n","category":"function"},{"location":"api/#Process-Measurements","page":"API","title":"Process Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"process_measurements","category":"page"},{"location":"api/#VariationalMC.process_measurements","page":"API","title":"VariationalMC.process_measurements","text":"process_measurements( measurement_container::NamedTuple,\n                      simulation_info::SimulationInfo,\n                      determinantal_parameters::DeterminantalParameters,\n                      model_geometry::ModelGeometry )\n\nProcesses all simulation and optimization measurements by organinzing them into CSV files.\n\nmeasurement_container::NamedTuple: contains measurement quantities.\nsimulation_info::SimulationInfo: contains all simulation info.\ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities. \n\n\n\n\n\nprocess_measurements( measurement_container::NamedTuple,\n                      simulation_info::SimulationInfo,\n                      determinantal_parameters::DeterminantalParameters,\n                      jastrow_parameters::JastrowParameters,\n                      model_geometry::ModelGeometry )\n\nProcesses all simulation and optimization measurements by organinzing them into CSV files.\n\nmeasurement_container::NamedTuple: contains measurement quantities.\nsimulation_info::SimulationInfo: contains all simulation info.\ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\njastrow_parameters::JastrowParameters: set of Jastrow parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities. \n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Methods-13","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.process_scalar_measurements\nVariationalMC.process_optimization_measurements","category":"page"},{"location":"api/#VariationalMC.process_scalar_measurements","page":"API","title":"VariationalMC.process_scalar_measurements","text":"process_scalar_measurements( datafolder::T,\n                             pID::I,\n                             measurement::T;\n                             N_bins::Union{I, Nothing}=nothing) where {T<:AbstractString, I<:Integer}\n\nWrite binned simulation measurements to CSV.\n\ndatafolder::T: path to folder where simulation files are written.\npID::I: processor ID/MPI rank\nmeasurement::T: local_energy, double_occ, global_density, pconfig, or local_spin-z.\nN_bins::Union{I, Nothing}=nothing: (optional) total number of bins.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.process_optimization_measurements","page":"API","title":"VariationalMC.process_optimization_measurements","text":"process_optimization_measurements( datafolder::T,\n                                   pID::I,\n                                   determinantal_parameters::DeterminantalParameters;\n                                   N_bins::Union{I, Nothing}=nothing ) where {T<:AbstractString, I<:Integer}\n\nWrites binned optimization measurements to CSV.\n\ndatafolder::T: path to folder where simulation files are written.\npID::I: processor ID/MPI rank\ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\nN_bins::Union{I, Nothing}=nothing: (optional) total number of bins.\n\n\n\n\n\nprocess_optimization_measurements( datafolder::T,\n                                   pID::I,\n                                   determinantal_parameters::DeterminantalParameters,\n                                   jastrow_parameters::JastrowParameters;\n                                   N_bins::Union{I, Nothing}=nothing ) where {T<:AbstractString, I<:Integer}\n\nWrites binned optimization measurements to CSV.\n\ndatafolder::T: path to folder where simulation files are written.\npID::I: processor ID/MPI rank\ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\njastrow_parameters::JastrowParameters: set of Jastrow parameters.\nN_bins::Union{I, Nothing}=nothing: (optional) total number of bins.\n\n\n\n\n\n","category":"function"},{"location":"examples/#1)-Hubbard-model-on-a-1D-chain-(without-Jastrow-factor)","page":"Examples","title":"1) Hubbard model on a 1D chain (without Jastrow factor)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we will work through simulating a repulsive Hubbard model on a one dimensional (1D) chain. The Hubbard hamiltonian in 1D is given by","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"hatH = -t sum_i sigma (hatc^dagger_i sigma hatc^phantom dagger_i+1 sigma + rm Hc)\n-t^prime sum_i sigma (hatc^dagger_i sigma hatc^phantom dagger_i+2 sigma + rm hc)\n+ U sum_i hatn_i uparrowhatn_i downarrow \n- mu sum_i sigma hatn_i sigma","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where hatc^dagger_i sigma  (hatc^phantom dagger_i sigma) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_i sigma = hatc^dagger_i sigma hatc^phantom dagger_i sigma is the spin-sigma electron number operator for site i. In the above Hamiltonian (t^prime)  t is the (next-) nearest-neighbor hopping amplitude and U  0 controls the strength of the on-site Hubbard repulsion. Lastly, we note the system is half-filled and particle-hole symmetric when the next-nearest-neighbor hopping amplitude and the chemical potential is zero (t^prime = mu = 00).","category":"page"},{"location":"examples/#Import-packages","page":"Examples","title":"Import packages","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We begin by importing the necessary packages, including the Standard Library packages LinearAlgebra, Random, and Printf for perfroming linear algebra operations, random number generation, and C-style string formatting, respectively.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Linear Algebra\nusing Random\nusing Printf","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, we use LatticeUtilities which exports a suite of types and methods useful for defining arbitrary lattice geometries, and the construction of neighbor tables. Finally, we import the VariationalMC package.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeUtilities\nusing VariationalMC","category":"page"},{"location":"examples/#Specify-simulation-parameters","page":"Examples","title":"Specify simulation parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The main body of the simulation is wrapped in a top-level function named run_hubbard_chain_simulationthat will take as keyword arguments various model and simulation parameters that we may want to change. The specific meaning of each argument will be discussed in more detail in later sections of the tutorial.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# We define a top-level function for running the VMC simulation.\nfunction run_hubbard_chain_simulation(;\n    # KEYWORD ARGUMENTS\n    sID,                    # Simulation ID.\n    L,                      # System size.\n    U,                      # Hubbard interaction.\n    nup,                    # number of spin-up electrons.\n    ndn,                    # number of spin-down electrons.\n    pht,                    # Whether model is particle-hole transformed. \n    N_equil,                # Number of equilibration/thermalization updates.\n    N_opt,                  # Number of optimization steps.\n    N_opt_bins,             # Number of times bin-averaged measurements are written to file during optimization step.\n    N_sim,                  # Number of simulation steps.\n    N_sim_bins,             # Number of times bin-averaged measurements are written to file during simulation step.\n    dt = 0.03,              # Optimization rate.\n    η = 1e-4,               # Optimization stablity factor.\n    n_stab_W = 50,          # Green's function stabilization frequency.\n    δW = 1e-3,              # Maximum allowed error in the Green's function.          \n    seed = abs(rand(Int)),  # Seed for random number generator.\n    filepath=\".\"            # Filepath to where data folder will be created.\n)","category":"page"},{"location":"examples/#Initialize-simulation","page":"Examples","title":"Initialize simulation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this initial part of the script, we will specify what parameters in the trial wavefunction will be optimized and name our simulation. The NamedTuple called optimized will contain all possible parameters that are automatically initialized in the wavefunction. Setting a flag to true will cause that parameter value (or values) to change during the optimization. We also specify whether the model is particle-hole transformed and is required to be true if pairing symmetery is being added to the wavefunction. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Select which parameters in the variational wavefunction will be optimized.\n    optimize = (\n        # Spin-x or in-plane magnetization\n        Δ_sx = false,\n        # Spin-z or out-of-plane magnetization\n        Δ_sz = true,\n        # (BCS) Chemical potential\n        μ = false,\n        # Uniform charge density or Charge Density Wave\n        Δ_cdw = false,\n        # Density-density Jastrow factor\n        density_J = false\n    )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The datafolder is created by initializing an instances of the SimulationInfo type, and then calling the initialize_datafolder function. Iin addition, we initialize the random number generator that will be used throughout the simulation. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Construct the foldername the data will be written.\n    df_prefix = @sprintf(\"hubbard_chain_U%.2f_nup%.2f_ndn%.2f_L%d_opt\", U, nup, ndn, L)\n\n    # Append optimized parameter names to the foldername.\n    datafolder_prefix = create_datafolder_prefix(optimize, df_prefix)\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath, \n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    rng = Xoshiro(seed)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In addition, we can calculate the length of each bin by dividing the number of iterations/steps by the number of bins. The bin size is the number of measurements that are averaged over each time data is written during either the optimization or simulation steps.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Calculate optimization bins size.\n    opt_bin_size = div(N_opt, N_opt_bins) \n\n    # Calculate simulation bins size.\n    sim_bin_size = div(N_sim, N_sim_bins)","category":"page"},{"location":"examples/#Initialize-simulation-metadata","page":"Examples","title":"Initialize simulation metadata","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this section of the code we record important metadata about the simulation, including initializing the random number generator that will be used throughout the simulation. The important metadata within the simulation will be recorded in the metadata dictionary.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Record simulation metadata.\n    metadata = Dict()\n    metadata[\"N_equil\"] = N_equil\n    metadata[\"N_opt\"] = N_opt\n    metadata[\"N_sim\"] = N_sim\n    metadata[\"N_opt_bins\"] = N_opt_bins\n    metadata[\"N_sim_bins\"] = N_sim_bins\n    metadata[\"δW\"] = δW\n    metadata[\"n_stab_W\"] = n_stab_W\n    metadata[\"dt\"] = dt \n    metadata[\"acceptance_rate\"] = 0.0\n    metadata[\"opt_time\"] = 0.0\n    metadata[\"sim_time\"] = 0.0\n    metadata[\"vmc_time\"] = 0.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the above, sID stands for simulation ID, which is used to distinguish simulations that would otherwise be identical i.e. to distinguish simulations that use the same parameters and are only different in the random seed used to initialize the simulation. A valid sID is any positive integer greater than zero, and is used when naming the data folder the simulation results will be written to. Specifically, the actual data folder created above will be \"$(filepath)/$(datafolder_prefix)-$(sID)\". Note that if you set sID = 0, then it will instead be assigned smallest previously unused integer value. For instance, suppose the directory \"$(filepath)/$(datafolder_prefix)-1\" already exits. Then if you pass sID = 0 to SimulationInfo, then the simulation ID sID = 2 will be used instead, and a directory \"$(filepath)/$(datafolder_prefix)-2\" will be created.","category":"page"},{"location":"examples/#Initialize-model","page":"Examples","title":"Initialize model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The next part of the script defines the model that we will simulate. First we define the lattice geometry for our model, relying on the LatticeUtilities package to do so. We define a the unit cell and size of our finite lattice using the UnitCell and Lattice types, respectively. Lastly, we define various instances of the Bond type to represent the the nearest-neighbor and next-nearest-neighbor bonds. All of this information regarding the lattice geometry is then stored in an instance of the ModelGeometry type.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Initialize an instance of the UnitCell type.\n    unit_cell = UnitCell(\n        lattice_vecs = [[1.0]],\n        basis_vecs   = [[0.0]]\n    )\n\n    # Initialize an instance of the Lattice type.\n    lattice = Lattice(\n        [L], \n        [true]\n    )\n\n    # Define the nearest neighbor bonds.\n    bond_x = Bond(\n        orbitals = (1,1), \n        displacement = [1]\n    )\n\n    # Define next-nearest neighbor bonds.\n    bond_xp = Bond(\n        orbitals = (1,1), \n        displacement = [2]\n    )\n\n    # Collect all bond definitions into a single vector.\n    # Note that this has the structure [[nearest],[next-nearest]].\n    bonds = [[bond_x], [bond_xp]]\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(\n        unit_cell, \n        lattice, \n        bonds\n    )","category":"page"},{"location":"examples/#Initialize-model-parameters","page":"Examples","title":"Initialize model parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The next step is to initialize our model parameters, which includes calculating the particle density in the canonical ensemble. The get_particle_density method includes mutliple ways of specifying the particle information. Here, we have chosen to pass the number of spin-up and spin-down particles. The function then computes the corresponding total density, particle number, and electron number.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Determine the total particle density in the canonical ensemble. \n    (density, Np, Ne, nup, ndn) = get_particle_density(nup, ndn, model_geometry, pht) ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We then specify parameters for our tight binding model and initializes all of the parameters that are in the determinantal part of the trial wavefunction. The model_summary function is used to write a model_summary.toml file, completely specifying the Hamiltonian that will be simulated. Lastly, we can also set an initial particle configuration, if we have one. If an empty array is provided instead, a random configuration will be given at the start of the simulation. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Define the nearest neighbor hopping amplitude, setting the energy scale of the system. \n    t = 1.0\n\n    # Define the next-nearest neighbor hopping amplitude.\n    tp = 0.0\n\n    # Define the third-nearest neighbor hopping amplitude.\n    tpd = 0.0\n\n    # Define the non-interacting tight binding model.\n    tight_binding_model = TightBindingModel(t, tp, tpd)\n\n    # Initialize determinantal variational parameters.\n    determinantal_parameters = DeterminantalParameters(\n        optimize, \n        tight_binding_model, \n        model_geometry, \n        Ne, \n        pht\n    )\n\n    # Write model summary TOML file specifying the Hamiltonian that will be simulated.\n    model_summary(\n        simulation_info, \n        determinantal_parameters, \n        pht, \n        model_geometry, \n        tight_binding_model, \n        U\n    )\n\n    # Initialize the (fermionic) particle configuration.\n    pconfig = Int[]","category":"page"},{"location":"examples/#Initialize-measurements","page":"Examples","title":"Initialize measurements","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, we initialize the mesaurement container, which accumulates the sums of measurements made in a bin. The standard measurements are of the local energy local_energy, double occupancy double_occ, particle confiugurations pconfig, and variational parameters parameters. There is also the option to add additional observables to measure through the initialize_simulation_measurement!and initialize_correlation_measurement! methods. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(\n        N_opt, \n        opt_bin_size, \n        N_sim, \n        sim_bin_size,\n        determinantal_parameters,\n        model_geometry\n    )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here, we have added measurements of the z-component of the spin S_z. After this, the initialize_measurement_directories can now be used used to initialize the various subdirectories in the data folder that the measurements will be written to. For more information, please refer to the Simulation Output Overview page. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Add local Sz measurements.\n    initialize_simulation_measurement!(\n        \"local\",\n        \"spin-z\",\n        measurement_container,\n        model_geometry\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info, \n        measurement_container\n    )","category":"page"},{"location":"examples/#Optimize-the-variational-parameters","page":"Examples","title":"Optimize the variational parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now that we have set-up the VMC simulation, we can begin optimizing the variational parameters. At the start of each bin, we initialize the variational wavefunction. On the first iteration, if no initial configuration is specified, a random one will be generated. In this example, we are neglecting the inclusion of the Jastrow correlation factor here for demonstration purposes but it can be included (see Example 2).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"        # Initialize the determinantal wavefunction.\n        detwf = get_determinantal_wavefunction(\n            tight_binding_model, \n            determinantal_parameters, \n            optimize, \n            Np, \n            nup, \n            ndn, \n            model_geometry, \n            rng,\n            pht,\n            pconfig\n        )  ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This next section of the code equilibrates/thermalizes the system before making measurements. Within the equilibration loop, the structure is fairly simple: the local_fermion_update! function is called to sweep over the particle configuration, attempting to update particle positions. Here, the number of updates performed before measurement is N_equil and opt_bin_size refers to the length of each bin from N_opt_bins.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The quantities n_stab_W and δW are passed to the local_fermion_update! function and controls the stability of the equal-time Green's function matrix W. After n_stab_W fermionic updates, there is a deviation check performed and if it exceeds the threshold δW, then the Green's function is recomputed from scratch.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, the number of measurements that are averaged over per bin is given by opt_bin_size = N_opt ÷ N_opt_bins. The bin-averaged measurements are written to file once bin_size measurements are accumulated using the write_measurements! function.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"        # Iterate over optimization bin length\n        for n in 1:opt_bin_size\n\n            # Iterate over equilibration/thermalization updates\n            for equil in 1:N_equil\n                (acceptance_rate, detwf) = local_fermion_update!(\n                    detwf, \n                    Np, \n                    model_geometry, \n                    n_stab_W,\n                    δW, \n                    rng\n                )\n\n                # Record acceptance rate.\n                metadata[\"acceptance_rate\"] += acceptance_rate\n            end\n\n            # Make measurements, with results being recorded in the measurement container.\n            make_measurements!(\n                measurement_container, \n                detwf, \n                tight_binding_model, \n                determinantal_parameters, \n                optimize,\n                model_geometry, \n                U,\n                Np, \n                pht\n            )\n        end","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"After the last measurement is made, the last particle configuration is recorded globally for use in the initialization of the determinantal wavefunction for the next bin. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"        # Record the last particle configuration used for the start of the next bin.\n        pconfig = detwf.pconfig","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The primary part of this step of the simulation is the optimization of the variational parameters. Since all measurements for this bin have already been accumulated in the measurement_container, the optimize_parameters! function need only apply the Stochastic Reconfiguration (SR) procedure. Once an SR iteration is complete, all measurements are written to file. The write_measurements! method has an optional argument to write the parameter values to file, which we want for the optimization step.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"        # Attempt to update the variational parameters using the Stochastic Reconfiguration procedure. \n        optimize_parameters!( \n            measurement_container,  \n            determinantal_parameters, \n            η, \n            dt, \n            opt_bin_size\n        )  \n\n        # Write measurement for the current bin to file.\n        write_measurements!(\n            \"opt\",\n            bin, \n            opt_bin_size,\n            measurement_container, \n            simulation_info,\n            write_parameters=true\n        )","category":"page"},{"location":"examples/#Simulate-the-system-with-optimized-parameters","page":"Examples","title":"Simulate the system with optimized parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this next section, we continue to sample particle configurations using local_fermion_update! function but without the SR optimization. This is mainly done to ensure proper statistics in calculating observables like the local energy. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Iterate over simulation bins.\n    for bin in 1:N_sim_bins\n\n        # Initialize the determinantal wavefunction.\n        detwf = get_determinantal_wavefunction(\n            tight_binding_model, \n            determinantal_parameters, \n            optimize, \n            Np, \n            nup, \n            ndn, \n            model_geometry, \n            rng,\n            pht,\n            pconfig\n        )  \n\n        # Iterate over optimization bin length\n        for n in 1:sim_bin_size\n\n            # Iterate over equilibration/thermalization updates\n            for equil in 1:N_equil\n                (acceptance_rate, detwf) = local_fermion_update!(\n                    detwf, \n                    Np, \n                    model_geometry, \n                    n_stab_W,\n                    δW, \n                    rng\n                )\n\n                # Record acceptance rate.\n                metadata[\"acceptance_rate\"] += acceptance_rate\n            end\n\n            # Make measurements, with results being recorded in the measurement container.\n            make_measurements!(\n                measurement_container, \n                detwf, \n                tight_binding_model, \n                model_geometry, \n                U,\n                Np, \n                pht\n            )\n        end\n\n        # Record the last particle configuration used for the start of the next bin.\n        pconfig = detwf.pconfig\n\n        # Write measurement for the current bin to file.\n        write_measurements!(\n            \"sim\",\n            bin, \n            sim_bin_size,\n            measurement_container, \n            simulation_info\n        )\n    end","category":"page"},{"location":"examples/#Record-simulation-metadata","page":"Examples","title":"Record simulation metadata","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now that the optimization and simulation of the system are complete, we calculate the total time of the VMC simulation and the average final acceptance rate. Such information is saved to file using the save_simulation_info function. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Record the total VMC time.\n    metadata[\"vmc_time\"] += metadata[\"opt_time\"] + metadata[\"sim_time\"]\n\n    # Normalize acceptance rate.\n    metadata[\"acceptance_rate\"] /=  (N_opt + N_sim)\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)","category":"page"},{"location":"examples/#Post-processing","page":"Examples","title":"Post-processing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"During the simulation, all measurments are written to file in HDF5 format for speed and portability; however, for analyzing data, having CSV files are mush more convenient. Calling the process_measurements function accomoplishes this. It will then up to the user to determine final processing and statistics. It should be noted that the next version of the code will have a convergence detection module and plotting function. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Process all optimization and simulation measurements.\n    process_measurements(\n        measurement_container, \n        simulation_info, \n        determinantal_parameters,\n        model_geometry\n    )","category":"page"},{"location":"examples/#Execute-script","page":"Examples","title":"Execute script","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"VMC simulations are typically run from the command line as jobs on a computing cluster. With this in mind, the following block of code only executes if the Julia script is run from the command line, also reading in additional command line arguments.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(;\n        sID         = parse(Int,     ARGS[1]), \n        L           = parse(Int,     ARGS[2]), \n        U           = parse(Float64, ARGS[3]), \n        nup         = parse(Float64, ARGS[4]), \n        ndn         = parse(Float64, ARGS[5]),\n        pht         = parse(Bool,    ARGS[6]),\n        N_equil     = parse(Int,     ARGS[7]), \n        N_opt       = parse(Int,     ARGS[8]), \n        N_opt_bins  = parse(Int,     ARGS[9]), \n        N_sim       = parse(Int,     ARGS[10]), \n        N_sim_bins  = parse(Int,     ARGS[11])\n    )\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For instance, the command","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"> julia hubbard_chain.jl 1 4 2.0 2 2 false 200 3000 100 6000 100","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"runs a VMC simulation of a N = 4 half-filled 1D Hubbard model with interaction strength U = 20. In the VMC simulation, 200 sweeps through the lattice are be performed to thermalize the system, with 3000 optimization steps and 6000 simulation steps. During the simulation, bin-averaged measurements are written to file 100 times, with each bin of data containing the average of 3000100 = 30 sequential optimization measurements and 6000100 = 60 simulation measurements.","category":"page"},{"location":"examples/#2)-Hubbard-model-on-a-square-lattice-(with-Jastrow-factor)","page":"Examples","title":"2) Hubbard model on a square lattice (with Jastrow factor)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example, we will work through simulating a repulsive Hubbard model on a two dimensional (2D) square lattice. The Hubbard hamiltonian in 2D is given by","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"hatH =  -t sum_sigmalangle i j rangle (hatc^dagger_i sigma hatc^phantom dagger_j sigma + rm Hc)\n+ sum_i hatn_i uparrowhatn_i downarrow\n- mu sum_i sigmahatn_isigma","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"where hatc^dagger_i sigma  (hatc^phantom dagger_i sigma) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_i sigma = hatc^dagger_i sigma hatc^phantom dagger_i sigma is the spin-sigma electron number operator for site i. The nearest-neighbor hopping amplitude is t and mu is the chemical potential. The strength of the repulsive Hubbard interaction is controlled by U0. ","category":"page"},{"location":"examples/#Import-packages-2","page":"Examples","title":"Import packages","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We begin by importing the necessary packages, including the Standard Library packages LinearAlgebra, Random, and Printf for perfroming linear algebra operations, random number generation, and C-style string formatting, respectively.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Linear Algebra\nusing Random\nusing Printf","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, we use LatticeUtilities which exports a suite of types and methods useful for defining arbitrary lattice geometries, and the construction of neighbor tables. Finally, we import the VariationalMC package.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LatticeUtilities\nusing VariationalMC","category":"page"},{"location":"examples/#Specify-simulation-parameters-2","page":"Examples","title":"Specify simulation parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The main body of the simulation is wrapped in a top-level function named run_hubbard_square_simulationthat will take as keyword arguments various model and simulation parameters that we may want to change. The specific meaning of each argument will be discussed in more detail in later sections of the tutorial.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# We define a top-level function for running the VMC simulation.\nfunction run_hubbard_square_simulation(;\n    # KEYWORD ARGUMENTS\n    sID,                    # Simulation ID.\n    L,                      # System size.\n    U,                      # Hubbard interaction.\n    density,                # Electron density.\n    pht,                    # Whether model is particle-hole transformed. \n    N_equil,                # Number of equilibration/thermalization updates.\n    N_opt,                  # Number of optimization steps.\n    N_opt_bins,             # Number of times bin-averaged measurements are written to file during optimization step.\n    N_sim,                  # Number of simulation steps.\n    N_sim_bins,             # Number of times bin-averaged measurements are written to file during simulation step.\n    dt = 0.03,              # Optimization rate.\n    dt_J = 1.0,             # Optional boost in the Jastrow optimization rate.\n    η = 1e-4,               # Optimization stablity factor.\n    n_stab_W = 50,          # Green's function stabilization frequency.\n    δW = 1e-3,              # Maximum allowed error in the Green's function. \n    n_stab_T = 50,          # Jastrow factor stabilization frequency.\n    δT = 1e-3,              # Maximum allowed error in the Jastrow factor.           \n    seed = abs(rand(Int)),  # Seed for random number generator.\n    filepath=\".\"            # Filepath to where data folder will be created.\n)","category":"page"},{"location":"examples/#Initialize-simulation-2","page":"Examples","title":"Initialize simulation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this initial part of the script, we will specify what parameters in the trial wavefunction will be optimized and name our simulation. The NamedTuple called optimized will contain all possible parameters that are automatically initialized in the wavefunction. Setting a flag to true will cause that parameter value (or values) to change during the optimization. We also specify whether the model is particle-hole transformed and is required to be true if pairing symmetery is being added to the wavefunction. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Select which parameters in the variational wavefunction will be optimized.\n    optimize = (\n        # local s-wave pairing\n        Δ_0 = false,\n        # site-dependent s-wave pairing  \n        Δ_spd = false,\n        # local d-wave pairing\n        Δ_d = false,\n        # site-dependent d-wave pairing \n        Δ_dpd = false,          \n        # pairing momentum\n        q_p = false,\n        # spin-x (in-plane magnetization)\n        Δ_sx = false,\n        # spin-z (out-of-plane magnetization)\n        Δ_sz = true,\n        # site-dependent spin density\n        Δ_ssd = false,\n        # (BCS) chemical potential\n        μ = false,\n        # uniform charge density \n        Δ_cdw = false,\n        # site-dependent charge density\n        Δ_csd = false,\n        # density-density Jastrow \n        density_J = true,\n    )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The datafolder is created by initializing an instances of the SimulationInfo type, and then calling the initialize_datafolder function. We also initialize the random number generator that will be used throughout the simulation. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Construct the foldername the data will be written.\n    df_prefix = @sprintf(\"hubbard_square_U%.2f_density%.2f_Lx%d_Ly%d_opt\", U, density, L, L)\n\n    # Append optimized parameter names to the foldername.\n    datafolder_prefix = create_datafolder_prefix(optimize, df_prefix)\n\n    # Initialize an instance of the SimulationInfo type.\n    simulation_info = SimulationInfo(\n        filepath = filepath, \n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    rng = Xoshiro(seed)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In addition, we can calculate the length of each bin by dividing the number of iterations/steps by the number of bins. The bin size is the number of measurements that are averaged over each time data is written during either the optimization or simulation steps.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Calculate optimization bins size.\n    opt_bin_size = div(N_opt, N_opt_bins) \n\n    # Calculate simulation bins size.\n    sim_bin_size = div(N_sim, N_sim_bins)","category":"page"},{"location":"examples/#Initialize-simulation-metadata-2","page":"Examples","title":"Initialize simulation metadata","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this section of the code we record important metadata about the simulation, including initializing the random number generator that will be used throughout the simulation. The important metadata within the simulation will be recorded in the metadata dictionary.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Record simulation metadata.\n    metadata = Dict()\n    metadata[\"N_equil\"] = N_equil\n    metadata[\"N_opt\"] = N_opt\n    metadata[\"N_sim\"] = N_sim\n    metadata[\"N_opt_bins\"] = N_opt_bins\n    metadata[\"N_sim_bins\"] = N_sim_bins\n    metadata[\"δW\"] = δW\n    metadata[\"δT\"] = δT\n    metadata[\"n_stab_W\"] = n_stab_W\n    metadata[\"n_stab_T\"] = n_stab_T\n    metadata[\"dt\"] = dt \n    metadata[\"acceptance_rate\"] = 0.0\n    metadata[\"opt_time\"] = 0.0\n    metadata[\"sim_time\"] = 0.0\n    metadata[\"vmc_time\"] = 0.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In the above, sID stands for simulation ID, which is used to distinguish simulations that would otherwise be identical i.e. to distinguish simulations that use the same parameters and are only different in the random seed used to initialize the simulation. A valid sID is any positive integer greater than zero, and is used when naming the data folder the simulation results will be written to. Specifically, the actual data folder created above will be \"$(filepath)/$(datafolder_prefix)-$(sID)\". Note that if you set sID = 0, then it will instead be assigned smallest previously unused integer value. For instance, suppose the directory \"$(filepath)/$(datafolder_prefix)-1\" already exits. Then if you pass sID = 0 to SimulationInfo, then the simulation ID sID = 2 will be used instead, and a directory \"$(filepath)/$(datafolder_prefix)-2\" will be created.","category":"page"},{"location":"examples/#Initialize-model-2","page":"Examples","title":"Initialize model","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The next part of the script defines the model that we will simulate. First we define the lattice geometry for our model, relying on the LatticeUtilities package to do so. We define a the unit cell and size of our finite lattice using the UnitCell and Lattice types, respectively. Lastly, we define various instances of the Bond type to represent the the nearest-neighbor and next-nearest-neighbor bonds. All of this information regarding the lattice geometry is then stored in an instance of the ModelGeometry type.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Initialize an instance of the UnitCell type.\n    unit_cell = UnitCell(\n        lattice_vecs = [[1.0, 0.0], [0.0, 1.0]],\n        basis_vecs   = [[0.0, 0.0]]\n    )\n\n    # Initialize an instance of the Lattice type.\n    lattice = Lattice(\n        [L, L], \n        [true, true]\n    )\n\n    # Define the nearest neighbor x-bond for a square lattice.\n    bond_x = Bond(\n        orbitals = (1,1), \n        displacement = [1,0]\n    )\n\n    # Define the nearest neighbor y-bond for a square lattice.\n    bond_y = Bond(\n        orbitals = (1,1), \n        displacement = [0,1]\n    )\n\n    # Define the next-nearest neighbor bonds for a square lattice.\n    bond_xy = Bond(\n        orbitals = (1,1), \n        displacement = [1,1]\n    )\n\n    # Define the next-nearest neighbor bonds for a square lattice.\n    bond_yx = Bond(\n        orbitals = (1,1), \n        displacement = [1,-1]\n    )\n\n    # Collect all bond definitions into a single vector.\n    # Note that this has the structure [[nearest],[next-nearest]].\n    bonds = [[bond_x, bond_y], [bond_xy, bond_yx]]\n\n    # Initialize an instance of the ModelGeometry type.\n    model_geometry = ModelGeometry(\n        unit_cell, \n        lattice, \n        bonds\n    )","category":"page"},{"location":"examples/#Initialize-model-parameters-2","page":"Examples","title":"Initialize model parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The next step is to initialize our model parameters, which includes calculating the particle density in the canonical ensemble. The get_particle_density method includes mutliple ways of specifying the particle information. Here, we have chosen to pass the total particle density. The function then computes the corresponding total density, particle number, and electron number.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Determine the total particle density in the canonical ensemble. \n    (density, Np, Ne, nup, ndn) = get_particle_density(density, model_geometry, pht) ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We then specify parameters for our tight binding model and initializes all of the parameters that are in the determinantal part of the trial wavefunction. Parameters for the density-desnity Jastrow factor are initialized seperately. The model_summary function is used to write a model_summary.toml file, completely specifying the Hamiltonian that will be simulated. Lastly, we can also set an initial particle configuration, if we have one. If an empty array is provided instead, a random configuration will be given at the start of the simulation. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Define the nearest neighbor hopping amplitude, setting the energy scale of the system. \n    t = 1.0\n\n    # Define the next-nearest neighbor hopping amplitude.\n    tp = 0.0\n\n    # Define the third-nearest neighbor hopping amplitude.\n    tpd = 0.0\n\n    # Define the non-interacting tight binding model.\n    tight_binding_model = TightBindingModel(t, tp, tpd)\n\n    # Initialize determinantal variational parameters.\n    determinantal_parameters = DeterminantalParameters(\n        optimize, \n        tight_binding_model, \n        model_geometry, \n        Ne, \n        pht\n    )\n\n    # Initialize density-density Jastrow variational parameters.\n    density_J_parameters = JastrowParameters(\n        \"e-den-den\",\n        optimize, \n        model_geometry,\n        rng\n    )\n\n    # Write model summary TOML file specifying the Hamiltonian that will be simulated.\n    model_summary(\n        simulation_info, \n        determinantal_parameters, \n        density_J_parameters, \n        pht, \n        model_geometry, \n        tight_binding_model, \n        U\n    )\n\n    # Initialize the (fermionic) particle configuration.\n    pconfig = Int[]","category":"page"},{"location":"examples/#Initialize-measurements-2","page":"Examples","title":"Initialize measurements","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, we initialize the mesaurement container, which accumulates the sums of measurements made in a bin. The standard measurements are of the local energy local_energy, double occupancy double_occ, particle confiugurations pconfig, and variational parameters parameters. There is also the option to add additional observables to measure through the initialize_simulation_measurement!and initialize_correlation_measurement! methods. Here, we have added density-density correlation measurements.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(\n        N_opt, \n        opt_bin_size, \n        N_sim, \n        sim_bin_size,\n        determinantal_parameters,\n        model_geometry\n    )\n\n    # Add density-density correlation measurements.\n    initialize_correlation_measurement!(\n        \"density\", \n        measurement_container, \n        model_geometry\n    )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The initialize_measurement_directories can now be used used to initialize the various subdirectories in the data folder that the measurements will be written to. For more information, please refer to the Simulation Output Overview page.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info, \n        measurement_container\n    )","category":"page"},{"location":"examples/#Optimize-the-variational-parameters-2","page":"Examples","title":"Optimize the variational parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now that we have set-up the VMC simulation, we can begin optimizing the variational parameters. At the start of each bin, we initialize the variational wavefunction which includes the determinantal part and the density-density Jastrow factor. On the first iteration, if no initial configuration is specified, a random one will be generated.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"        # Initialize the determinantal wavefunction.\n        detwf = get_determinantal_wavefunction(\n            tight_binding_model, \n            determinantal_parameters, \n            optimize, \n            Np, \n            nup, \n            ndn, \n            model_geometry, \n            rng,\n            pht,\n            pconfig\n        )  \n\n        # Initialize density-density Jastrow factor.\n        density_J_factor = get_jastrow_factor(\n            density_J_parameters,\n            detwf,\n            model_geometry,\n            pht\n        )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This next section of the code equilibrates/thermalizes the system before making measurements. Within the equilibration loop, the structure is fairly simple: the local_fermion_update! function is called to sweep over the particle configuration, attempting to update particle positions. Here, the number of updates performed before measurement is N_equil and opt_bin_size refers to the length of each bin from N_opt_bins.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The quantities n_stab_W and δW are passed to the local_fermion_update! function and controls the stability of the equal-time Green's function matrix W. After n_stab_W fermionic updates, there is a deviation check performed and if it exceeds the threshold δW, then the Green's function is recomputed from scratch.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, the number of measurements that are averaged over per bin is given by opt_bin_size = N_opt ÷ N_opt_bins. The bin-averaged measurements are written to file once bin_size measurements are accumulated using the write_measurements! function.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"        # Iterate over optimization bin length\n        for n in 1:opt_bin_size\n\n            # Iterate over equilibration/thermalization updates\n            for equil in 1:N_equil\n                (acceptance_rate, detwf, density_J_factor) = local_fermion_update!(\n                    detwf, \n                    density_J_factor,\n                    density_J_parameters,\n                    Np, \n                    model_geometry, \n                    pht,\n                    n_stab_W,\n                    n_stab_T,\n                    δW, \n                    δT,\n                    rng\n                )\n\n                # Record acceptance rate.\n                metadata[\"acceptance_rate\"] += acceptance_rate\n            end\n\n            # Make measurements, with results being recorded in the measurement container.\n            make_measurements!(\n                measurement_container, \n                detwf, \n                tight_binding_model, \n                determinantal_parameters, \n                density_J_parameters,\n                density_J_factor,\n                optimize,\n                model_geometry, \n                U,\n                Np, \n                pht\n            )\n        end","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"After the last measurement is made, the last particle configuration is recorded globally for use in the initialization of the determinantal wavefunction for the next bin. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"        # Record the last particle configuration used for the start of the next bin.\n        pconfig = detwf.pconfig","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The primary part of this step of the simulation is the optimization of the variational parameters. Since all measurements for this bin have already been accumulated in the measurement_container, the optimize_parameters! function need only apply the Stochastic Reconfiguration (SR) procedure. Once an SR iteration is complete, all measurements are written to file. The write_measurements! method has an optional argument to write the parameter values to file, which we want for the optimization step.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"        # Attempt to update the variational parameters using the Stochastic Reconfiguration procedure. \n        optimize_parameters!( \n            measurement_container,  \n            determinantal_parameters, \n            density_J_parameters,\n            η, \n            dt, \n            dt_J,\n            opt_bin_size\n        )  \n\n        # Write measurement for the current bin to file.\n        write_measurements!(\n            \"opt\",\n            bin, \n            opt_bin_size,\n            measurement_container, \n            simulation_info,\n            write_parameters=true\n        )","category":"page"},{"location":"examples/#Simulate-the-system-with-optimized-parameters-2","page":"Examples","title":"Simulate the system with optimized parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this next section, we continue to sample particle configurations using local_fermion_update! function but without the SR optimization. This is mainly done to ensure proper statistics in calculating observables like the local energy. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Iterate over simulation bins.\n    for bin in 1:N_sim_bins\n\n        # Initialize the determinantal wavefunction.\n        detwf = get_determinantal_wavefunction(\n            tight_binding_model, \n            determinantal_parameters, \n            optimize, \n            Np, \n            nup, \n            ndn, \n            model_geometry, \n            rng,\n            pht,\n            pconfig\n        )  \n\n        # Initialize density-density Jastrow factor.\n        density_J_factor = get_jastrow_factor(\n            density_J_parameters,\n            detwf,\n            model_geometry,\n            pht\n        )\n\n        # Iterate over optimization bin length\n        for n in 1:sim_bin_size\n\n            # Iterate over equilibration/thermalization updates\n            for equil in 1:N_equil\n                (acceptance_rate, detwf, density_J_factor) = local_fermion_update!(\n                    detwf, \n                    density_J_factor,\n                    density_J_parameters,\n                    Np, \n                    model_geometry, \n                    pht,\n                    n_stab_W,\n                    n_stab_T,\n                    δW, \n                    δT,\n                    rng\n                )\n\n                # Record acceptance rate.\n                metadata[\"acceptance_rate\"] += acceptance_rate\n            end\n\n            # Make measurements, with results being recorded in the measurement container.\n            make_measurements!(\n                measurement_container, \n                detwf, \n                tight_binding_model, \n                density_J_parameters,\n                density_J_factor,\n                model_geometry, \n                U,\n                Np, \n                pht\n            )\n        end\n\n        # Record the last particle configuration used for the start of the next bin.\n        pconfig = detwf.pconfig\n\n        # Write measurement for the current bin to file.\n        write_measurements!(\n            \"sim\",\n            bin, \n            sim_bin_size,\n            measurement_container, \n            simulation_info\n        )\n    end","category":"page"},{"location":"examples/#Record-simulation-metadata-2","page":"Examples","title":"Record simulation metadata","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now that the optimization and simulation of the system are complete, we calculate the total time of the VMC simulation and the average final acceptance rate. Such information is saved to file using the msave_simulation_info function. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Record the total VMC time.\n    metadata[\"vmc_time\"] += metadata[\"opt_time\"] + metadata[\"sim_time\"]\n\n    # Normalize acceptance rate.\n    metadata[\"acceptance_rate\"] /=  (N_opt + N_sim)\n\n    # Write simulation summary TOML file.\n    save_simulation_info(simulation_info, metadata)","category":"page"},{"location":"examples/#Post-processing-2","page":"Examples","title":"Post-processing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"During the simulation, all measurments are written to file in HDF5 format for speed and portability; however, for analyzing data, having CSV files are mush more convenient. Calling the process_measurements function accomoplishes this. It will then up to the user to determine final processing and statistics. It should be noted that the next version of the code will have a convergence detection module and plotting function. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Process all optimization and simulation measurements.\n    process_measurements(\n        measurement_container, \n        simulation_info, \n        determinantal_parameters, \n        density_J_parameters,\n        model_geometry\n    )","category":"page"},{"location":"examples/#Execute-script-2","page":"Examples","title":"Execute script","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"VMC simulations are typically run from the command line as jobs on a computing cluster. With this in mind, the following block of code only executes if the Julia script is run from the command line, also reading in additional command line arguments.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Run the simulation.\n    run_hubbard_square_simulation(;\n        sID         = parse(Int,     ARGS[1]), \n        L           = parse(Int,     ARGS[2]), \n        U           = parse(Float64, ARGS[3]), \n        density     = parse(Float64, ARGS[4]), \n        pht         = parse(Bool,    ARGS[5]),\n        N_equil     = parse(Int,     ARGS[6]), \n        N_opt       = parse(Int,     ARGS[7]), \n        N_opt_bins  = parse(Int,     ARGS[8]), \n        N_sim       = parse(Int,     ARGS[9]), \n        N_sim_bins  = parse(Int,     ARGS[10])\n    )\nend\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For instance, the command","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"> julia hubbard_square.jl 1 4 2.0 0.5 1000 3000 100 6000 100","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"runs a VMC simulation of a N = 4 times 4 quarter-filled 2D Hubbard model with interaction strength U = 20. In the VMC simulation, 1000 sweeps through the lattice are be performed to thermalize the system, with 3000 optimization steps and 6000 simulation steps. During the simulation, bin-averaged measurements are written to file 100 times, with each bin of data containing the average of 3000100 = 30 sequential optimization measurements and 6000100 = 60 simulation measurements.","category":"page"},{"location":"examples/#3)-Hubbard-model-on-a-square-lattice-with-MPI-Parallelization","page":"Examples","title":"3) Hubbard model on a square lattice with MPI Parallelization","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Download this example as a Julia script.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example will build on the previous 2) Hubbard model on a square lattice (withh Jastrow factor) example, demonstrating how to add parallelization with MPI using the MPI.jl package. By this we mean that each MPI process will act as independent walker, running it's own independent VMC simulation.","category":"page"},{"location":"examples/#Import-packages-3","page":"Examples","title":"Import packages","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We now need to import the MPI.jl package as well. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using LinearAlgebra\nusing Random\nusing Printf\n\n# Import MPI\nusing MPI\n\nusing LatticeUtilities\nusing VariationalMC ","category":"page"},{"location":"examples/#Specify-simulation-parameters-3","page":"Examples","title":"Specify simulation parameters","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we have introduced the comm argument to the run_simulation function, which is a type exported by the MPI.jl package to facilitate communication and synchronization between the different MPI processes.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# We define a top-level function for running the VMC simulation.\nfunction run_hubbard_square_simulation(\n    comm::MPI.Comm;         # MPI communicator.\n    # KEYWORD ARGUMENTS\n    sID,                    # Simulation ID.\n    L,                      # System size.\n    U,                      # Hubbard interaction.\n    density,                # Electron density.\n    pht,                    # Whether model is particle-hole transformed. \n    N_equil,                # Number of equilibration/thermalization updates.\n    N_opt,                  # Number of optimization steps.\n    N_opt_bins,             # Number of times bin-averaged measurements are written to file during optimization step.\n    N_sim,                  # Number of simulation steps.\n    N_sim_bins,             # Number of times bin-averaged measurements are written to file during simulation step.\n    dt = 0.03,              # Optimization rate.\n    dt_J = 1.0,             # Optional boost in the Jastrow optimization rate.\n    η = 1e-4,               # Optimization stablity factor.\n    n_stab_W = 50,          # Green's function stabilization frequency.\n    δW = 1e-3,              # Maximum allowed error in the Green's function. \n    n_stab_T = 50,          # Jastrow factor stabilization frequency.\n    δT = 1e-3,              # Maximum allowed error in the Jastrow factor.           \n    seed = abs(rand(Int)),  # Seed for random number generator.\n    filepath=\".\"            # Filepath to where data folder will be created.\n)","category":"page"},{"location":"examples/#Initialize-simulation-3","page":"Examples","title":"Initialize simulation","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"While choosing which variational parameters to optimize is the same as before, Now when initializing the SimulationInfo type, we also need to include the MPI process ID pID, which can be retrieved using the MPI.Comm_rank function.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We also the initialize_datafolder function such that it takes the comm as the first argument. This ensures that all the MPI processes remained synchronized, and none try proceeding beyond this point until the data folder has been initialized.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # Construct the foldername the data will be written.\n    df_prefix = @sprintf(\"hubbard_square_U%.2f_density%.2f_Lx%d_Ly%d_opt\", U, density, L, L)\n\n    # Append optimized parameter names to the foldername.\n    datafolder_prefix = create_datafolder_prefix(optimize, df_prefix)\n\n    # Get the MPI comm rank, which fixes the processor ID (pID).\n    pID = MPI.Comm_rank(comm)\n\n    # Initialize an instance of the SimulationInfo type.\n    # This type tracks of where the data is written, as well as \n    # which version of Julia and VariationalMC are used in the script. \n    simulation_info = SimulationInfo(\n        filepath = filepath, \n        datafolder_prefix = datafolder_prefix,\n        sID = sID,\n        pID = pID\n    )\n\n    # Initialize the directory the data will be written.\n    initialize_datafolder(comm, simulation_info)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"There are no changes to the simulation script in terms of initializing the simulation metadata, model, model parameters, and measurements. There are also no changes in performing the optimization and simulation steps. Please refer to Example 2 for details. ","category":"page"},{"location":"examples/#Execute-script-3","page":"Examples","title":"Execute script","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we first need to initialize MPI using the MPI.Init command. Then, we need to make sure to pass the comm = MPI.COMM_WORLD to the run_simulation function. At the very end of simulation it is good practice to run the MPI.Finalize() function even though it is typically not strictly required.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Only excute if the script is run directly from the command line.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n    # Initialize MPI.\n    MPI.Init()\n\n    # Initialize the MPI communicator.\n    comm = MPI.COMM_WORLD\n\n    # Run the simulation.\n    run_hubbard_square_simulation(\n        comm; \n        sID        = parse(Int,     ARGS[1]), \n        L          = parse(Int,     ARGS[2]), \n        U          = parse(Float64, ARGS[3]),\n        density    = parse(Float64, ARGS[4]),\n        pht        = parse(Bool,    ARGS[5]),\n        N_equil    = parse(Int,     ARGS[6]), \n        N_opt      = parse(Int,     ARGS[7]), \n        N_opt_bins = parse(Int,     ARGS[8]), \n        N_sim      = parse(Int,     ARGS[9]),\n        N_sim_bins = parse(Int,     ARGS[10])\n    )\n\n    # Finalize MPI.\n    MPI.Finalize()\nend","category":"page"},{"location":"simulation_output/#Simulation-Output-Overview","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"In this section we define and provide an overview of the output generated by a VMC simulation performed using the VariationalMC.jl package.","category":"page"},{"location":"simulation_output/#Output-Data-Folder-Structure","page":"Simulation Output Overview","title":"Output Data Folder Structure","text":"","category":"section"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"Each simulation performed with VariationalMC.jl will generate a directory with a user defined name that all the output of the simulation will be written to, which will be referred to as datafolder here.  Inside the datafolder a set of files and folders resembling the structure outlined below will be found:","category":"page"},{"location":"simulation_output/","page":"Simulation Output Overview","title":"Simulation Output Overview","text":"[datafolder]: \nmodel_summary.toml: A TOML file that describes qunatities that were used in the simulation.\n[correlation]: Directory containing all files pertaining to correlation measurements made during the simulation.\nopt_bin_measurements.h5: HDF5 file containing binned measurements made during the optimization step.\nsim_bin_measurements.h5: HDF5 file containing binned measurements made during the simulation step.\nden-den_correlation_stats.csv\nspn-spn_correlation_states.csv\n[optimization]: Directory containing all file pertaining to measurements used during the optimization step.\nopt_bin_measurements.h5: HDF5 file containing binned measurements made during the optimization step.\ne-den-den_jastrow_parameters.csv\nparameter_cdw_stats.csv\nparameter_csd_stats.csv\nparameter_ssd_stats.csv\nparameter_sx_stats.csv\nparameter_msz_stats.csv\nparameter_mu_stats.csv\n[simulation]: Directory containing all files pertaining to measured observables made during the simulation. \nopt_bin_measurements.h5: HDF5 file containing binned measurements made during the optimization step.\nsim_bin_measurements.h5: HDF5 file containing binned measurements made during the simulation step.\nbin_measurements.h5: merged HDF5 file containing all binned measurments made during the simulation.\ndouble_occ_stats.csv\nglobal_density_stats.csv\nlocal_energy_stats.csv\npconfig_stats.csv","category":"page"},{"location":"#VariationalMC.jl","page":"Home","title":"VariationalMC.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for VariationalMC.jl. This package impelments the variational Monte Carlo (VMC) method for Hubbard and electron-phonon interactions (coming soon).","category":"page"},{"location":"","page":"Home","title":"Home","text":"This code is currently the experimental stage of development. Use with caution. ","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The development of this code was supported by the U.S. Department of Energy, Office of Science, Office of Workforce Development for Teachers and Scientists, Office of Science Graduate Student Research (SCGSR) program. The SCGSR program is administered by the Oak Ridge Institute for Science and Education (ORISE) for the DOE. ORISE is managed by ORAU under contract number DE-SC0014664.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the VariationalMC.jl, simply open the Julia REPL and run the commands","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add VariationalMC","category":"page"},{"location":"","page":"Home","title":"Home","text":"or equivalently via Pkg do","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"VariationalMC\")","category":"page"},{"location":"#Notable-External-Package-Dependencies","page":"Home","title":"Notable External Package Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This section reviews some notable package dependencies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"LatticeUtilties.jl: Package that is used to represent arbitrary lattice geometries.\nOrderedCollections.jl: Package that implements associative containers that preserve the order of insertion.\nJLD2.jl: Package used to write data to binary files in an HDF5 compatible format. \nCSV.jl: Package used for handling delimited text data.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For questions and comments regarding this package, please email Andy Tanjaroon Ly at atanjaro@vols.utk.edu.","category":"page"}]
}
