var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#ModelGeometry-Type-and-Methods","page":"API","title":"ModelGeometry Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ModelGeometry","category":"page"},{"location":"api/#VariationalMC.ModelGeometry","page":"API","title":"VariationalMC.ModelGeometry","text":"ModelGeometry( unit_cell::UnitCell, \n               lattice::Lattice, \n               bond::Vector{Vector{Any}} )\n\nA type defining model geometry.\n\n\n\n\n\n","category":"type"},{"location":"api/#Internal-Methods","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.x\nVariationalMC.y\nVariationalMC.d\nVariationalMC.reduce_index_2d\nVariationalMC.reduce_index_1d\nVariationalMC.max_dist","category":"page"},{"location":"api/#VariationalMC.x","page":"API","title":"VariationalMC.x","text":"x( i::Int, model_geometry::ModelGeometry )\n\nConvenience function for obtaining the x-coordinate of a lattice site given a  lattice spindex.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.y","page":"API","title":"VariationalMC.y","text":"y( i::Int, model_geometry::ModelGeometry )\n\nConvenience function for obtaining the y-coordinate of a lattice site given a  lattice spindex.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.d","page":"API","title":"VariationalMC.d","text":"d( p1::Int, p2::Int, model_geometry::ModelGeometry )\n\nGiven lattice indices i and j, returns the distances between those 2 points, accounting  for the latticed edges with different boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.reduce_index_2d","page":"API","title":"VariationalMC.reduce_index_2d","text":"reduce_index_2d( i::Int, j::Int, model_geometry::ModelGeometry )\n\nReduces the indices of 2 lattice sites (i,j) to irreducible indices (0,k), where k is an integer.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.reduce_index_1d","page":"API","title":"VariationalMC.reduce_index_1d","text":"reduce_index_1d( i::Int, j::Int, model_geometry::ModelGeometry )\n\nReduces the indices of 2 lattice sites (i,j) to irreducible indices (0,k), where k is an integer.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.max_dist","page":"API","title":"VariationalMC.max_dist","text":"max_dist( N::Int, L::Int )\n\nObtains the maximum irreducible index given the total number of sites N and extent of the lattice L.\n\n\n\n\n\n","category":"function"},{"location":"api/#Parameters-Types-and-Methods","page":"API","title":"Parameters Types and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"TightBindingModel\nSpinModel\nDeterminantalParameters\nJastrowParameters","category":"page"},{"location":"api/#VariationalMC.TightBindingModel","page":"API","title":"VariationalMC.TightBindingModel","text":"TightBindingModel( t₀::Float64,\n                   t₁::Float64 )\n\nA type defining a non-interacting tight binding model.\n\n\n\n\n\n","category":"type"},{"location":"api/#VariationalMC.SpinModel","page":"API","title":"VariationalMC.SpinModel","text":"SpinModel( J₁::Float64,\n           J₂::Float64,\n           J₃::Float64 )\n\nA type defining a spin model.\n\n\n\n\n\n","category":"type"},{"location":"api/#VariationalMC.DeterminantalParameters","page":"API","title":"VariationalMC.DeterminantalParameters","text":"DeterminantalParameters( pars::Vector{AbstractString}, \n                         vals::Vector{AbstractFloat}, \n                         num_detpars::Int )\n\nA type defining a set of variational parameters for the determinantal wavefunction.\n\n\n\n\n\n","category":"type"},{"location":"api/#VariationalMC.JastrowParameters","page":"API","title":"VariationalMC.JastrowParameters","text":"JastrowParameters( jastrow_type::String,\n                   jpar_map::OrderedDict{Any, Any},\n                   num_jpars::Int,\n                   num_jpar_opts::Int )\n\nA type defining quantities related to Jastrow variational parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#Internal-Methods-2","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.collect_parameters\nVariationalMC.update_parameters!\nVariationalMC.readin_parameters","category":"page"},{"location":"api/#VariationalMC.collect_parameters","page":"API","title":"VariationalMC.collect_parameters","text":"collect_parameters( determinantal_parameters::DeterminantalParameters, \n                    jastrow_parameters::JastrowParameters )::Vector{AbstractFloat}\n\nConcatenates all values of determinantal and Jastrow parameters into a single vector.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.update_parameters!","page":"API","title":"VariationalMC.update_parameters!","text":"update_parameters!( new_vpars::AbstractVector, \n                    determinantal_parameters::DeterminantalParameters )::Nothing\n\nUpdates variational (determinantal) parameters after Stochastic Reconfiguration.\n\n\n\n\n\nupdate_parameters!( new_vpars::AbstractVector, \n                    determinantal_parameters::DeterminantalParameters, \n                    jastrow_parameters::JastrowParameters )::Nothing\n\nUpdates variational (determinantal) parameters after Stochastic Reconfiguration.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.readin_parameters","page":"API","title":"VariationalMC.readin_parameters","text":"readin_parameters( filename::String )\n\nParses TOML file containing initial variational parameters. \n\nfilename::String: name of parameter summary file in TOML format.\n\n\n\n\n\n","category":"function"},{"location":"api/#Hamiltonian-Methods","page":"API","title":"Hamiltonian Methods","text":"","category":"section"},{"location":"api/#Internal-Methods-3","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.build_auxiliary_hamiltonian\nVariationalMC.build_tight_binding_hamiltonian\nVariationalMC.build_variational_hamiltonian\nVariationalMC.add_pairing_symmetry!\nVariationalMC.add_spin_order!\nVariationalMC.add_charge_order!\nVariationalMC.add_chemical_potential!\nVariationalMC.diagonalize\nVariationalMC.is_openshell\nVariationalMC.get_variational_matrices\nVariationalMC.get_tb_chem_pot","category":"page"},{"location":"api/#VariationalMC.build_auxiliary_hamiltonian","page":"API","title":"VariationalMC.build_auxiliary_hamiltonian","text":"build_auxiliary_hamiltonian( tight_binding_model::TightBindingModel, \n                             determinantal_parameters::DeterminantalParameters, \n                             pht::Bool )\n\nConstructs a complete Hamiltonian matrix by combining the non-interacting matrix with matrices of variational terms.\n\ntight_binding_model::TightBindingModel: parameters for a non-interacting tight-binding model.\ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hol transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.build_tight_binding_hamiltonian","page":"API","title":"VariationalMC.build_tight_binding_hamiltonian","text":"build_tight_binding_hamiltonian( tight_binding_model::TightBindingModel,\n                                 model_geometry::ModelGeometry,\n                                 pht::Bool )\n\nConstructs a 2N by 2N Hamiltonian matrix where N is the number of lattice sites,  given tight binding parameters t, and t'.\n\ntight_binding_model::TightBindingModel: parameters for a non-interacting tight-binding model. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed. \n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.build_variational_hamiltonian","page":"API","title":"VariationalMC.build_variational_hamiltonian","text":"build_variational_hamiltonian( determinantal_parameters::DeterminantalParameters, \n                               optimize::NamedTuple, \n                               pht::Bool )\n\nConstructs 2N by 2N matrices to be added to the non-interacting tight binding Hamiltonian for each variational parameter,  where N is the number of lattice sites. Returns a vector of the sum of matrices and a vector of individual matrix terms.\n\ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\npht::Bool: whether model is particle-hole transformed. \n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.add_pairing_symmetry!","page":"API","title":"VariationalMC.add_pairing_symmetry!","text":"add_pairing_symmetry!( symmetry::String, \n                       determinantal_parameters::DeterminantalParameters, \n                       optimize::NamedTuple, \n                       H_vpars::AbstractMatrix{<:Complex}, \n                       V, \n                       model_geometry::ModelGeometry, \n                       pht::Bool )::Nothing\n\nAdds a pairing symmetry term to the auxiliary Hamiltonian. \n\nsymmetry::String: type of pairing symmetry: \"s\", \"d\", \"sPDW\", or \"dPDW\ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\nH_vpars::Vector{Any}: vector of variational Hamiltonian matrices.\nV::Vector{Any}: vector of variational operators.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities. \npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.add_spin_order!","page":"API","title":"VariationalMC.add_spin_order!","text":"add_spin_order!( order::String, \n                 determinantal_parameters::DeterminantalParameters, \n                 optimize::NamedTuple, \n                 H_vpars::Vector{Any}, \n                 V::Vector{Any}, \n                 model_geometry::ModelGeometry, \n                 pht::Bool )::Nothing\n\nAdds a spin order term to the auxiliary Hamiltonian. \n\norder::String: type of spin order: \"spin-x\", \"spin-z\", or \"site-dependent\"\ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\nH_vpars::Vector{Any}: vector of variational Hamiltonian matrices.\nV::Vector{Any}: vector of variational operators.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model if particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.add_charge_order!","page":"API","title":"VariationalMC.add_charge_order!","text":"add_charge_order!( order::String, \n                   determinantal_parameters::DeterminantalParameters, \n                   optimize::NamedTuple, \n                   H_vpars::Vector{Any}, \n                   V::Vector{Any}, \n                   model_geometry::ModelGeometry, \n                   pht::Bool )::Nothing\n\nAdds a charge order term to the auxiliary Hamiltonian.\n\norder::String: type of spin order: \"density wave\" or \"site-dependent\"\ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\nH_vpars::Vector{Any}: vector of variational Hamiltonian matrices.\nV::Vector{Any}: vector of variational operators.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model if particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.add_chemical_potential!","page":"API","title":"VariationalMC.add_chemical_potential!","text":"add_chemical_potential!( determinantal_parameters::DeterminantalParameters, \n                         optimize::NamedTuple, \n                         H_vpars::Vector{Any}, \n                         V::Vector{Any}, \n                         model_geometry::ModelGeometry, \n                         pht::Bool )::Nothing\n\nAdds a chemical potential term to the auxiliary Hamiltonian.\n\ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\nH_vpars::Vector{Any}: vector of variational Hamiltonian matrices.\nV::Vector{Any}: vector of variational operators.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model if particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.diagonalize","page":"API","title":"VariationalMC.diagonalize","text":"diagonalize( H::Matrix{ComplexF64} )::Tuple{Vector{Float64}, Matrix{ComplexF64}}\n\nReturns all eigenenergies and all eigenstates of the mean-field Hamiltonian,  the latter being stored in the columns of a matrix. Convention: H(diag) = U⁺HU.\n\nH::AbstractMatrix{<:Complex}: auxiliary Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.is_openshell","page":"API","title":"VariationalMC.is_openshell","text":"is_openshell( ε::Vector{Float64},  \n              Ne::Int )::Bool\n\nChecks whether a energy configuration is open shell.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_variational_matrices","page":"API","title":"VariationalMC.get_variational_matrices","text":"get_variational_matrices( V::Vector{Any}, \n                          U_int::Matrix{ComplexF64}, \n                          ε::Vector{Float64}, \n                          model_geometry::ModelGeometry )::Vector{Any}\n\nReturns variational parameter matrices Aₖ from the corresponding Vₖ. Computes  Qₖ = (U⁺VₖU)(ην) / (εη - ε_ν), for η > Nₚ and ν ≤ Nₚ and is 0 otherwise (η and ν run from 1 to 2N).\n\nV::Vector{Any}: vector of variational operators. \nU_int::Matrix{ComplexF64}: matrix which diagonalizes the auxiliary Hamiltonian.\nε::Vector{Float64}: initial energies.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_tb_chem_pot","page":"API","title":"VariationalMC.get_tb_chem_pot","text":"get_tb_chem_pot( Ne::Int64, \n                 tight_binding_model::TightBindingModel, \n                 model_geometry::ModelGeometry )::Float64\n\nFor a tight-binding model that has not been particle-hole transformed, returns the   chemical potential.\n\nNe::Int64: total number of electrons.\ntight_binding_model::TightBindingModel: parameters for a non-interacting tight-binding model.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#DeterminantalWavefunction-Type-and-Methods","page":"API","title":"DeterminantalWavefunction Type and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DeterminantalWavefunction\nget_determinantal_wavefunction","category":"page"},{"location":"api/#VariationalMC.DeterminantalWavefunction","page":"API","title":"VariationalMC.DeterminantalWavefunction","text":"DeterminantalWavefunction( W::Matrix{ComplexF64}, \n                           D::Matrix{ComplexF64}, \n                           M::Matrix{ComplexF64}\n                           U_int::Matrix{ComplexF64}, \n                           A::Vector{Any}, \n                           ε::Vector{Float64}, \n                           pconfig::Vector{Int64} )\n\nA type defining quantities related to a determinantal wavefunction.\n\n\n\n\n\n","category":"type"},{"location":"api/#VariationalMC.get_determinantal_wavefunction","page":"API","title":"VariationalMC.get_determinantal_wavefunction","text":"get_determinantal_wavefunction( tight_binding_model::TightBindingModel, \n                                determinantal_parameters::DeterminantalParameters, \n                                Ne::Int64, \n                                nup::Int64, \n                                ndn::Int64,\n                                model_geometry::ModelGeometry, \n                                rng::Xoshiro)::DeterminantalWavefunction\n\nConstructs a variational wavefunction based on parameters given by the tight binding model and determinantal parameters.  Returns an instances of the DeterminantalWavefunction type. If no particle configuration is specified, a random configuration will be generated.                            \n\ntight_binding_model::TightBindingModel: parameters for a non-interacting tight-binding model. \ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\noptimize::NamedTuple: field of optimization flags.\nNe::Int: total number of electrons.\nnup::Int: number of spin-up electrons.\nndn::Int: number of spin-down electrons.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nrng::Xoshiro: random number.\npconfig::Union{Nothing, Vector{Int}}=nothing: current particle configuration. \n\n\n\n\n\n","category":"function"},{"location":"api/#Jastrow-Types-and-Methods","page":"API","title":"Jastrow Types and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JastrowFactor\nget_jastrow_factor","category":"page"},{"location":"api/#VariationalMC.JastrowFactor","page":"API","title":"VariationalMC.JastrowFactor","text":"JastrowFactor( Tvec_f::Vector{Float64}, \n               Tvec_b::Vector{Float64} )\n\nA type defining quantities related to a Jastrow factor.\n\n\n\n\n\n","category":"type"},{"location":"api/#VariationalMC.get_jastrow_factor","page":"API","title":"VariationalMC.get_jastrow_factor","text":"get_jastrow_factor( jastrow_parameters::JastrowParameters, \n                    detwf::DeterminantalWavefunction, \n                    model_geometry::ModelGeometry, \n                    pht::Bool )::JastrowFactor\n\nConstructs specified Jastrow factor and returns a instance of the JastrowFactor type. \n\njastrow_parameters::JastrowParameters: current set of Jastrow parameters. \ndetwf::DeterminantalWavefunction: current variational wavefunction. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed. \n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Methods-4","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.get_fermionic_Tvec\nVariationalMC.update_fermionic_Tvec!\nVariationalMC.get_fermionic_jastrow_ratio\nVariationalMC.map_jastrow_parameters","category":"page"},{"location":"api/#VariationalMC.get_fermionic_Tvec","page":"API","title":"VariationalMC.get_fermionic_Tvec","text":"get_fermionic_Tvec( jastrow_parameters::JastrowParameters,  \n                    detwf::DeterminantalWavefunction, \n                    pht::Bool, \n                    model_geometry::ModelGeometry )::Vector{Float64}\n\nReturns T vector with entries of the form Tᵢ = ∑ⱼ vᵢⱼnᵢ(x) where vᵢⱼ are the  associated Jastrow peseudopotentials and nᵢ(x) is the total electron occupation.\n\njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\ndetwf::DeterminantalWavefunction: current variational wavefunction. \npht::Bool: whether model is particle-hole transformed.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.update_fermionic_Tvec!","page":"API","title":"VariationalMC.update_fermionic_Tvec!","text":"update_fermionic_Tvec!( markov_move::MarkovMove, \n                        spin::Int64, \n                        jastrow_parameters::JastrowParameters,\n                        jastrow_factor::JastrowFactor, \n                        model_geometry::ModelGeometry, \n                        n_stab_T::Int64, \n                        δT::Float64, \n                        pht::Bool )::Nothing\n\nUpdates elements Tᵢ of the T vector after an accepted Metropolis step.\n\nmarkov_move::MarkovMove: quantities related to a Markov move. \nspin::Int64: spin of the current particle. \njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\njastrow::Jastrow: current Jastrow factor.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nn_stab_T::Int64: frequency of T vector stabilization setps.\nδT::Float64: deviation threshold for the T vector.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_fermionic_jastrow_ratio","page":"API","title":"VariationalMC.get_fermionic_jastrow_ratio","text":"get_fermionic_jastrow_ratio( markov_move::MarkovMove, \n                             jastrow_parameters::JastrowParameters\n                             jastrow_factor::JastrowFactor, \n                             pht::Bool, \n                             spin::Int64, \n                             model_geometry::ModelGeometry )\n\nCalculates ratio J(x₂)/J(x₁) = exp[-s(Tₗ - Tₖ) + vₗₗ - vₗₖ ] of Jastrow factors for particle configurations  which differ by a single particle hopping from site 'k' (configuration 'x₁') to site 'l' (configuration 'x₂') using the corresponding T vectors Tₖ and Tₗ, rsepctively.  \n\nmarkov_move::MarkovMove: quantities related to a Markov move.  \njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor: current Jastrow factor.\npht::Bool: whether model is particle-hole transformed.\nspin::Int64: spin of the current particle.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\nget_fermionic_jastrow_ratio( k::Int64, \n                             l::Int64, \n                             jastrow_parameters::JastrowParameters,\n                             jastrow_factor::JastrowFactor, \n                             pht::Bool, \n                             spin::Int64, \n                             model_geometry::ModelGeometry )\n\nCalculates ratio J(x₂)/J(x₁) = exp[-s(Tₗ - Tₖ) + vₗₗ - vₗₖ ] of Jastrow factors for particle configurations  which differ by a single particle hopping from site 'k' (configuration 'x₁') to site 'l' (configuration 'x₂') using the corresponding T vectors Tₖ and Tₗ, rsepctively.  \n\nk::Int64: initial site of the current particle. \nl::Int64: final site of the current particle. \njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor: current Jastrow factor.\npht::Bool: whether model is particle-hole transformed.\nspin::Int64: spin of the current particle.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.map_jastrow_parameters","page":"API","title":"VariationalMC.map_jastrow_parameters","text":"map_jastrow_parameters( model_geometry::ModelGeometry, \n                        rng::Xoshiro )::OrderedDict{Any, Any}\n\nGenerates a dictionary of irreducible indices k which reference a tuple consisting of a vector of lattice index  pairs (i,j) which generate k, and Jastrow parameters vᵢⱼ. The parameter corresponding to the  largest k is automatically initialized to 0, all others are randomly initialized.\n\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.  \nrng::Xoshiro: random number generator.\n\n\n\n\n\nmap_jastrow_parameters( model_geometry::ModelGeometry, \n                        vpar_dict::Dict{Symbol, Any} )::OrderedDict{Any, Any}\n\nGenerates a dictionary of irreducible indices k which reference a tuple consisting of a vector of lattice index  pairs (i,j) which generate k, and Jastrow parameters vᵢⱼ. The parameter corresponding to the  largest k is automatically initialized to 0, all others are read in from file.\n\nmodel_geometry::ModelGeometry: contains unit cell and lattice qunatities. \nvpar_dict::Dict{Symbol, Any}: dictionary of variational parameters from file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Markov-Methods","page":"API","title":"Markov Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"local_fermion_update!","category":"page"},{"location":"api/#VariationalMC.local_fermion_update!","page":"API","title":"VariationalMC.local_fermion_update!","text":"local_fermion_update!( detwf::DeterminantalWavefunction,\n                       Ne::Int, \n                       model_geometry::ModelGeometry, \n                       pht::Bool, \n                       δW::Float64, \n                       δT::Float64, \n                       rng::Xoshiro )\n\nPerforms a local update to the electronic sector, with a certain number of equilibration steps.\n\ndetwf::DeterminantalWavefunction: current determinantal variational wavefunction.\nNe::Int: total number of electrons.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nn_stab_W: frequency of Green's function stabilization steps.\nδW::Float64: error threshold for the Green's function.\nrng::Xoshiro: random number generator.\n\n\n\n\n\nlocal_fermion_update!( detwf::DeterminantalWavefunction, \n                       jastrow_factor::JastrowFactor, \n                       jastrow_parameters::JastrowParameters,\n                       Ne::Int, \n                       model_geometry::ModelGeometry, \n                       pht::Bool, \n                       δW::Float64, \n                       δT::Float64, \n                       rng::Xoshiro )\n\nPerforms a local update to the electronic sector, with a certain number of equilibration steps.\n\ndetwf::DeterminantalWavefunction: current determinantal variational wavefunction.\njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\njastrow::Jastrow: current Jastrow factor.\nNe::Int: total number of electrons.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nn_stab_W: frequency of Green's function stabilization steps.\nn_stab_T: frequency of T vector stabilization steps.\nδW::Float64: error threshold for the Green's function.\nrng::Xoshiro: random number generator.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Methods-5","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.metropolis_step","category":"page"},{"location":"api/#VariationalMC.metropolis_step","page":"API","title":"VariationalMC.metropolis_step","text":"metropolis_step( detwf::DeterminantalWavefunction, \n                 Ne::Int, \n                 n_stab_W::Int64, \n                 δW::Float64,\n                 model_geometry::ModelGeometry, \n                 rng::Xoshiro )::String\n\nProposes a particle to hop to a random neighboring site, and then accepts or rejects  using the Metropolis algorithm. \n\ndetwf::DeterminantalWavefunction: current determinantal variational wavefunction.\nNe::Int: total number of electrons.\nn_stab_W::Int64: frequency of Green's function stabilization steps.\nδW::Float64: error threshold for the Green's function.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nrng::Xoshiro: random number generator.\n\n\n\n\n\nmetropolis_step( detwf::DeterminantalWavefunction, \n                 jastrow_factor::JastrowFactor, \n                 jastrow_parameters::JastrowParameters,\n                 Ne::Int, \n                 n_stab_W::Int64, \n                 n_stab_T::Int64, \n                 δW::Float64, \n                 δT::Float64, \n                 model_geometry::ModelGeometry, \n                 pht::Bool, \n                 rng::Xoshiro )::String\n\nProposes a particle to hop to a random neighboring site, and then accepts or rejects using the Metropolis algorithm. \n\ndetwf::DeterminantalWavefunction: current variational wavefunction.\njastrow_factor::JastrowFactor: current Jastrow factor.\njastrow_parameters::JastrowParameters: current set of Jastrow parameters.\nNe::Int: total number of electrons.\nn_stab_W: frequency of Green's function stabilization steps.\nn_stab_T: frequency of T vector stabilization steps.\nδW::Float64: error threshold for the Green's function.\nδT::Float64: error threshold for the T vector.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\nrng::Xoshiro: random number generator.\n\n\n\n\n\n","category":"function"},{"location":"api/#ParticleConfiguration-Types-and-Methods","page":"API","title":"ParticleConfiguration Types and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"get_particle_numbers\nget_particle_density","category":"page"},{"location":"api/#VariationalMC.get_particle_numbers","page":"API","title":"VariationalMC.get_particle_numbers","text":"get_particle_numbers( density::Float64 )::NTuple{4, Int64}\n\nGiven a particle density, returns the total number of particles Np, number of spin-up particles Npu,  number of spin-down particles Npd, and total number of electrons Ne.\n\ndensity::Float64: desired electronic density.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_particle_density","page":"API","title":"VariationalMC.get_particle_density","text":"get_particle_density( nup::Int64, \n                      ndn::Int64 )::Tuple{Float64, Int64, Int64}\n\nGiven the number of spin-up electrons nup, and number of spin-down electrons ndn, returns  the particle density, total number of particles Np, and the total number of electrons Ne.\n\nnup::Int: number of spin-up electrons.\nndn::Int: number of spin-down electrons.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Types-and-Methods","page":"API","title":"Internal Types and Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.MarkovMove\nVariationalMC.propose_random_move\nVariationalMC.hop!\nVariationalMC.generate_initial_fermion_configuration\nVariationalMC.get_onsite_fermion_occupation\nVariationalMC.get_spindex_type\nVariationalMC.get_index_from_spindex\nVariationalMC.get_spindices_from_index\nVariationalMC.get_linked_spindex","category":"page"},{"location":"api/#VariationalMC.MarkovMove","page":"API","title":"VariationalMC.MarkovMove","text":"MarkovMove( particle::Int, \n            k::Int, \n            l::Int, \n            possible::Bool )\n\nA type defining a Markov move.\n\n\n\n\n\n","category":"type"},{"location":"api/#VariationalMC.propose_random_move","page":"API","title":"VariationalMC.propose_random_move","text":"propose_random_move( Ne::Int64, \n                     pconfig::Vector{Int64}, \n                     model_geometry::ModelGeometry, \n                     rng::Xoshiro )::MarkovMove\n\nProposes randomly hopping or exchanging a particle from some intial site 'k' to a neighboring site 'l'  and returns an instance of the MarkovMove type. \n\nNe::Int64: total number of electrons.  \npconfig::Vector{Int64}: current particle configuration. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities. \nrng::Xoshiro: random number generator.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.hop!","page":"API","title":"VariationalMC.hop!","text":"hop!( markov_move::MarkovMove, \n      pconfig::Vector{Int} )::Nothing\n\nIf proposed hopping move is accepted, updates the particle positions.\n\nmarkov_move::MarkovMove: quantities related to a Markov move.  \npconfig::Vector{Int}: current particle configuration. \n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.generate_initial_fermion_configuration","page":"API","title":"VariationalMC.generate_initial_fermion_configuration","text":"generate_initial_fermion_configuration( nup::Int64, \n                                        ndn::Int64, \n                                        model_geometry::ModelGeometry, \n                                        rng::Xoshiro )::Vector{Int64}\n\nGenerates a random initial configuration of spin-up and spin-down fermions. The first N elements correspond  to spin-up and the last N correspond to spin-down. Occupation is denoted by a positive integer corresponding  to that particle's creation operator label. \n\nnup::Int64: number of spin-up electrons.\nndn::Int64: number of spin-down electrons.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nrng::Xoshiro: random number generator.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_onsite_fermion_occupation","page":"API","title":"VariationalMC.get_onsite_fermion_occupation","text":"get_onsite_fermion_occupation( site::Int, \n                               pconfig::Vector{Int} )::Tuple{Int64, Int64, Int64}\n\nReturns the number of spin-up and spin-down electrons occupying a real lattice site 'i'.  \n\nsite::Int: lattice site. \npconfig::Vector{Int}: current particle configuration.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_spindex_type","page":"API","title":"VariationalMC.get_spindex_type","text":"get_spindex_type( spindex::Int, \n                  model_geometry::ModelGeometry )::Int\n\nReturns the spin species at a given spindex.\n\nspindex::Int: spin index.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_index_from_spindex","page":"API","title":"VariationalMC.get_index_from_spindex","text":"get_index_from_spindex( spindex::Int, \n                        model_geometry::ModelGeometry )::Int\n\nReturns the lattice site i for a given spindex.\n\nspindex::Int: spin index.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_spindices_from_index","page":"API","title":"VariationalMC.get_spindices_from_index","text":"get_spindices_from_index( index::Int, \n                          model_geometry::ModelGeometry )::Tuple{Int64, Int64}\n\nReturns spin-up and spin-down indices from a given site index.\n\nindex::Int: lattice site index.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_linked_spindex","page":"API","title":"VariationalMC.get_linked_spindex","text":"get_linked_spindex( i::Int, \n                    N::Int )::Int\n\nReturns an index in the spin-down sector, given an index in the spin-up sector.\n\ni::Int: lattice index in the spin-up sector.\nN::Int: total number of lattice sites. \n\n\n\n\n\n","category":"function"},{"location":"api/#Optimizer-Methods","page":"API","title":"Optimizer Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"stochastic_reconfiguration!","category":"page"},{"location":"api/#VariationalMC.stochastic_reconfiguration!","page":"API","title":"VariationalMC.stochastic_reconfiguration!","text":"stochastic_reconfiguration!( measurement_container::NamedTuple, \n                             determinantal_parameters::DeterminantalParameters, \n                             η::Float64, \n                             dt::Float64, \n                             bin::Int,\n                             bin_size::Int64 )::Nothing\n\nUpdates variational parameters through stochastic optimization.\n\nmeasurement_container::NamedTuple: container where measurements are stored. \ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\nη::Float64: optimization stabilization factor. \ndt::Float64: optimization rate. \nbin::Int: current bin number.\nbin_size::Int64: length of the current bin. \n\n\n\n\n\nstochastic_reconfiguration!( measurement_container::NamedTuple, \n                             determinantal_parameters::DeterminantalParameters, \n                             jastrow_parameters::JastrowParameters, \n                             η::Float64, \n                             dt::Float64, \n                             bin::Int, \n                             bin_size::Int64 )::Nothing\n\nUpdates variational parameters through stochastic optimization.\n\nmeasurement_container::NamedTuple: container where measurements are stored. \ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\njastrow_parameters::JastrowParameters: set of Jastrow variational parameters. \nη::Float64: optimization stabilization factor. \ndt::Float64: optimization rate. \nbin::Int: current bin number.\nbin_size::Int64: length of the current bin. \n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Methods-6","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.get_Δk\nVariationalMC.get_covariance_matrix\nVariationalMC.get_force_vector","category":"page"},{"location":"api/#VariationalMC.get_Δk","page":"API","title":"VariationalMC.get_Δk","text":"get_Δk( optimize::NamedTuple, \n        determinantal_parameters::DeterminantalParameters, \n        detwf::DeterminantalWavefunction, \n        model_geometry::ModelGeometry, \n        Ne::Int )::Vector{Float64}\n\nCalculates the local logarithmic derivative Δₖ(x) = ∂lnΨ(x)/∂αₖ, with respect to the kth variational parameter αₖ, in the determinantal part of the wavefunction. Returns a vector of derivatives.\n\noptimize::NamedTuple: field of optimization flags.\ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\ndetwf::DeterminantalWavefunction: current variational wavefunction. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int: total number of electrons. \n\n\n\n\n\nget_Δk( optimize::NamedTuple, \n        determinantal_parameters::DeterminantalParameters, \n        jastrow_parameters::JastrowParameters,\n        detwf::DeterminantalWavefunction, \n        model_geometry::ModelGeometry, \n        Ne::Int,\n        pht::Bool )::Vector{Float64}\n\nCalculates the local logarithmic derivative Δₖ(x) = ∂lnΨ(x)/∂αₖ, with respect to the kth variational parameter αₖ, in the determinantal part of the wavefunction. Returns a vector of derivatives.\n\noptimize::NamedTuple: field of optimization flags.\ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters. \ndetwf::DeterminantalWavefunction: current variational wavefunction. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int: total number of electrons. \npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_covariance_matrix","page":"API","title":"VariationalMC.get_covariance_matrix","text":"get_covariance_matrix( measurement_container::NamedTuple, \n                       opt_bin_size::Int64 )\n\nCalculates the covariance matrix S, for Stochastic Reconfiguration, with elements Skk' = <ΔkΔk'> - <Δk><Δk'>.\n\nmeasurement_container::NamedTuple: container where measurements are stored. \nopt_bin_size::Int64: length of the current bin.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_force_vector","page":"API","title":"VariationalMC.get_force_vector","text":"get_force_vector( measurement_container::NamedTuple, \n                  opt_bin_size::Int64 )\n\nGenerates the force vector f, for Stochastic Reconfiguration with elements  fk = <Δk><H> - <Δ_kH>.\n\nmeasurement_container::NamedTuple: container where measurements are stored. \nopt_bin_size::Int64: length of the current bin.\n\n\n\n\n\n","category":"function"},{"location":"api/#Measurement-Methods","page":"API","title":"Measurement Methods","text":"","category":"section"},{"location":"api/#Intitialize-Measurements","page":"API","title":"Intitialize Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"initialize_measurement_container\ninitialize_measurement_directories","category":"page"},{"location":"api/#VariationalMC.initialize_measurement_container","page":"API","title":"VariationalMC.initialize_measurement_container","text":"initialize_measurement_container( N_opts::Int, \n                                  opt_bin_size::Int, \n                                  N_bins::Int, \n                                  bin_size::Int,\n                                  determinantal_parameters::DeterminantalParameters, \n                                  model_geometry::ModelGeometry )::NamedTuple\n\nInitializes a set of dictionaries containing generic arrays for storing measurements. Each dictionary in the container has [keys => values] of the form: [observable name => (local value(s), current bin value(s))] \n\nN_opts::Int: number of optimization updates.\nopt_bin_size::Int: length of an optimization bin.\nN_bins::Int: number of simulation bins.\nbin_size::Int: length of a simulation bin. \ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\ninitialize_measurement_container( N_opts::Int, \n                                  opt_bin_size::Int, \n                                  N_bins::Int, \n                                  bin_size::Int,\n                                  determinantal_parameters::DeterminantalParameters, \n                                  jastrow_parameters::JastrowParameters,\n                                  model_geometry::ModelGeometry )::NamedTuple\n\nInitializes a set of dictionaries containing generic arrays for storing measurements. Each dictionary in the container has [keys => values] of the form: [observable name => (local value(s), current bin value(s))] \n\nN_opts::Int: number of optimization updates.\nopt_bin_size::Int: length of an optimization bin.\nN_bins::Int: number of simulation bins.\nbin_size::Int: length of a simulation bin. \ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\njastrow_parameters::JastrowParameters: set of Jastrow variational parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.initialize_measurement_directories","page":"API","title":"VariationalMC.initialize_measurement_directories","text":"initialize_measurement_directories( simulation_info::SimulationInfo, \n                                    measurement_container::NamedTuple )::Nothing\n\nCreates file directories and for storing measurements. \n\nsimulation_info::SimulationInfo: contains datafolder information.\nmeasurement_container::NamedTuple: container where measurements are contained.\n\n\n\n\n\n","category":"function"},{"location":"api/#Scalar-Measurements","page":"API","title":"Scalar Measurements","text":"","category":"section"},{"location":"api/#Internal-Methods-7","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.get_local_energy\nVariationalMC.get_local_kinetic_energy\nVariationalMC.get_local_hubbard_energy\nVariationalMC.get_double_occ\nVariationalMC.get_n","category":"page"},{"location":"api/#VariationalMC.get_local_energy","page":"API","title":"VariationalMC.get_local_energy","text":"get_local_energy( detwf::DeterminantalWavefunction, \n                  tight_binding_model::TightBindingModel, \n                  model_geometry::ModelGeometry, \n                  Ne::Int64, \n                  pht::Bool )::Float64\n\nCalculates the local variational energy per site for a Hubbard model (without a Jastrow factor).\n\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ntight_binding_model::TightBindingModel: parameters for a non-interacting tight-binding model. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: total number of electrons.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nget_local_energy( detwf::DeterminantalWavefunction, \n                  tight_binding_model::TightBindingModel,\n                  jastrow_parameters::JastrowParameters, \n                  jastrow_factor::JastrowParameters,\n                  model_geometry::ModelGeometry\n                  Ne::Int64,\n                  pht::Bool )::Nothing\n\nCalculates the local variational energy per site for a Hubbard model.\n\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ntight_binding_model::TightBindingModel: parameters for a non-interacting tight-binding model. \njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor: current Jastrow factor.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: total number of electrons.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_local_kinetic_energy","page":"API","title":"VariationalMC.get_local_kinetic_energy","text":"get_local_kinetic_energy( detwf::DeterminantalWavefunction, \n                          tight_binding_model::TightBindingModel, \n                          model_geometry::ModelGeometry, \n                          Ne::Int64\n                          pht::Bool )::Float64\n\nCalculates the local electronic kinetic energy. \n\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ntight_binding_model::TightBindingModel: parameters for a non-interacting tight-binding model. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: total number of electrons.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nget_local_kinetic_energy( detwf::DeterminantalWavefunction, \n                          tight_binding_model::TightBindingModel, \n                          jastrow_parameters::JastrowParameters,\n                          jastrow_factor::JastrowFactor, \n                          model_geometry::ModelGeometry, \n                          Ne::Int64,\n                          pht::Bool )::Float64\n\nCalculates the local electronic kinetic energy. \n\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ntight_binding_model::TightBindingModel: parameters for a non-interacting tight-binding model. \njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor: current Jastrow factor.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: total number of electrons.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_local_hubbard_energy","page":"API","title":"VariationalMC.get_local_hubbard_energy","text":"get_local_hubbard_energy( U::Float64, \n                          detwf::DeterminantalWavefunction, \n                          model_geometry::ModelGeometry, \n                          pht::Bool )::Float64\n\nCalculates the energy due to onsite Hubbard repulsion.  \n\nU::Float64: Hubbard repulsion.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_double_occ","page":"API","title":"VariationalMC.get_double_occ","text":"get_double_occ( detwf::DeterminantalParameters, \n                model_geometry::ModelGeometry, \n                pht::Bool )::Float64\n\nCalculates the double occupancy. \n\ndetwf::DeterminantalWavefunction: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_n","page":"API","title":"VariationalMC.get_n","text":"get_n( detwf::DeterminantalWavefunction, \n       model_geometry::ModelGeometry )::Float64\n\nCalculate the local density.\n\ndetwf::DeterminantalWavefunction: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#Optimization-Measurements","page":"API","title":"Optimization Measurements","text":"","category":"section"},{"location":"api/#Internal-Methods-8","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.measure_parameters!\nVariationalMC.measure_Δk!\nVariationalMC.measure_ΔkΔkp!\nVariationalMC.measure_ΔkE!","category":"page"},{"location":"api/#VariationalMC.measure_parameters!","page":"API","title":"VariationalMC.measure_parameters!","text":"measure_parameters!( measurement_container::NamedTuple, \n                     determinantal_parameters::DeterminantalParameters )::Nothing\n\nMeasures all variational (determinantal) parameters and then writes them to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndeterminantal_parameters::DeterminantalParameters: current set of determinantal variational parameters.\n\n\n\n\n\nmeasure_parameters!( measurement_container::NamedTuple, \n                     determinantal_parameters::DeterminantalParameters, \n                     jastrow_parameters::JastrowParameters )::Nothing\n\nMeasures all initialized variational parameters and then writes them to the measurment container.  The first 'p' are determinantal parameters and the rest are Jastrow parameters. \n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndeterminantal_parameters::DeterminantalParameters: current set of determinantal variational parameters.\njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.measure_Δk!","page":"API","title":"VariationalMC.measure_Δk!","text":"measure_Δk!( measurement_container::NamedTuple, \n             detwf::DeterminantalWavefunction, \n             determinantal_parameters::DeterminantalParameters, \n             model_geometry::ModelGeometry, \n             Ne::Int64 )::Nothing\n\nMeasures logarithmic derivatives for all variational parameters and then writes them to the measurement container. The first 'p' are derivatives of determinantal parameters.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ndeterminantal_parameters::DeterminantalParameters: current set of determinantal variational parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: total number of electrons.\n\n\n\n\n\nmeasure_Δk!( measurement_container::NamedTuple, \n             detwf::DeterminantalWavefunction, \n             determinantal_parameters::DeterminantalParameters, \n             jastrow_parameters::JastrowParameters, \n             model_geometry::ModelGeometry, \n             Ne::Int64, \n             pht::Bool )::Nothing\n\nMeasures logarithmic derivatives for all variational parameters and then writes  them to the measurement container. The first 'p' are derivatives of determinantal  parameters and the rest are derivatives of Jastrow parameters. \n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ndeterminantal_parameters::DeterminantalParameters: current set of determinantal variational parameters.\njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: total number of electrons.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.measure_ΔkΔkp!","page":"API","title":"VariationalMC.measure_ΔkΔkp!","text":"measure_ΔkΔkp!( measurement_container::NamedTuple, \n                detwf::DeterminantalWavefunction, \n                determinantal_parameters::DeterminantalParameters,\n                model_geometry::ModelGeometry,\n                Ne::Int64 )::Nothing\n\nMeasures the product of variational derivatives with other variational derivatives and then writes them to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ndeterminantal_parameters::DeterminantalParameters: current variational determinantal parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: total number of electrons.\n\n\n\n\n\nmeasure_ΔkΔkp!( measurement_container::NamedTuple, \n                detwf::DeterminantalWavefunction, \n                determinantal_parameters::DeterminantalParameters, \n                jastrow_parameters::JastrowParameters, \n                model_geometry::ModelGeometry, \n                Ne::Int64, \n                pht::Bool )::Nothing\n\nMeasures the product of variational derivatives with other variational derivatives and then writes them to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ndeterminantal_parameters::DeterminantalParameters: current set of determinantal variational parameters.\njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: total number of electrons.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.measure_ΔkE!","page":"API","title":"VariationalMC.measure_ΔkE!","text":"measure_ΔkE!( measurement_container::NamedTuple, \n              detwf::DeterminantalWavefunction, \n              tight_binding_model::TightBindingModel, \n              determinantal_parameters::DeterminantalParameters, \n              model_geometry::ModelGeometry, \n              Ne::Int64, \n              pht::Bool )::Nothing\n\nMeasures the product of variational derivatives with the local energy and then writes them to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction. \ntight_binding_model::TightBindingModel: parameter for a non-interacting tight-binding model.\ndeterminantal_parameters::DeterminantalParameters: current set of determinantal variational parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: total number of electrons.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nmeasure_ΔkE!( measurement_container::NamedTuple, \n              detwf::DeterminantalWavefunction, \n              tight_binding_model::TightBindingModel, \n              determinantal_parameters::DeterminantalParameters, \n              jastrow_parameters::JastrowParameters, \n              model_geometry::ModelGeometry, \n              Ne::Int64, \n              pht::Bool )::Nothing\n\nMeasures the product of variational derivatives with the local energy and then  writes them to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ntight_binding_model::TightBindingModel: parameters for a non-interacting tight-binding model.\ndeterminantal_parameters::DeterminantalParameters: current set of determinantal variational parameters.\njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: total number of electrons.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation-Measurements","page":"API","title":"Simulation Measurements","text":"","category":"section"},{"location":"api/#Internal-Methods-9","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.measure_local_energy!\nVariationalMC.measure_double_occ!\nVariationalMC.measure_n!","category":"page"},{"location":"api/#VariationalMC.measure_local_energy!","page":"API","title":"VariationalMC.measure_local_energy!","text":"measure_local_energy!( measurement_container::NamedTuple, \n                       detwf::DeterminantalWavefunction, \n                       tight_binding_model::TightBindingModel, \n                       model_geometry::ModelGeometry,\n                       Ne::Int64,\n                       pht::Bool )::Nothing\n\nMeasures the total local energy for a Hubbard model and writes to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ntight_binding_model::TightBindingModel: parameters for a non-interacting tight-binding model. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: total number of electrons.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\nmeasure_local_energy!( measurement_container::NamedTuple, \n                       detwf::DeterminantalWavefunction, \n                       tight_binding_model::TightBindingModel, \n                       jastrow_parameters::JastrowParameters,\n                       jastrow_factor::JastrowFactor, \n                       model_geometry::ModelGeometry,\n                       Ne::Int64, \n                       pht::Bool )::Nothing\n\nMeasures the total local energy for a Hubbard model and writes to the measurement container.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\ntight_binding_model::TightBindingModel: parameters for a non-interacting tight-binding model. \njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor: current Jastrow factor. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: total number of electrons.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.measure_double_occ!","page":"API","title":"VariationalMC.measure_double_occ!","text":"measure_double_occ!( measurement_container::NamedTuple, \n                     detwf::DeterminantalWavefunction, \n                     model_geometry::ModelGeometry, \n                     pht::Bool )::Nothing\n\nMeasure the average double occupancy ⟨D⟩ = N⁻¹ ∑ᵢ ⟨nᵢ↑nᵢ↓⟩.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\npht::Bool: whether model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.measure_n!","page":"API","title":"VariationalMC.measure_n!","text":"measure_n!( measurement_container::NamedTuple, \n            detwf::DeterminantalWavefunction, \n            model_geometry::ModelGeometry )::Nothing\n\nMeasure the local particle density ⟨n⟩.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#Correlation-Measurements","page":"API","title":"Correlation Measurements","text":"","category":"section"},{"location":"api/#Internal-Methods-10","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.measure_density_correlation!\nVariationalMC.measure_spin_correlation!\nVariationalMC.get_site_dependent_n\nVariationalMC.get_site_dependent_s","category":"page"},{"location":"api/#VariationalMC.measure_density_correlation!","page":"API","title":"VariationalMC.measure_density_correlation!","text":"measure_density_correlation!( measurement_container::NameTuple,\n                              detwf::DeterminantalWavefunction,\n                              model_geometry::ModelGeometry )::Nothing\n\nMeasures the equal-time density-density correlation function.\n\nmeasurement_container::NamedTuple: container where measurements are stroed.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.measure_spin_correlation!","page":"API","title":"VariationalMC.measure_spin_correlation!","text":"measure_spin_correlation!( measurement_container::NamedTuple,\n                           detwf::DeterminantalWavefunction,\n                           model_geometry::ModelGeometry )::Nothing\n\nMeasures the equal-time spin-spin correlation function. \n\nmeasurement_container::NamedTuple: container where measurements are stroed.\ndetwf::DeterminantalWavefunction: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_site_dependent_n","page":"API","title":"VariationalMC.get_site_dependent_n","text":"get_site_dependent_n( detwf::DeterminantalWavefunction, \n                      model_geometry::ModelGeometry )::Vector{Int}\n\nCalculates the density on each lattice site.\n\ndetwf::DeterminantalWavefunction: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#VariationalMC.get_site_dependent_s","page":"API","title":"VariationalMC.get_site_dependent_s","text":"get_site_dependent_s( detwf::DeterminantalParameters\n                      model_geometry::ModelGeometry )::Vector{Int}\n\nCalculates the spin on each lattice site.\n\ndetwf::DeterminantalParameters: current variational wavefunction.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\n\n\n\n\n\n","category":"function"},{"location":"api/#Make-Measurements","page":"API","title":"Make Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"make_measurements!","category":"page"},{"location":"api/#VariationalMC.make_measurements!","page":"API","title":"VariationalMC.make_measurements!","text":"make_measurements!( measurement_container::NamedTuple, \n                    detwf::DeterminantalWavefunction, \n                    tight_binding_model::TightBindingModel,\n                    determinantal_parameters::DeterminantalParameters,\n                    optimize::NamedTuple, \n                    model_geometry::ModelGeometry, \n                    Ne::Int64, \n                    pht::Bool )::Nothing\n\nMeasures global, optimization, and simulation observables.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current determinantal wavefunction.\ntight_binding_model::TightBindingModel: non-interacting tight-binding model. \ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: number of electrons.\npht::Bool: whether or not model is particle-hole transformed.\n\n\n\n\n\nmake_measurements!( measurement_container::NamedTuple, \n                    detwf::DeterminantalWavefunction, \n                    tight_binding_model::TightBindingModel,\n                    determinantal_parameters::DeterminantalParameters,\n                    jastrow_parameters::JastrowParameters,\n                    jastrow_factor::JastrowFactor, \n                    model_geometry::ModelGeometry, \n                    Ne::Int64, \n                    pht::Bool )::Nothing\n\nMeasures global, optimization, and simulation observables.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current determinantal wavefunction.\ntight_binding_model::TightBindingModel: non-interacting tight-binding model. \ndeterminantal_parameters::DeterminantalParameters: set of determinantal variational parameters.\njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor: current Jastrow factor. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: number of electrons.\npht::Bool: whether or not model is particle-hole transformed.\n\n\n\n\n\nmake_measurements!( measurement_container::NamedTuple, \n                    detwf::DeterminantalWavefunction, \n                    tight_binding_model::TightBindingModel, \n                    model_geometry::ModelGeometry, \n                    Ne::Int64, \n                    pht::Bool )\n\nMeasures simulation observables.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current determinantal wavefunction.\ntight_binding_model::TightBindingModel: non-interacting tight-binding model. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: number of electrons.\npht::Bool: whether or not model is particle-hoel transformed.\n\n\n\n\n\nmake_measurements!( measurement_container::NamedTuple, \n                    detwf::DeterminantalWavefunction, \n                    tight_binding_model::TightBindingModel, \n                    jastrow_parameters::JastrowParameters,\n                    jastrow_factor::JastrowFactor, \n                    model_geometry::ModelGeometry, \n                    Ne::Int64, \n                    pht::Bool )\n\nMeasures simulation observables.\n\nmeasurement_container::NamedTuple: container where measurements are stored.\ndetwf::DeterminantalWavefunction: current determinantal wavefunction.\ntight_binding_model::TightBindingModel: non-interacting tight-binding model. \njastrow_parameters::JastrowParameters: current set of Jastrow variational parameters.\njastrow_factor::JastrowFactor: current Jastrow factor. \nmodel_geometry::ModelGeometry: contains unit cell and lattice quantities.\nNe::Int64: number of electrons.\npht::Bool: whether or not model is particle-hole transformed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Internal-Methods-11","page":"API","title":"Internal Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"VariationalMC.reset_measurements!","category":"page"},{"location":"api/#VariationalMC.reset_measurements!","page":"API","title":"VariationalMC.reset_measurements!","text":"reset_measurements!( measurements::Dict{String, Any} )\n\nResets value of a dictionary (measurement container) to zero.\n\n\n\n\n\n","category":"function"},{"location":"api/#Write-Measurements","page":"API","title":"Write Measurements","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"write_measurements!","category":"page"},{"location":"api/#VariationalMC.write_measurements!","page":"API","title":"VariationalMC.write_measurements!","text":"write_measurements!( bin::Int, \n                     step::Int, \n                     measurement_container::NamedTuple, \n                     simulation_info::SimulationInfo )::Nothing\n\nWrites optimization and simulation measurements in the current bin to file.  Files created are in HDF5 format. \n\nbin::Int: current bin.\nstep::Int: current step within the bin.\nmeasurement_container::NamedTuple: container where measurements are stored.\nsimulation_info: contains datafolder names.\n\n\n\n\n\nwrite_measurements!( measurement_container::NamedTuple, \n                     energy_bin::Vector{Any}, \n                     dblocc_bin::Vector{Any}, \n                     param_bin::Vector{Any} )::Nothing\n\nDEBUG version of the write_measurements!() method. Will write individuallly binned energies, double occupancy, and parameters to specified vectors.  \n\nmeasurement_container::NamedTuple: container where measurements are stored.\nenergy_bin::Vector{Float64}: externally specified vector for storing energy measurements.\ndblocc_bin::Vector{Float64}: externally specified vector for storing double occupancy measurements.\nparam_bin::Vector{Any}: externally specified vector for storing parameter measurements.\n\n\n\n\n\n","category":"function"},{"location":"api/#Process-Measurements","page":"API","title":"Process Measurements","text":"","category":"section"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Here are a few example usage cases. ","category":"page"},{"location":"usage/#Hubbard-chain","page":"Usage","title":"Hubbard chain","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"In the first example, we will work though simulating the repulsive Hubbard model  on a 1D chain at half-filling. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The Hubbard Hamiltonian for a 1D chain is given by ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"hatH = -t sum_i sigma (hatc^dagger_i+1sigmahatc^phantom dagger_i sigma + rm hc)\n+ U sum_i hatn_i uparrowhatn_i downarrow - mu sum_i sigma hatn_i sigma","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"where hatc^dagger_i sigma  (hatc^phantom dagger_i sigma) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_i sigma = hatc^dagger_i sigma hatc^phantom dagger_i sigma is the spin-sigma electron number operator for site i. In the above Hamiltonian t is the nearest neighbor hopping integral and U  0 controls the strength of the on-site Hubbard repulsion. Lastly, we consider the case that the system is half-filled and particle-hole symmetric, which occurs when when the chemical potential is zero, mu = 00.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Suppose we want to simulate a half-filled Hubbard chain (mu = 00) of length L=4 with U=10 with a Neél   antiferromagnet trial wavefunction and a density-density Jastrow factor.. This is accomplished by running the script associated with this example using the command","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"> julia hubbard_chain.jl 1 4 1.0 2 2 300 1000 2000 100","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Below you will find a heavily commented script that includes details on what each part of the code is doing.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Import the required packages\nusing LinearAlgebra\nusing Random\nusing Printf\n\nusing LatticeUtilities\nusing VariationalMC\n\n# We define a top-level function for running the VMC simulation.\n# Note that the arguments of this function correspond to the command line\n# arguments used to run this script.\nfunction run_hubbard_chain_simulation(\n    sID, \n    L,\n    U,\n    nup,\n    ndn,\n    N_equil,\n    N_opts,\n    N_updates,\n    N_bins; \n    filepath=\".\"\n)\n    # DEBUG flag which writes information to terminal during the simulation.\n    # For efficeincy, this should always be turned off. \n    debug = false\n\n    # Select which parameters in the variational wavefunction will be optimized.\n    optimize = (\n        # local s-wave pairing\n        Δ_0 = false,\n        # spin-x (in-plane magnetization)\n        Δ_sx = false,\n        # spin-z (out-of-plane magnetization)\n        Δ_sz = true,\n        # (BCS) chemical potential\n        μ = false,\n        # uniform charge density \n        Δ_cdw = false\n    )\n\n    # Specify whether the model will be particle-hole transformed.\n    # Note that this is required if adding pair fields to the wavefunction.\n    pht = false\n\n    # Construct the foldername the data will be written.\n    df_prefix = @sprintf \"hubbard_chain_U%.2f_nup%.2f_ndn%.2f_L%d_opt\" U, nup, ndn, L\n\n    # Append optimized parameter names to the foldername.\n    datafolder_prefix = create_datafolder_prefix(optimize, df_prefix)\n\n    # Initialize an instance of the SimulationInfo type.\n    # This type tracks of where the data is written, as well as \n    # which version of Julia and VariationalMC are used in the script. \n    simulation_info = SimulationInfo(\n        filepath = filepath, \n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    # We seed this function with a randomly sampled number for the\n    # global random number generator.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the optimization rate for the VMC simulation.\n    dt = 0.03     \n\n    # Set the stabilization factor used in parameter optimization. \n    η = 1e-4    \n\n    # Set the frequency in Monte Carlo steps with which the equal-time Green's function\n    # matrix will be recomputed using the numerical stabilization procedure.\n    n_stab_W = 50\n\n    # Specify the maximum allowed error in the equal-time Green's function matrix that\n    # is corrected by numerical stabilization.\n    δW = 1e-3\n\n    # Specify the optimization bin size.\n    # The optimization bin size if the number of measurments that are averaged over each time data\n    # is written to file during optimization. \n    opt_bin_size = 3000\n\n    # Calculate the simulation bin size.\n    # The bin size is the number of measurements that are averaged over each time data is written\n    # to file during the simulation.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    # This is a sort of \"notebook\" for tracking extraneous parameters during the VMC simulation.\n    metadata = Dict()\n    metadata[\"N_equil\"] = N_equil\n    metadata[\"N_opts\"] = N_opts\n    metadata[\"N_updates\"] = N_updates\n    metadata[\"N_bins\"] = N_bins\n    metadata[\"seed\"] = seed\n    metadata[\"pht\"] = true\n    metadata[\"δW\"] = δW\n    metadata[\"dt\"] = dt \n    metadata[\"opt_flags\"] = optimize \n    metadata[\"avg_acceptance_rate\"] = 0.0\n    metadata[\"opt_time\"] = 0.0\n    metadata[\"sim_time\"] = 0.0\n    metadata[\"total_time\"] = 0.0\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the UnitCell type.\n    # This struct defines the UnitCell.\n    unit_cell = UnitCell(\n        lattice_vecs = [[1.0]],\n        basis_vecs   = [[0.0]]\n    )\n\n    # Initialize an instance of the Lattice type.\n    # The struct describes the size of the finite periodic lattice to be simulated.\n    # Note that the current version of LatticeUtilities requires \n    # periodic boundary conditions be used.\n    lattice = Lattice(\n        [L], \n        [true]\n    )\n\n    # Define the nearest neighbor bond for a 1D chain.\n    bond_x = Bond(\n        orbitals = (1,1), \n        displacement = [1]\n    )\n\n    # Define the next-nearest neighbor bonds for a 1D chain.\n    bond_xp = Bond(\n        orbitals = (1,1), \n        displacement = [2]\n    )\n\n    # Collect all bond definitions into a single vector.\n    # Note that this has the structure [[nearest],[next-nearest]].\n    bonds = [[bond_x], [bond_xp]]\n    \n    # Initialize an instance of the ModelGeometry type.\n    # This type helps keep track of all the relevant features of the lattice\n    # geometry being simulated, including the defintion of the unit cell,\n    # the size of the finite periodic lattice, and all the relevant\n    # bond defintions that may arise in the model.\n    model_geometry = ModelGeometry(\n        unit_cell, \n        lattice, \n        bonds\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(\n        N_opts, \n        opt_bin_size, \n        N_bins, \n        bin_size,\n        determinantal_parameters,\n        model_geometry\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info, \n        measurement_container\n    )\n\n    ############################\n    ### SET-UP VMC SIMULATION ##\n    ############################\n\n    # Determine the total particle density in the canonical ensemble. \n    (density, Np, Ne) = get_particle_density(nup, ndn)\n\n    # Define the nearest neighbor hopping amplitude, setting the energy scale of the system. \n    t = 1.0;\n\n    # Define the next-nearest neighbor hopping amplitude.\n    tp = 0.0;\n\n    # Define the non-interacting tight binding model.\n    tight_binding_model = TightBindingModel(t, tp)\n\n    # Specify the minimum value of each variational parameter.\n    # Note that this is done to avoid open shell issues.\n    minabs_vpar = 1e-4;\n\n    # Initialize determinantal variational parameters.\n    determinantal_parameters = DeterminantalParameters(\n        optimize, \n        tight_binding_model, \n        model_geometry, \n        minabs_vpar, \n        Ne, \n        pht\n    )\n\n    # Initialize the (fermionic) particle configuration cache.\n    pconfig_cache = nothing\n\n    ###########################\n    ### OPTIMIZATION UPDATES ##\n    ###########################\n\n    # Record start time for optimization. \n    opt_start_time = time()\n\n    # Iterate over optimization updates.\n    for bin in 1:N_opts\n\n        # Initialize the determinantal wavefunction.\n        detwf = get_determinantal_wavefunction(\n            tight_binding_model, \n            determinantal_parameters, \n            optimize, \n            Ne, \n            nup, \n            ndn, \n            model_geometry, \n            rng,\n            pconfig_cache\n        )   \n\n        # Iterate over equilibration/thermalization updates.\n        for step in 1:N_equil \n\n            # Attempt to update the fermionic particle configuration.\n            (acceptance_rate, detwf) = local_fermion_update!(\n                detwf, \n                Ne, \n                model_geometry, \n                n_stab_W,\n                δW, \n                rng\n            )\n\n            # Record the acceptance rate for attempted local updates of the particle configuration.                                                         \n            metadata[\"avg_acceptance_rate\"] += acceptance_rate;\n        end\n\n        # Iterate over the number of optimization bins.\n        for n in 1:opt_bin_size\n\n            # Attempt to update the fermionic particle configuration.\n            (acceptance_rate, detwf) = local_fermion_update!(\n                detwf, \n                Ne, \n                model_geometry, \n                n_stab_W,\n                δW, \n                rng\n            ) \n                                                                                                        \n            # Record the acceptance rate for attempted local updates of the particle configuration                                                       \n            metadata[\"avg_acceptance_rate\"] += acceptance_rate;\n            \n            # Make measurements, with results being recorded in the measurement container. \n            make_measurements!(\n                measurement_container, \n                detwf, \n                tight_binding_model, \n                determinantal_parameters, \n                model_geometry, \n                Ne, \n                pht\n            )\n\n            # Write measurement for the current bin to file.\n            write_measurements!(\n                bin, \n                n, \n                measurement_container, \n                simulation_info\n            )\n        end\n\n        # Record the last particle configuration used in the current bin. \n        pconfig_cache = detwf.pconfig\n\n        # Process the measurement results, calculating error bars for all measurements. \n        # process_measurements(simulation_info, opt_bin_size)\n\n        # Attempt an update to the variational parameters using the Stochastic Reconfiguration procedure. \n        stochastic_reconfiguration!( \n            measurement_container,  \n            determinantal_parameters, \n            η, \n            dt, \n            bin, \n            opt_bin_size\n        )  \n    end     \n\n    # Record end time for optimization.\n    opt_end_time = time()\n\n    # Calculate the total time for optimization. \n    metadata[\"opt_time\"] += opt_end_time - opt_start_time\n\n    #########################\n    ### SIMULATION UPDATES ##\n    #########################\n\n    # Record start time for the simulation.\n    sim_start_time = time()\n\n    # Iterate over simulation updates.\n    for bin in 1:N_updates\n\n        # Initialize the determinantal wavefunction.\n        detwf = get_determinantal_wavefunction(\n            tight_binding_model, \n            determinantal_parameters, \n            optimize, \n            Ne, \n            nup, \n            ndn, \n            model_geometry, \n            rng,\n            pconfig_cache\n        )   \n\n        # Iterate over equilibration/thermalization updates.\n        for step in 1:N_equil \n\n            # Attempt to update the fermionic particle configuration.\n            (acceptance_rate, detwf) = local_fermion_update!(\n                detwf, \n                Ne, \n                model_geometry, \n                n_stab_W,\n                δW, \n                rng\n            )\n\n            # Record the acceptance rate for attempted local updates of the particle configuration.                                                         \n            metadata[\"avg_acceptance_rate\"] += acceptance_rate;\n        end\n\n        # Iterate over the number of simulation bins.\n        for n in 1:bin_size\n\n            # Attempt to update the fermionic particle configuration.\n            (acceptance_rate, detwf) = local_fermion_update!(\n                detwf, \n                Ne, \n                model_geometry, \n                n_stab_W,\n                δW, \n                rng\n            ) \n                                                                                                        \n            # Record the acceptance rate for attempted local updates of the particle configuration                                                       \n            metadata[\"avg_acceptance_rate\"] += acceptance_rate;\n            \n            # Make measurements, with results being recorded in the measurement container. \n            make_measurements!(\n                measurement_container, \n                detwf, \n                tight_binding_model, \n                determinantal_parameters, \n                model_geometry, \n                Ne, \n                pht\n            )\n\n            # Write measurement for the current bin to file.\n            write_measurements!(\n                bin, \n                n, \n                measurement_container, \n                simulation_info\n            )\n        end\n\n        # Record the last particle configuration used in the current bin. \n        pconfig_cache = detwf.pconfig\n\n        # Process the measurement results, calculating error bars for all measurements. \n        # process_measurements(simulation_info, bin_size)\n    end     \n\n    # Record end time for the simulation. \n    sim_end_time = time()\n\n    # Calculate total time for the simulation. \n    metadata[\"sim_time\"] += sim_end_time - sim_start_time\n\n    # Record the total runtime.\n    metadata[\"total_time\"] += metadata[\"opt_time\"] + metadata[\"sim_time\"]\n\n    # # Write simulation summary TOML file.\n    # save_simulation_info(simulation_info, metadata)\n\n    return nothing\nend \n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    L = parse(Int, ARGS[2])\n    U = parse(Float64, ARGS[3])\n    nup = parse(Int, ARGS[4])\n    ndn = parse(Int, ARGS[5])\n    N_equil = parse(Int, ARGS[6])\n    N_opts = parse(Int, ARGS[7])\n    N_updates = parse(Int, ARGS[8])\n    N_bins = parse(Int, ARGS[9])\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(sID, L, U, nup, ndn, N_equil, N_opts, N_updates, N_bins)\nend","category":"page"},{"location":"usage/#Hubbard-chain-with-MPI-(experimental)","page":"Usage","title":"Hubbard chain with MPI (experimental)","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"In this example we simulate the same system as in example 1, the half-filled Hubbard chain. However in this case, we use a BCS trial wavefunction with a density-density Jastrow factor. A short tes simulation using  this script associated with this example can be run as","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"> mpiexecjl -n 8 julia hubbard_chain_mpi.jl 1 4 1.0 2 2 300 1000 2000 100","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"(The script is forthcoming.)","category":"page"},{"location":"usage/#Hubbard-chain-with-Jastrow-factor","page":"Usage","title":"Hubbard chain with Jastrow factor","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"In this example we simulate the same system as in example 1, the half-filled Hubbard chain. However in this case, we use a BCS trial wavefunction with a density-density Jastrow factor. A short tes simulation using  this script associated with this example can be run as","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"> julia hubbard_chain_jastrow.jl 1 4 1.0 2 2 300 1000 2000 100","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Below you will find a heavily commented script that includes details on what each part of the code is doing.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Import the required packages\nusing LinearAlgebra\nusing Random\nusing Printf\n\nusing LatticeUtilities\nusing VariationalMC\n\n# We define a top-level function for running the VMC simulation.\n# Note that the arguments of this function correspond to the command line\n# arguments used to run this script.\nfunction run_hubbard_chain_simulation(\n    sID, \n    L,\n    U,\n    nup,\n    ndn,\n    N_equil,\n    N_opts,\n    N_updates,\n    N_bins; \n    filepath=\".\"\n)\n    # DEBUG flag which writes information to terminal during the simulation.\n    # For efficeincy, this should always be turned off. \n    debug = false\n\n    # Select which parameters in the variational wavefunction will be optimized.\n    optimize = (\n        # local s-wave pairing\n        Δ_0 = true,\n        # spin-x (in-plane magnetization)\n        Δ_sx = false,\n        # spin-z (out-of-plane magnetization)\n        Δ_sz = true,\n        # (BCS) chemical potential\n        μ = true,\n        # uniform charge density \n        Δ_cdw = false,\n        # density-density Jastrow \n        djastrow = true\n    )\n\n    # Specify whether the model will be particle-hole transformed.\n    # Note that this is required if adding pair fields to the wavefunction.\n    pht = true\n\n    # Construct the foldername the data will be written.\n    df_prefix = @sprintf \"hubbard_chain_U%.2f_nup%.2f_ndn%.2f_L%d_opt\" U, nup, ndn, L\n\n    # Append optimized parameter names to the foldername.\n    datafolder_prefix = create_datafolder_prefix(optimize, df_prefix)\n\n    # Initialize an instance of the SimulationInfo type.\n    # This type tracks of where the data is written, as well as \n    # which version of Julia and VariationalMC are used in the script. \n    simulation_info = SimulationInfo(\n        filepath = filepath, \n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    # We seed this function with a randomly sampled number for the\n    # global random number generator.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the optimization rate for the VMC simulation.\n    dt = 0.03     \n\n    # Set the stabilization factor used in parameter optimization. \n    η = 1e-4    \n\n    # Set the frequency in Monte Carlo steps with which the equal-time Green's function\n    # matrix will be recomputed using the numerical stabilization procedure.\n    n_stab_W = 50\n\n    # Set the frequency in Monte Carlo steps with which the Jastrow T vector will be\n    # recomputed using the numerical stabilization procedure.\n    n_stab_T = 50\n\n    # Specify the maximum allowed error in the equal-time Green's function matrix that\n    # is corrected by numerical stabilization.\n    δW = 1e-3\n\n    # Specify the maximum allowed error in the Jastrow T vector that is corrected \n    # by numerical stabilization.\n    δT = 1e-3\n\n    # Specify the optimization bin size.\n    # The optimization bin size if the number of measurments that are averaged over each time data\n    # is written to file during optimization. \n    opt_bin_size = 3000\n\n    # Calculate the simulation bin size.\n    # The bin size is the number of measurements that are averaged over each time data is written\n    # to file during the simulation.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    # This is a sort of \"notebook\" for tracking extraneous parameters during the VMC simulation.\n    metadata = Dict()\n    metadata[\"N_equil\"] = N_equil\n    metadata[\"N_opts\"] = N_opts\n    metadata[\"N_updates\"] = N_updates\n    metadata[\"N_bins\"] = N_bins\n    metadata[\"seed\"] = seed\n    metadata[\"pht\"] = true\n    metadata[\"δW\"] = δW\n    metadata[\"dt\"] = dt \n    metadata[\"opt_flags\"] = optimize \n    metadata[\"avg_acceptance_rate\"] = 0.0\n    metadata[\"opt_time\"] = 0.0\n    metadata[\"sim_time\"] = 0.0\n    metadata[\"total_time\"] = 0.0\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the UnitCell type.\n    # This struct defines the UnitCell.\n    unit_cell = UnitCell(\n        lattice_vecs = [[1.0]],\n        basis_vecs   = [[0.0]]\n    )\n\n    # Initialize an instance of the Lattice type.\n    # The struct describes the size of the finite periodic lattice to be simulated.\n    # Note that the current version of LatticeUtilities requires \n    # periodic boundary conditions be used.\n    lattice = Lattice(\n        [L], \n        [true]\n    )\n\n    # Define the nearest neighbor bond for a 1D chain.\n    bond_x = Bond(\n        orbitals = (1,1), \n        displacement = [1]\n    )\n\n    # Define the next-nearest neighbor bonds for a 1D chain.\n    bond_xp = Bond(\n        orbitals = (1,1), \n        displacement = [2]\n    )\n\n    # Collect all bond definitions into a single vector.\n    # Note that this has the structure [[nearest],[next-nearest]].\n    bonds = [[bond_x], [bond_xp]]\n    \n    # Initialize an instance of the ModelGeometry type.\n    # This type helps keep track of all the relevant features of the lattice\n    # geometry being simulated, including the defintion of the unit cell,\n    # the size of the finite periodic lattice, and all the relevant\n    # bond defintions that may arise in the model.\n    model_geometry = ModelGeometry(\n        unit_cell, \n        lattice, \n        bonds\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(\n        N_opts, \n        opt_bin_size, \n        N_bins, \n        bin_size,\n        determinantal_parameters,\n        model_geometry\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info, \n        measurement_container\n    )\n\n    ############################\n    ### SET-UP VMC SIMULATION ##\n    ############################\n\n    # Determine the total particle density in the canonical ensemble. \n    (density, Np, Ne) = get_particle_density(nup, ndn)\n\n    # Define the nearest neighbor hopping amplitude, setting the energy scale of the system. \n    t = 1.0;\n\n    # Define the next-nearest neighbor hopping amplitude.\n    tp = 0.0;\n\n    # Define the non-interacting tight binding model.\n    tight_binding_model = TightBindingModel(t, tp)\n\n    # Specify the minimum value of each variational parameter.\n    # Note that this is done to avoid open shell issues.\n    minabs_vpar = 1e-4;\n\n    # Initialize determinantal variational parameters.\n    determinantal_parameters = DeterminantalParameters(\n        optimize, \n        tight_binding_model, \n        model_geometry, \n        minabs_vpar, \n        Ne, \n        pht\n    )\n\n    # Initialize density-density Jastrow variational parameters. \n    djastrow_parameters = JastrowParameters(\n        \"e-den-den\",\n        optimize, \n        model_geometry,\n        rng\n    )\n\n    # Initialize the (fermionic) particle configuration cache.\n    pconfig_cache = nothing\n\n    ###########################\n    ### OPTIMIZATION UPDATES ##\n    ###########################\n\n    # Record start time for optimization. \n    opt_start_time = time()\n\n    # Iterate over optimization updates.\n    for bin in 1:N_opts\n\n        # Initialize the determinantal wavefunction.\n        detwf = get_determinantal_wavefunction(\n            tight_binding_model, \n            determinantal_parameters, \n            optimize, \n            Ne, \n            nup, \n            ndn, \n            model_geometry, \n            rng,\n            pconfig_cache\n        )   \n\n        # Initialize the density-density Jastrow factor.\n        djas_factor = get_jastrow_factor(\n            djastrow_parameters,\n            detwf,\n            model_geometry,\n            pht\n        )\n\n        # Iterate over equilibration/thermalization updates.\n        for step in 1:N_equil \n\n            # Attempt to update the fermionic particle configuration.\n            (acceptance_rate, detwf, djas_factor) = local_fermion_update!(\n                detwf, \n                djas_factor,\n                djastrow_parameters,\n                Ne, \n                model_geometry, \n                pht,\n                n_stab_W,\n                n_stab_T,\n                δW, \n                δT,\n                rng\n            )\n\n            # Record the acceptance rate for attempted local updates of the particle configuration.                                                         \n            metadata[\"avg_acceptance_rate\"] += acceptance_rate;\n        end\n\n        # Iterate over the number of optimization bins.\n        for n in 1:opt_bin_size\n\n            # Attempt to update the fermionic particle configuration.\n            (acceptance_rate, detwf, djas_factor) = local_fermion_update!(\n                detwf, \n                djas_factor,\n                djastrow_parameters,\n                Ne, \n                model_geometry, \n                pht,\n                n_stab_W,\n                n_stab_T,\n                δW, \n                δT,\n                rng\n            ) \n                                                                                                        \n            # Record the acceptance rate for attempted local updates of the particle configuration                                                       \n            metadata[\"avg_acceptance_rate\"] += acceptance_rate;\n            \n            # Make measurements, with results being recorded in the measurement container. \n            make_measurements!(\n                measurement_container, \n                detwf, \n                tight_binding_model, \n                djas_factor,\n                djastrow_parameters,\n                determinantal_parameters, \n                model_geometry, \n                Ne, \n                pht\n            )\n\n            # Write measurement for the current bin to file.\n            write_measurements!(\n                bin, \n                n, \n                measurement_container, \n                simulation_info\n            )\n        end\n\n        # Record the last particle configuration used in the current bin. \n        pconfig_cache = detwf.pconfig\n\n        # Process the measurement results, calculating error bars for all measurements. \n        # process_measurements(simulation_info, opt_bin_size)\n\n        # Attempt an update to the variational parameters using the Stochastic Reconfiguration procedure. \n        stochastic_reconfiguration!( \n            measurement_container,  \n            determinantal_parameters, \n            djastrow_parameters,\n            η, \n            dt, \n            bin, \n            opt_bin_size\n        )  \n    end     \n\n    # Record end time for optimization.\n    opt_end_time = time()\n\n    # Calculate the total time for optimization. \n    metadata[\"opt_time\"] += opt_end_time - opt_start_time\n\n    #########################\n    ### SIMULATION UPDATES ##\n    #########################\n\n    # Record start time for the simulation.\n    sim_start_time = time()\n\n    # Iterate over simulation updates.\n    for bin in 1:N_updates\n\n        # Initialize the determinantal wavefunction.\n        detwf = get_determinantal_wavefunction(\n            tight_binding_model, \n            determinantal_parameters, \n            optimize, \n            Ne, \n            nup, \n            ndn, \n            model_geometry, \n            rng,\n            pconfig_cache\n        )   \n\n        # Initialize the density-density Jastrow factor.\n        djas_factor = get_jastrow_factor(\n            djastrow_parameters,\n            detwf,\n            model_geometry,\n            pht\n        )\n\n        # Iterate over equilibration/thermalization updates.\n        for step in 1:N_equil \n\n            # Attempt to update the fermionic particle configuration.\n            (acceptance_rate, detwf, djas_factor) = local_fermion_update!(\n                detwf, \n                Ne, \n                model_geometry, \n                n_stab_W,\n                δW, \n                rng\n            )\n\n            # Record the acceptance rate for attempted local updates of the particle configuration.                                                         \n            metadata[\"avg_acceptance_rate\"] += acceptance_rate;\n        end\n\n        # Iterate over the number of simulation bins.\n        for n in 1:bin_size\n\n            # Attempt to update the fermionic particle configuration.\n            (acceptance_rate, detwf) = local_fermion_update!(\n                detwf, \n                djas_factor,\n                djastrow_parameters,\n                Ne, \n                model_geometry, \n                pht,\n                n_stab_W,\n                n_stab_T,\n                δW, \n                δT,\n                rng\n            ) \n                                                                                                        \n            # Record the acceptance rate for attempted local updates of the particle configuration                                                       \n            metadata[\"avg_acceptance_rate\"] += acceptance_rate;\n            \n            # Make measurements, with results being recorded in the measurement container. \n            make_measurements!(\n                measurement_container, \n                detwf, \n                tight_binding_model, \n                djas_factor,\n                djastrow_parameters,\n                determinantal_parameters, \n                model_geometry, \n                Ne, \n                pht\n            )\n\n            # Write measurement for the current bin to file.\n            write_measurements!(\n                bin, \n                n, \n                measurement_container, \n                simulation_info\n            )\n        end\n\n        # Record the last particle configuration used in the current bin. \n        pconfig_cache = detwf.pconfig\n\n        # Process the measurement results, calculating error bars for all measurements. \n        # process_measurements(simulation_info, bin_size)\n    end     \n\n    # Record end time for the simulation. \n    sim_end_time = time()\n\n    # Calculate total time for the simulation. \n    metadata[\"sim_time\"] += sim_end_time - sim_start_time\n\n    # Record the total runtime.\n    metadata[\"total_time\"] += metadata[\"opt_time\"] + metadata[\"sim_time\"]\n\n    # # Write simulation summary TOML file.\n    # save_simulation_info(simulation_info, metadata)\n\n    return nothing\nend \n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    L = parse(Int, ARGS[2])\n    U = parse(Float64, ARGS[3])\n    nup = parse(Int, ARGS[4])\n    ndn = parse(Int, ARGS[5])\n    N_equil = parse(Int, ARGS[6])\n    N_opts = parse(Int, ARGS[7])\n    N_updates = parse(Int, ARGS[8])\n    N_bins = parse(Int, ARGS[9])\n\n    # Run the simulation.\n    run_hubbard_chain_simulation(sID, L, U, nup, ndn, N_equil, N_opts, N_updates, N_bins)\nend","category":"page"},{"location":"usage/#Square-Hubbard-model-with-Jastrow-factor","page":"Usage","title":"Square Hubbard model with Jastrow factor","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"In this next example, we will work though simulating the repulsive Hubbard model  on a 2D square lattice at half-filling. ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The Hubbard Hamiltonian for a 2D square lattice is given by ","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"hatH = -t sum_langle ijrangle sigma (hatc^dagger_jsigmahatc^phantom dagger_i sigma + rm hc)\n+ U sum_i hatn_i uparrowhatn_i downarrow - mu sum_i sigma hatn_i sigma","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"where hatc^dagger_i sigma  (hatc^phantom dagger_i sigma) creates (annihilates) a spin sigma electron on site i in the lattice, and hatn_i sigma = hatc^dagger_i sigma hatc^phantom dagger_i sigma is the spin-sigma electron number operator for site i. In the above Hamiltonian t is the nearest neighbor hopping integral and U  0 controls the strength of the on-site Hubbard repulsion. Lastly, we consider the case that the system is half-filled and particle-hole symmetric, which occurs when when the chemical potential is zero, mu = 00.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Suppose we want to simulate a half-filled square Hubbard (mu = 00) of size N=4times 4 with U=10 with a uniform  d-wave trial wavefunction and a density-density Jastrow factor. This is accomplished by running the script associated with this example using the command","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"> julia hubbard_square_jastrow.jl 1 4 1.0 2 2 300 1000 2000 100","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Below you will find a heavily commented script that includes details on what each part of the code is doing.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# Import the required packages\nusing LinearAlgebra\nusing Random\nusing Printf\n\nusing LatticeUtilities\nusing VariationalMC\n\n# We define a top-level function for running the VMC simulation.\n# Note that the arguments of this function correspond to the command line\n# arguments used to run this script.\nfunction run_hubbard_square_simulation(\n    sID, \n    L,\n    U,\n    nup,\n    ndn,\n    N_equil,\n    N_opts,\n    N_updates,\n    N_bins; \n    filepath=\".\"\n)\n    # DEBUG flag which writes information to terminal during the simulation.\n    # For efficeincy, this should always be turned off. \n    debug = false\n\n    # Select which parameters in the variational wavefunction will be optimized.\n    optimize = (\n        # local s-wave pairing\n        Δ_0 = false,\n        # site-dependent s-wave pairing  \n        Δ_spd = false,\n        # local d-wave pairing\n        Δ_d = true,\n        # site-dependent d-wave pairing \n        Δ_dpd = false,          \n        # pairing momentum\n        q_p = false,\n        # spin-x (in-plane magnetization)\n        Δ_sx = false,\n        # spin-z (out-of-plane magnetization)\n        Δ_sz = true,\n        # site-dependent spin density\n        Δ_ssd = false,\n        # (BCS) chemical potential\n        μ = false,\n        # uniform charge density \n        Δ_cdw = false,\n        # site-dependent charge density\n        Δ_csd = false,\n        # density-density Jastrow \n        djastrow = true,\n    )\n\n    # Specify whether the model will be particle-hole transformed.\n    # Note that this is required if adding pair fields to the wavefunction.\n    pht = true\n\n    # Construct the foldername the data will be written.\n    df_prefix = @sprintf \"hubbard_chain_U%.2f_nup%.2f_ndn%.2f_L%d_opt\" U, nup, ndn, L\n\n    # Append optimized parameter names to the foldername.\n    datafolder_prefix = create_datafolder_prefix(optimize, df_prefix)\n\n    # Initialize an instance of the SimulationInfo type.\n    # This type tracks of where the data is written, as well as \n    # which version of Julia and VariationalMC are used in the script. \n    simulation_info = SimulationInfo(\n        filepath = filepath, \n        datafolder_prefix = datafolder_prefix,\n        sID = sID\n    )\n\n    # Initialize the directory the data will be written.\n    initialize_datafolder(simulation_info)\n\n    # Initialize a random number generator that will be used throughout the simulation.\n    # We seed this function with a randomly sampled number for the\n    # global random number generator.\n    seed = abs(rand(Int))\n    rng = Xoshiro(seed)\n\n    # Set the optimization rate for the VMC simulation.\n    dt = 0.03     \n\n    # Set the stabilization factor used in parameter optimization. \n    η = 1e-4    \n\n    # Set the frequency in Monte Carlo steps with which the equal-time Green's function\n    # matrix will be recomputed using the numerical stabilization procedure.\n    n_stab_W = 50\n\n    # Set the frequency in Monte Carlo steps with which the Jastrow T vector will be\n    # recomputed using the numerical stabilization procedure.\n    n_stab_T = 50\n\n    # Specify the maximum allowed error in the equal-time Green's function matrix that\n    # is corrected by numerical stabilization.\n    δW = 1e-3\n\n    # Specify the maximum allowed error in the Jastrow T vector that is corrected \n    # by numerical stabilization.\n    δT = 1e-3\n\n    # Specify the optimization bin size.\n    # The optimization bin size if the number of measurments that are averaged over each time data\n    # is written to file during optimization. \n    opt_bin_size = 3000\n\n    # Calculate the simulation bin size.\n    # The bin size is the number of measurements that are averaged over each time data is written\n    # to file during the simulation.\n    bin_size = div(N_updates, N_bins)\n\n    # Initialize a dictionary to store additional information about the simulation.\n    # This is a sort of \"notebook\" for tracking extraneous parameters during the VMC simulation.\n    metadata = Dict()\n    metadata[\"N_equil\"] = N_equil\n    metadata[\"N_opts\"] = N_opts\n    metadata[\"N_updates\"] = N_updates\n    metadata[\"N_bins\"] = N_bins\n    metadata[\"seed\"] = seed\n    metadata[\"pht\"] = true\n    metadata[\"δW\"] = δW\n    metadata[\"dt\"] = dt \n    metadata[\"opt_flags\"] = optimize \n    metadata[\"avg_acceptance_rate\"] = 0.0\n    metadata[\"opt_time\"] = 0.0\n    metadata[\"sim_time\"] = 0.0\n    metadata[\"total_time\"] = 0.0\n\n    #######################\n    ### DEFINE THE MODEL ##\n    #######################\n\n    # Initialize an instance of the UnitCell type.\n    # This struct defines the UnitCell.\n    unit_cell = UnitCell(\n        lattice_vecs = [[1.0, 0.0], [0.0, 1.0]],\n        basis_vecs   = [[0.0, 0.0]]\n    )\n\n    # Initialize an instance of the Lattice type.\n    # The struct describes the size of the finite periodic lattice to be simulated.\n    # Note that the current version of LatticeUtilities requires \n    # periodic boundary conditions be used.\n    lattice = Lattice(\n        [L, L], \n        [true, true]\n    )\n\n    # Define the nearest neighbor x-bond for a square lattice.\n    bond_x = Bond(\n        orbitals = (1,1), \n        displacement = [1]\n    )\n\n    # Define the nearest neighbor y-bond for a square lattice.\n    bond_y = Bond(\n        orbitals = (1,1), \n        displacement = [0,1]\n    )\n\n    # Define the next-nearest neighbor bonds for a square lattice.\n    bond_xy = Bond(\n        orbitals = (1,1), \n        displacement = [1,1]\n    )\n\n    # Define the next-nearest neighbor bonds for a square lattice.\n    bond_yx = Bond(\n        orbitals = (1,1), \n        displacement = [1,-1]\n    )\n\n    # Collect all bond definitions into a single vector.\n    # Note that this has the structure [[nearest],[next-nearest]].\n    bonds = [[bond_x, bond_y], [bond_xy, bond_yx]]\n    \n    # Initialize an instance of the ModelGeometry type.\n    # This type helps keep track of all the relevant features of the lattice\n    # geometry being simulated, including the defintion of the unit cell,\n    # the size of the finite periodic lattice, and all the relevant\n    # bond defintions that may arise in the model.\n    model_geometry = ModelGeometry(\n        unit_cell, \n        lattice, \n        bonds\n    )\n\n    ##############################\n    ### INITIALIZE MEASUREMENTS ##\n    ##############################\n\n    # Initialize the container that measurements will be accumulated into.\n    measurement_container = initialize_measurement_container(\n        N_opts, \n        opt_bin_size, \n        N_bins, \n        bin_size,\n        determinantal_parameters,\n        model_geometry\n    )\n\n    # Initialize the sub-directories to which the various measurements will be written.\n    initialize_measurement_directories(\n        simulation_info, \n        measurement_container\n    )\n\n    ############################\n    ### SET-UP VMC SIMULATION ##\n    ############################\n\n    # Determine the total particle density in the canonical ensemble. \n    (density, Np, Ne) = get_particle_density(nup, ndn)\n\n    # Define the nearest neighbor hopping amplitude, setting the energy scale of the system. \n    t = 1.0;\n\n    # Define the next-nearest neighbor hopping amplitude.\n    tp = 0.0;\n\n    # Define the non-interacting tight binding model.\n    tight_binding_model = TightBindingModel(t, tp)\n\n    # Specify the minimum value of each variational parameter.\n    # Note that this is done to avoid open shell issues.\n    minabs_vpar = 1e-4;\n\n    # Initialize determinantal variational parameters.\n    determinantal_parameters = DeterminantalParameters(\n        optimize, \n        tight_binding_model, \n        model_geometry, \n        minabs_vpar, \n        Ne, \n        pht\n    )\n\n    # Initialize density-density Jastrow variational parameters. \n    djastrow_parameters = JastrowParameters(\n        \"e-den-den\",\n        optimize, \n        model_geometry,\n        rng\n    )\n\n    # Initialize the (fermionic) particle configuration cache.\n    pconfig_cache = nothing\n\n    ###########################\n    ### OPTIMIZATION UPDATES ##\n    ###########################\n\n    # Record start time for optimization. \n    opt_start_time = time()\n\n    # Iterate over optimization updates.\n    for bin in 1:N_opts\n\n        # Initialize the determinantal wavefunction.\n        detwf = get_determinantal_wavefunction(\n            tight_binding_model, \n            determinantal_parameters, \n            optimize, \n            Ne, \n            nup, \n            ndn, \n            model_geometry, \n            rng,\n            pconfig_cache\n        )   \n\n        # Initialize the density-density Jastrow factor.\n        djas_factor = get_jastrow_factor(\n            djastrow_parameters,\n            detwf,\n            model_geometry,\n            pht\n        )\n\n        # Iterate over equilibration/thermalization updates.\n        for step in 1:N_equil \n\n            # Attempt to update the fermionic particle configuration.\n            (acceptance_rate, detwf, djas_factor) = local_fermion_update!(\n                detwf, \n                djas_factor,\n                djastrow_parameters,\n                Ne, \n                model_geometry, \n                pht,\n                n_stab_W,\n                n_stab_T,\n                δW, \n                δT,\n                rng\n            )\n\n            # Record the acceptance rate for attempted local updates of the particle configuration.                                                         \n            metadata[\"avg_acceptance_rate\"] += acceptance_rate;\n        end\n\n        # Iterate over the number of optimization bins.\n        for n in 1:opt_bin_size\n\n            # Attempt to update the fermionic particle configuration.\n            (acceptance_rate, detwf, djas_factor) = local_fermion_update!(\n                detwf, \n                djas_factor,\n                djastrow_parameters,\n                Ne, \n                model_geometry, \n                pht,\n                n_stab_W,\n                n_stab_T,\n                δW, \n                δT,\n                rng\n            ) \n                                                                                                        \n            # Record the acceptance rate for attempted local updates of the particle configuration                                                       \n            metadata[\"avg_acceptance_rate\"] += acceptance_rate;\n            \n            # Make measurements, with results being recorded in the measurement container. \n            make_measurements!(\n                measurement_container, \n                detwf, \n                tight_binding_model, \n                djas_factor,\n                djastrow_parameters,\n                determinantal_parameters, \n                model_geometry, \n                Ne, \n                pht\n            )\n\n            # Write measurement for the current bin to file.\n            write_measurements!(\n                bin, \n                n, \n                measurement_container, \n                simulation_info\n            )\n        end\n\n        # Record the last particle configuration used in the current bin. \n        pconfig_cache = detwf.pconfig\n\n        # Process the measurement results, calculating error bars for all measurements. \n        # process_measurements(simulation_info, opt_bin_size)\n\n        # Attempt an update to the variational parameters using the Stochastic Reconfiguration procedure. \n        stochastic_reconfiguration!( \n            measurement_container,  \n            determinantal_parameters, \n            djastrow_parameters,\n            η, \n            dt, \n            bin, \n            opt_bin_size\n        )  \n    end     \n\n    # Record end time for optimization.\n    opt_end_time = time()\n\n    # Calculate the total time for optimization. \n    metadata[\"opt_time\"] += opt_end_time - opt_start_time\n\n    #########################\n    ### SIMULATION UPDATES ##\n    #########################\n\n    # Record start time for the simulation.\n    sim_start_time = time()\n\n    # Iterate over simulation updates.\n    for bin in 1:N_updates\n\n        # Initialize the determinantal wavefunction.\n        detwf = get_determinantal_wavefunction(\n            tight_binding_model, \n            determinantal_parameters, \n            optimize, \n            Ne, \n            nup, \n            ndn, \n            model_geometry, \n            rng,\n            pconfig_cache\n        )   \n\n        # Initialize the density-density Jastrow factor.\n        djas_factor = get_jastrow_factor(\n            djastrow_parameters,\n            detwf,\n            model_geometry,\n            pht\n        )\n\n        # Iterate over equilibration/thermalization updates.\n        for step in 1:N_equil \n\n            # Attempt to update the fermionic particle configuration.\n            (acceptance_rate, detwf, djas_factor) = local_fermion_update!(\n                detwf, \n                Ne, \n                model_geometry, \n                n_stab_W,\n                δW, \n                rng\n            )\n\n            # Record the acceptance rate for attempted local updates of the particle configuration.                                                         \n            metadata[\"avg_acceptance_rate\"] += acceptance_rate;\n        end\n\n        # Iterate over the number of simulation bins.\n        for n in 1:bin_size\n\n            # Attempt to update the fermionic particle configuration.\n            (acceptance_rate, detwf) = local_fermion_update!(\n                detwf, \n                djas_factor,\n                djastrow_parameters,\n                Ne, \n                model_geometry, \n                pht,\n                n_stab_W,\n                n_stab_T,\n                δW, \n                δT,\n                rng\n            ) \n                                                                                                        \n            # Record the acceptance rate for attempted local updates of the particle configuration                                                       \n            metadata[\"avg_acceptance_rate\"] += acceptance_rate;\n            \n            # Make measurements, with results being recorded in the measurement container. \n            make_measurements!(\n                measurement_container, \n                detwf, \n                tight_binding_model, \n                djas_factor,\n                djastrow_parameters,\n                determinantal_parameters, \n                model_geometry, \n                Ne, \n                pht\n            )\n\n            # Write measurement for the current bin to file.\n            write_measurements!(\n                bin, \n                n, \n                measurement_container, \n                simulation_info\n            )\n        end\n\n        # Record the last particle configuration used in the current bin. \n        pconfig_cache = detwf.pconfig\n\n        # Process the measurement results, calculating error bars for all measurements. \n        # process_measurements(simulation_info, bin_size)\n    end     \n\n    # Record end time for the simulation. \n    sim_end_time = time()\n\n    # Calculate total time for the simulation. \n    metadata[\"sim_time\"] += sim_end_time - sim_start_time\n\n    # Record the total runtime.\n    metadata[\"total_time\"] += metadata[\"opt_time\"] + metadata[\"sim_time\"]\n\n    # # Write simulation summary TOML file.\n    # save_simulation_info(simulation_info, metadata)\n\n    return nothing\nend \n\n# Only execute if the script is run directly from the command line.\nif abspath(PROGRAM_FILE) == @__FILE__\n\n    # Read in the command line arguments.\n    sID = parse(Int, ARGS[1]) # simulation ID\n    L = parse(Int, ARGS[2])\n    U = parse(Float64, ARGS[3])\n    nup = parse(Int, ARGS[4])\n    ndn = parse(Int, ARGS[5])\n    N_equil = parse(Int, ARGS[6])\n    N_opts = parse(Int, ARGS[7])\n    N_updates = parse(Int, ARGS[8])\n    N_bins = parse(Int, ARGS[9])\n\n    # Run the simulation.\n    run_hubbard_square_simulation(sID, L, U, nup, ndn, N_equil, N_opts, N_updates, N_bins)\nend","category":"page"},{"location":"#VariationalMC.jl","page":"Home","title":"VariationalMC.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for VariationalMC.jl. This package impelments the variational Monte Carlo (VMC) method for Hubbard and electron-phonon interactions (coming soon).","category":"page"},{"location":"","page":"Home","title":"Home","text":"This code is currently the experimental stage of development. Use with caution. ","category":"page"},{"location":"#Funding","page":"Home","title":"Funding","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The development of this code was supported by the U.S. Department of Energy, Office of Science, Office of Workforce Development for Teachers and Scientists, Office of Science Graduate Student Research (SCGSR) program. The SCGSR program is administered by the Oak Ridge Institute for Science and Education (ORISE) for the DOE. ORISE is managed by ORAU under contract number DE-SC0014664.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the VariationalMC.jl, simply open the Julia REPL and run the commands","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\npkg> add VariationalMC","category":"page"},{"location":"","page":"Home","title":"Home","text":"or equivalently via Pkg do","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"VariationalMC\")","category":"page"},{"location":"#Notable-External-Package-Dependencies","page":"Home","title":"Notable External Package Dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This section reviews some notable package dependencies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"LatticeUtilties.jl: Package that is used to represent arbitrary lattice geometries.\nOrderedCollections.jl: Package that implements associative containers that preserve the order of insertion.\nJLD2.jl: Package used to write data to binary files in an HDF5 compatible format. \nCSV.jl: Package used for handling delimited text data.","category":"page"},{"location":"#Contact","page":"Home","title":"Contact","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For questions and comments regarding this package, please email Andy Tanjaroon Ly at atanjaro@vols.utk.edu.","category":"page"}]
}
